/*! BBH London */ ! function(modules) {

    function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) return installedModules[moduleId].exports;
        var module = installedModules[moduleId] = {
            exports: {},
            id: moduleId,
            loaded: !1
        };
        return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), module.loaded = !0, module.exports
    }
    var installedModules = {};
    return __webpack_require__.m = modules, __webpack_require__.c = installedModules, __webpack_require__.p = "scripts/", __webpack_require__(0)
}([function(module, exports, __webpack_require__) {
    window.codeplayground = window.codeplayground || {}, __webpack_require__(54), __webpack_require__(55), __webpack_require__(52), __webpack_require__(53), __webpack_require__(50), __webpack_require__(56), __webpack_require__(51), __webpack_require__(49), __webpack_require__(48), __webpack_require__(47), __webpack_require__(45), __webpack_require__(44), __webpack_require__(46), __webpack_require__(96), __webpack_require__(11), __webpack_require__(10), __webpack_require__(95), __webpack_require__(97), __webpack_require__(9), __webpack_require__(29), __webpack_require__(28), __webpack_require__(30), __webpack_require__(12), __webpack_require__(13), __webpack_require__(14), __webpack_require__(3), __webpack_require__(6), __webpack_require__(2), __webpack_require__(92), __webpack_require__(93), __webpack_require__(94), __webpack_require__(5), __webpack_require__(4), __webpack_require__(7), __webpack_require__(16), __webpack_require__(19), __webpack_require__(17), __webpack_require__(15), __webpack_require__(26), __webpack_require__(23), __webpack_require__(105), __webpack_require__(22), __webpack_require__(24), __webpack_require__(25), __webpack_require__(27), __webpack_require__(21), __webpack_require__(102), __webpack_require__(116), __webpack_require__(57), __webpack_require__(106), __webpack_require__(119), __webpack_require__(99), __webpack_require__(124), __webpack_require__(57), __webpack_require__(114), __webpack_require__(109), __webpack_require__(103), __webpack_require__(113), __webpack_require__(108), __webpack_require__(20), __webpack_require__(118), __webpack_require__(115), __webpack_require__(98), __webpack_require__(121), __webpack_require__(125), __webpack_require__(122), __webpack_require__(110), __webpack_require__(100), __webpack_require__(112), __webpack_require__(120), __webpack_require__(123), __webpack_require__(104), __webpack_require__(117), __webpack_require__(111), __webpack_require__(101), __webpack_require__(107), __webpack_require__(8),
        function(codeplayground, soma) {
            "use strict";
            codeplayground.events = {
                STARTUP: "codeplayground.events.startup",
                CHECK_LOCALE: "codeplayground.events.checkLocale",
                RENDER: "codeplayground.events.render",
                PRELOAD: "codeplayground.events.preload",
                CHANGE_STATE: "codeplayground.events.changeState",
                STATE_CHANGED: "codeplayground.events.stateChanged",
                INITIALIZE_PLAYGROUND: "codeplayground.events.initializePlayground",
                PLAYTHINGS_INITIALISED: "codeplayground.events.playthingsInitialised",
                PLAYGROUND_READY: "codeplayground.events.playgroundReady",
                VIEWPORT_CHANGED: "codeplayground.events.viewportChanged",
                LOCK_VIEWPORT: "codeplayground.events.lockViewport",
                UNLOCK_VIEWPORT: "codeplayground.events.unlockViewport",
                RESIZE: "codeplayground.events.resize",
                INTRO_IN: "codeplayground.events.introIn",
                INTRO_OUT: "codeplayground.events.introOut",
                INTRO_FINISHED: "codeplayground.events.introFinished",
                PLAYTHING_READY: "codeplayground.events.playthingReady",
                PLAYTHING_SELECTED: "codeplayground.events.playthingSelected",
                PLAYTHING_UNSELECTED: "codeplayground.events.playthingUnselected",
                HOLD_PLAYTHING: "codeplayground.events.holdPlaything",
                RELEASE_PLAYTHING: "codeplayground.events.releasePlaything",
                PAUSE_PLAYTHING: "codeplayground.events.pausePlaything",
                PAUSE_ALL_PLAYTHING: "codeplayground.events.pauseAllPlaything",
                RESUME_PLAYTHING: "codeplayground.events.resumePlaything",
                RESUME_ALL_PLAYTHING: "codeplayground.events.resumeAllPlaything",
                LOCK_PLAYTHING: "codeplayground.events.lockPlaything",
                UNLOCK_PLAYTHING: "codeplayground.events.unlockPlaything",
                UPDATE_PLAYTHING: "codeplayground.events.updatePlaything",
                MUTE: "codeplayground.events.mute",
                UNMUTE: "codeplayground.events.unmute",
                CONFIRM_RESET: "codeplayground.events.confirmReset",
                SHOW_EDITOR: "codeplayground.events.showEditor",
                HIDE_EDITOR: "codeplayground.events.hideEditor",
                UPDATE_PROPERTIES: "codeplayground.events.updateProperties",
                PROPERTIES_CHANGED: "codeplayground.events.propertiesChanged",
                RESET_ALL_PROPERTIES: "codeplayground.events.resetAllProperties",
                SHOW_INFO: "codeplayground.events.showInfo",
                HIDE_INFO: "codeplayground.events.hideInfo",
                SHEEP_POS: "codeplayground.events.sheepPos",
                GRASS_IS_HERE: "codeplayground.events.grassIsHere",
                TURNTABLE_CHANGED: "codeplayground.events.turntableChanged",
                SOUNDS_LOADED: "codeplayground.events.soundsLoaded",
                VIEW_FOCUS: "codeplayground.events.viewFocus",
                ELEMENT_FOCUS: "codeplayground.events.elementFocus",
                ELEMENT_HIT: "codeplayground.events.elementHit",
                FOCUS_PLAYTHING: "codeplayground.events.focusPlaything",
                ELEMENT_FOCUSED: "codeplayground.events.elementFocused",
                SCROLL: "codeplayground.events.scroll"
            }, codeplayground.analytics = {
                CATEGORY_CONTROL: "Control",
                CATEGORY_INFORMATION: "Information",
                CATEGORY_BOOK_A_SESSION: "Book_session",
                CATEGORY_WATCH_FILMS: "Watch_Films",
                CATEGORY_FURTHER_LEARNING: "Further_Learning"
            }, codeplayground.CodePlayground = soma.Application.extend({
                constructor: function(rootElement) {
                    this.rootElement = rootElement, soma.Application.call(this)
                },
                init: function() {
                    this.injector.mapValue("breakpoint", this.createPlugin(plugins.BreakpointPlugin)), this.injector.mapValue("i18n", this.createPlugin(plugins.i18nPlugin, {})), codeplayground.canPlaySounds = createjs.Sound.initializeDefaultPlugins(), createjs.Sound.alternateExtensions = ["mp3"], codeplayground.AudioAutoplay.init(), this.injector.mapClass("configModel", codeplayground.ConfigModel, !0), this.injector.mapClass("stateModel", codeplayground.StateModel, !0), this.injector.mapClass("deviceModel", codeplayground.DeviceModel, !0), this.injector.mapClass("analyticsModel", codeplayground.AnalyticsModel, !0), this.injector.mapClass("playgroundModel", codeplayground.PlaygroundModel, !0), this.injector.mapClass("cookieModel", codeplayground.CookieModel, !0), this.injector.createInstance(codeplayground.Accessibility), this.injector.createInstance(codeplayground.StateModel), this.commands.add(codeplayground.events.STARTUP, codeplayground.StartupCommand), this.commands.add(codeplayground.events.PRELOAD, codeplayground.PreloadCommand), this.commands.add(codeplayground.events.CHECK_LOCALE, codeplayground.CheckLocaleCommand), this.commands.add(codeplayground.events.PLAYTHING_SELECTED, codeplayground.SelectPlaythingCommand), this.commands.add(codeplayground.events.PLAYTHING_UNSELECTED, codeplayground.UnselectPlaythingCommand), this.commands.add(codeplayground.events.UPDATE_PROPERTIES, codeplayground.UpdatePropertiesCommand), this.commands.add(codeplayground.events.RESET_ALL_PROPERTIES, codeplayground.ResetAllPropertiesCommand), this.commands.add(codeplayground.events.PROPERTIES_CHANGED, codeplayground.PropertiesChangedCommand), this.createTemplate(codeplayground.LoaderView, this.rootElement.getElementById("loader")), this.createTemplate(codeplayground.EditorView, this.rootElement.getElementById("editor")), this.createTemplate(codeplayground.ConfirmResetView, this.rootElement.getElementById("confirm-reset")), this.createTemplate(codeplayground.InfoView, this.rootElement.getElementById("info")), this.createTemplate(codeplayground.IntroView, this.rootElement.getElementById("intro")), this.createTemplate(codeplayground.CookieView, this.rootElement.getElementById("cookie")), this.mediators.create(codeplayground.PlaygroundView, this.rootElement.getElementById("playground"))
                },
                start: function() {
                    this.ready(function() {
                        this.dispatcher.dispatch(codeplayground.events.CHANGE_STATE, "preload")
                    }.bind(this))
                   
                }
            }), new codeplayground.CodePlayground(document)
        }(window.codeplayground = window.codeplayground || {}, soma), ("undefined" == typeof window.console || "undefined" == typeof window.console.log) && (window.console = {
            log: function() {}
        }), "undefined" == typeof window.location.origin && (window.location.origin = window.location.protocol + "//" + window.location.hostname),
        function() {
            "use strict";
            HTMLElement.prototype.vendorStyle = function(prop, val) {
                var capProp = prop.charAt(0).toUpperCase() + prop.split(1);
                this.style[prop] = val, this.style["-webkit-" + prop] = val, this.style["Moz" + capProp] = val, this.style["-o-" + prop] = val, this.style["-ms-" + prop] = val
            }
        }(),
        function() {
            "use strict";
            for (var lastTime = 0, vendors = ["ms", "moz", "webkit", "o"], x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"], window.cancelAnimationFrame = window[vendors[x] + "CancelAnimationFrame"] || window[vendors[x] + "CancelRequestAnimationFrame"];
            window.requestAnimationFrame || (window.requestAnimationFrame = function(callback) {
                var currTime = (new Date).getTime(),
                    timeToCall = Math.max(0, 16 - (currTime - lastTime)),
                    id = window.setTimeout(function() {
                        callback(currTime + timeToCall)
                    }, timeToCall);
                return lastTime = currTime + timeToCall, id
            }), window.cancelAnimationFrame || (window.cancelAnimationFrame = function(id) {
                clearTimeout(id)
            })
        }(),
        function() {
            "use strict";
            if (document.all && !window.setTimeout.isPolyfill) {
                var __nativeST__ = window.setTimeout;
                window.setTimeout = function(vCallback, nDelay) {
                    var aArgs = Array.prototype.slice.call(arguments, 2);
                    return __nativeST__(vCallback instanceof Function ? function() {
                        vCallback.apply(null, aArgs)
                    } : vCallback, nDelay)
                }, window.setTimeout.isPolyfill = !0
            }
            if (document.all && !window.setInterval.isPolyfill) {
                var __nativeSI__ = window.setInterval;
                window.setInterval = function(vCallback, nDelay) {
                    var aArgs = Array.prototype.slice.call(arguments, 2);
                    return __nativeSI__(vCallback instanceof Function ? function() {
                        vCallback.apply(null, aArgs)
                    } : vCallback, nDelay)
                }, window.setInterval.isPolyfill = !0
            }
        }()
}, function(module) {
    module.exports = function(src) {
        "function" == typeof execScript ? execScript(src) : eval.call(null, src)
    }
}, function() {
    ! function(codeplayground) {
        "use strict";
        var CheckLocaleCommand = function(dispatcher) {
            this.execute = function() {
                var qs = window.location.search,
                    lang = qs.match(/lang=(.{5})/);
                lang ? dispatcher.dispatch(window.plugins.i18nPlugin.events.UPDATE, lang[1]) : dispatcher.dispatch(window.plugins.i18nPlugin.events.UPDATE)
            }
        };
        codeplayground.CheckLocaleCommand = CheckLocaleCommand
    }(window.codeplayground = window.codeplayground || {})
}, function() {
    ! function(codeplayground) {
        "use strict";
        var PreloadCommand = function(dispatcher, i18n, configModel) {
            this.execute = function() {
                dispatcher.addEventListener(window.plugins.i18nPlugin.events.UPDATED, function() {
                    dispatcher.dispatch(codeplayground.events.CHANGE_STATE, "startup")
                }), i18n.loadConfig(configModel.getLocaleConfigUrl()).then(function() {
                    dispatcher.dispatch(codeplayground.events.CHECK_LOCALE)
                })
            }
        };
        codeplayground.PreloadCommand = PreloadCommand
    }(window.codeplayground = window.codeplayground || {})
}, function() {
    ! function(codeplayground) {
        "use strict";
        var PropertiesChangedCommand = function(dispatcher, playgroundModel) {
            this.execute = function() {
                playgroundModel.hasChanged = !0
            }
        };
        codeplayground.PropertiesChangedCommand = PropertiesChangedCommand
    }(window.codeplayground = window.codeplayground || {})
}, function() {
    ! function(codeplayground) {
        "use strict";
        var ResetAllPropertiesCommand = function(dispatcher, playgroundModel) {
            this.execute = function() {
                playgroundModel.resetAll()
            }
        };
        codeplayground.ResetAllPropertiesCommand = ResetAllPropertiesCommand
    }(window.codeplayground = window.codeplayground || {})
}, function() {
    ! function(codeplayground) {
        "use strict";
        codeplayground.StartupCommand = function(dispatcher, analyticsModel, playgroundModel) {
            this.execute = function() {
                navigator.userAgent.match(/iPad;.*CPU.*OS 7_\d/i) && document.documentElement.classList.add("ipad", "ios7"), window.Modernizr.touch && window.FastClick.attach(document.body), dispatcher.dispatch(codeplayground.events.RENDER), analyticsModel.init(), playgroundModel.init(), /[?&]sound=off/.test(location.search) && dispatcher.dispatch(codeplayground.events.MUTE)
            }
        }
    }(window.codeplayground = window.codeplayground || {})
}, function() {
    ! function(cp) {
        "use strict";
        var VIEWS = ["PlaygroundView", "CuboidControlsView", "AyeView"],
            CODE_MAP = {
                9: "TAB",
                13: "ENTER",
                32: "SPACE",
                37: "LEFT",
                38: "UP",
                39: "RIGHT",
                40: "DOWN"
            },
            METHOD_MAP = {
                TAB: "focusView",
                LEFT: "focusNextElement",
                UP: "focusNextElement",
                RIGHT: "focusNextElement",
                DOWN: "focusNextElement",
                ENTER: "hitElement",
                SPACE: "hitElement"
            },
            Accessibility = function(dispatcher) {
                this.dispatcher = dispatcher, this.currentView = 0, this.isActive = !0, this.focus = !1, this.reader = document.getElementById("playground-reader"), window.addEventListener("keyup", this.handleKeyup.bind(this), !1), window.addEventListener("keydown", this.handleKeydown.bind(this), !1), this.dispatcher.addEventListener(cp.events.ELEMENT_FOCUSED, this.announceElement.bind(this)), this.dispatcher.addEventListener(cp.events.LOCK_VIEWPORT, this.lock.bind(this)), this.dispatcher.addEventListener(cp.events.UNLOCK_VIEWPORT, this.unlock.bind(this))
            },
            proto = Accessibility.prototype;
        proto.handleKeyup = function(event) {
            var key = CODE_MAP[event.keyCode];
            if (this.clickedUnlock) return this.clickedUnlock = !1;
            if (CODE_MAP[event.keyCode] && this.isActive) {
                event.preventDefault();
                var method = METHOD_MAP[key];
                method && this[method](key, event.shiftKey)
            }
        }, proto.handleKeydown = function(event) {
            this.isActive && /TAB|UP|DOWN|LEFT|RIGHT/.test(CODE_MAP[event.keyCode]) && event.preventDefault()
        }, proto.focusView = function(key, shift) {
            this.focus ? this.currentView += shift ? -1 : 1 : this.focus = !0, this.currentView === VIEWS.length && (this.currentView = 0), this.currentView < 0 && (this.currentView = VIEWS.length - 1);
            var data = {
                view: VIEWS[this.currentView]
            };
            this.dispatcher.dispatch(cp.events.VIEW_FOCUS, data)
        }, proto.focusNextElement = function(key) {
            var direction = /LEFT|UP/.test(key) ? -1 : 1,
                data = {
                    view: VIEWS[this.currentView],
                    direction: direction
                };
            this.dispatcher.dispatch(cp.events.ELEMENT_FOCUS, data)
        }, proto.hitElement = function() {
            var data = {
                view: VIEWS[this.currentView]
            };
            this.dispatcher.dispatch(cp.events.ELEMENT_HIT, data)
        }, proto.lock = function() {
            this.isActive = !1
        }, proto.unlock = function(event) {
            this.clickedUnlock = event.params && event.params.clicked, this.isActive = !0
        }, proto.announceElement = function(event) {
            var params = event.params;
            params && params.description && this.announce([params.description, "selected"].join(" "))
        }, proto.announce = function(message) {
            this.reader.innerText = message
        }, cp.Accessibility = Accessibility
    }(window.codeplayground = window.codeplayground || {})
}, function() {
    ! function(codeplayground) {
        "use strict";
        var PlaythingMediator = function(target, dispatcher) {
            this.target = target, this.dispatcher = dispatcher, this.dispatcher.addEventListener(codeplayground.events.HOLD_PLAYTHING, function(event) {
                var playthingId = event.params.playthingId;
                this.target.id === playthingId && this.target.hold()
            }.bind(this)), this.dispatcher.addEventListener(codeplayground.events.RELEASE_PLAYTHING, function(event) {
                var playthingId = event.params.playthingId;
                this.target.id === playthingId && this.target.release()
            }.bind(this)), this.dispatcher.addEventListener(codeplayground.events.PAUSE_PLAYTHING, function(event) {
                var playthingId = event.params.playthingId;
                this.target.id === playthingId && this.target.pause()
            }.bind(this)), this.dispatcher.addEventListener(codeplayground.events.PAUSE_ALL_PLAYTHING, function() {
                this.target.isReady && this.target.pause()
            }.bind(this)), this.dispatcher.addEventListener(codeplayground.events.RESUME_PLAYTHING, function(event) {
                var playthingId = event.params.playthingId;
                this.target.id === playthingId && this.target.resume()
            }.bind(this)), this.dispatcher.addEventListener(codeplayground.events.RESUME_ALL_PLAYTHING, function() {
                this.target.resume && this.target.resume()
            }.bind(this)), this.dispatcher.addEventListener(codeplayground.events.LOCK_PLAYTHING, function() {
                this.target.lock && this.target.lock()
            }.bind(this)), this.dispatcher.addEventListener(codeplayground.events.UNLOCK_PLAYTHING, function() {
                this.target.unlock && this.target.unlock()
            }.bind(this)), this.dispatcher.addEventListener(codeplayground.events.MUTE, function() {
                this.target.onIntroFinished && this.target.mute()
            }.bind(this)), this.dispatcher.addEventListener(codeplayground.events.UNMUTE, function() {
                this.target.unmute()
            }.bind(this)), this.dispatcher.addEventListener(codeplayground.events.INTRO_FINISHED, function() {
                this.target.onIntroFinished && this.target.onIntroFinished()
            }.bind(this)), this.dispatcher.addEventListener(codeplayground.PlaythingVO.events.PROPERTIES_UPDATED, function(event) {
                var playthingId = event.params.playthingId,
                    editableProperties = event.params.editableProperties;
                this.target.id === playthingId && this.target.updateProperties(editableProperties)
            }.bind(this)), this.dispatcher.addEventListener(codeplayground.events.REMOVE_PLAYTHING, function(event) {
                this.target.id === event.params && this.target.remove()
            }.bind(this)), this.dispatcher.addEventListener(codeplayground.events.VISIBLE, function(event) {
                this.target.id === event.params && (this.target.isVisible = !0)
            }.bind(this))
        };
        codeplayground.PlaythingMediator = PlaythingMediator
    }(window.codeplayground = window.codeplayground || {})
}, function() {
    ! function(codeplayground) {
        "use strict";
        var CookieModel = function(dispatcher) {
            this.dispatcher = dispatcher
        };
        CookieModel.prototype.createCookie = function(name, value, days) {
            if (days) {
                var date = new Date;
                date.setTime(date.getTime() + 24 * days * 60 * 60 * 1e3);
                var expires = "; expires=" + date.toGMTString()
            } else var expires = "";
            document.cookie = name + "=" + value + expires + "; path=/"
        }, CookieModel.prototype.readCookie = function(name) {
            for (var nameEQ = name + "=", ca = document.cookie.split(";"), i = 0; i < ca.length; i++) {
                for (var c = ca[i];
                    " " == c.charAt(0);) c = c.substring(1, c.length);
                if (0 == c.indexOf(nameEQ)) return c.substring(nameEQ.length, c.length)
            }
            return null
        }, CookieModel.prototype.eraseCookie = function(name) {
            createCookie(name, "", -1)
        }, codeplayground.CookieModel = CookieModel
    }(window.codeplayground = window.codeplayground || {})
}, function() {
    ! function(codeplayground) {
        "use strict";
        var DeviceModel = function(breakpoint, configModel) {
            var ua = navigator.userAgent;
            return {
                isMobile: function() {
                    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(ua) && "baby-bear" === breakpoint.getBreakpoint()
                },
                isTablet: function() {
                    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(ua)
                },
                isAndroidBrowser: function() {
                    return /android.+version\/\d/i.test(ua)
                },
                isSmall: function() {
                    return window.innerWidth < configModel.breakpoints.mamaBear
                },
                isSafari: function() {
                    return /safari/i.test(ua) && !/chrome/i.test(ua)
                },
                imageIsRotated: function() {
                    return /safari/i.test(ua) && /Version\/8\./.test(ua) || /safari/i.test(ua) && /iPad|iPhone/.test(ua) && /OS 8_/.test(ua)
                }
            }
        };
        codeplayground.DeviceModel = DeviceModel
    }(window.codeplayground = window.codeplayground || {})
}, function() {
    ! function(codeplayground) {
        "use strict";
        var StateModel = function(dispatcher) {
            dispatcher.addEventListener(codeplayground.events.CHANGE_STATE, function(event) {
                this.fsm[event.params].call(this)
            }.bind(this)), this.fsm = new window.Stately.machine({
                STATE_INIT: {
                    preload: function() {
                        return this.STATE_PRELOAD
                    },
                    startup: function() {
                        return this.STATE_STARTUP
                    }
                },
                STATE_PRELOAD: {
                    startup: function() {
                        return this.STATE_STARTUP
                    }
                },
                STATE_STARTUP: {
                    gotoIntro: function() {
                        return this.STATE_INTRO
                    },
                    gotoPlayground: function() {
                        return this.STATE_PLAYGROUND
                    },
                    gotoError: function() {
                        return this.STATE_ERROR
                    }
                },
                STATE_INTRO: {
                    gotoPlayground: function() {
                        return this.STATE_PLAYGROUND
                    }
                },
                STATE_PLAYGROUND: {},
                STATE_ERROR: {}
            }).bind(function(event, oldState, newState) {
                var transition = oldState + " => " + newState;
                switch (dispatcher.dispatch(codeplayground.events.STATE_CHANGED, {
                    newState: newState,
                    oldState: oldState
                }), transition) {
                    case "STATE_INIT => STATE_PRELOAD":
                        dispatcher.dispatch(codeplayground.events.PRELOAD);
                        break;
                    case "STATE_PRELOAD => STATE_STARTUP":
                    case "STATE_INIT => STATE_STARTUP":
                        dispatcher.dispatch(codeplayground.events.STARTUP)
                }
            }.bind(this))
        };
        StateModel.prototype.fsm = null, StateModel.prototype.getState = function() {
            return this.fsm.getMachineState()
        }, codeplayground.StateModel = StateModel
    }(window.codeplayground = window.codeplayground || {})
}, function() {
    "use strict";
    ! function(plugins) {
        var BreakpointPlugin = function(dispatcher) {
            function onResize() {
                var newBreakpoint = detectBreakpoint();
                newBreakpoint !== breakpoint && (breakpoint = newBreakpoint, dispatcher.dispatch("breakpoint", breakpoint))
            }

            function detectBreakpoint() {
                var b = null;
                return document.documentElement.currentStyle && (b = document.documentElement.currentStyle.fontFamily), window.getComputedStyle && (b = window.getComputedStyle(document.documentElement, null).getPropertyValue("font-family")), null !== b ? b = b.replace(/['",]/g, "") : void 0
            }
            var breakpoint = detectBreakpoint();
            return window.addEventListener("resize", onResize), {
                getBreakpoint: function() {
                    return breakpoint
                },
                dispose: function() {
                    window.removeEventListener("resize", onResize)
                }
            }
        };
        plugins.BreakpointPlugin = BreakpointPlugin
    }(window.plugins = window.plugins || {})
}, function(module, exports, __webpack_require__) {
    __webpack_require__(18),
        function(plugins) {
            "use strict";
            var i18nPlugin = function(dispatcher, options) {
                function update(lang) {
                    i18n.update({
                        language: lang
                    }).then(function(error) {
                        error || dispatcher.dispatch(plugins.i18nPlugin.events.UPDATED)
                    })
                }
                var i18n = new window.utils.i18n;
                return i18n.init(options), window.soma.template && window.soma.template.helpers && window.soma.template.helpers({
                    translate: function(value, options) {
                        return i18n.translate(value, options)
                    },
                    __: function(value, options) {
                        return i18n.translate(value, options)
                    },
                    __url: function(value, options) {
                        return i18n.translateUrl(value, options)
                    }
                }), dispatcher.addEventListener(plugins.i18nPlugin.events.UPDATE, function(event) {
                    update(event.params)
                }), {
                    loadConfig: function(configUrl) {
                        return i18n.loadConfig(configUrl)
                    },
                    translate: function(key, options) {
                        return i18n.translate(key, options)
                    },
                    __: function(key, options) {
                        return i18n.translate(key, options)
                    },
                    update: function(lang) {
                        return update(lang)
                    },
                    getCurrentLocale: function() {
                        return i18n.getCurrentLocale()
                    },
                    getObject: function(key, options) {
                        return i18n.getObject(key, options)
                    }
                }
            };
            plugins.i18nPlugin = i18nPlugin, plugins.i18nPlugin.events = {
                UPDATE: "plugins.i18nPlugin.events.update",
                UPDATED: "plugins.i18nPlugin.events.updated"
            }
        }(window.plugins = window.plugins || {})
}, function() {
    var ReadyPlugin = function(instance) {
        var ready = function() {
            function l(b) {
                for (k = 1; b = a.shift();) b()
            }
            var b, a = [],
                c = !1,
                d = document,
                e = d.documentElement,
                f = e.doScroll,
                g = "DOMContentLoaded",
                h = "addEventListener",
                i = "onreadystatechange",
                j = "readyState",
                k = /^loade|c/.test(d[j]);
            return d[h] && d[h](g, b = function() {
                d.removeEventListener(g, b, c), l()
            }, c), f && d.attachEvent(i, b = function() {
                /^c/.test(d[j]) && (d.detachEvent(i, b), l())
            }), f ? function(b) {
                self != top ? k ? b() : a.push(b) : function() {
                    try {
                        e.doScroll("left")
                    } catch (a) {
                        return setTimeout(function() {
                            ready(b)
                        }, 50)
                    }
                    b()
                }()
            } : function(b) {
                k ? b() : a.push(b)
            }
        }();
        instance.constructor.prototype.ready = ready
    };
    soma.plugins && soma.plugins.add && soma.plugins.add(ReadyPlugin)
}, function() {
    ! function() {
        "use strict";

        function init() {
            var sound, soundID = "keyboard";
            createjs.Sound.addEventListener("fileload", function(event) {
                event.id === soundID && (sound = createjs.Sound.createInstance(event.id), sound.volume = 0)
            });
            var playAudio = function() {
                sound && (sound.play(), document.body.removeEventListener("click", playAudio))
            };
            document.body.addEventListener("click", playAudio)
        }
        codeplayground.AudioAutoplay = {
            init: init
        }
    }()
}, function() {
    ! function(codeplayground) {
        "use strict";
        var CameraMan = function(stage, container, bounds, dispatcher, playgroundModel) {
            this.dispatcher = dispatcher, this.playgroundModel = playgroundModel, this.stage = stage, this.container = container, this.bounds = bounds, this.mouseX = void 0, this.speed = 0, this.viewport = new PIXI.Rectangle(0, 0, window.innerWidth, window.innerHeight), this.touchPoint = null, this.isLocked = !1, this.MARGIN_SIZE = .1 * this.viewport.width, this.MAX_SPEED = 10, dispatcher.addEventListener(codeplayground.events.LOCK_VIEWPORT, this.lock.bind(this)), dispatcher.addEventListener(codeplayground.events.UNLOCK_VIEWPORT, function() {
                this.playgroundModel.selectedPlaything || this.unlock()
            }.bind(this)), dispatcher.addEventListener(codeplayground.events.INTRO_IN, this.introIn.bind(this)), dispatcher.addEventListener(codeplayground.events.INTRO_OUT, this.introOut.bind(this)), dispatcher.addEventListener(codeplayground.events.FOCUS_PLAYTHING, this.focusPlaything.bind(this)), dispatcher.dispatch(codeplayground.events.VIEW_FOCUS, this.notifyUpdate.bind(this)), this.init()
        };
        CameraMan.prototype.init = function() {
            Modernizr.touch ? (window.addEventListener("touchmove", this.onTouchMove.bind(this)), window.addEventListener("touchstart", this.onTouchStart.bind(this)), window.addEventListener("touchend", this.onTouchEnd.bind(this))) : (window.addEventListener("mousemove", this.onMouseMove.bind(this)), window.addEventListener("mouseout", this.onMouseOut.bind(this)), window.addEventListener("mousewheel", this.onMouseWheel.bind(this))), this.container.x = 0 - (this.bounds.width - this.viewport.width) / 2, this.notifyUpdate()
        }, CameraMan.prototype.introIn = function() {
            this.container.y = 0 + this.viewport.height
        }, CameraMan.prototype.introOut = function(event) {
            TweenMax.to(this.container, 5, {
                y: 0,
                delay: event.params ? event.params.delay : 4,
                ease: Quad.easeOut
            })
        }, CameraMan.prototype.onTouchStart = function(event) {
            this.touchPoint = new PIXI.Point(event.touches[0].pageX, event.touches[0].pageY)
        }, CameraMan.prototype.onTouchMove = function(event) {
            var newTouchPoint = new PIXI.Point(event.changedTouches[0].pageX, event.changedTouches[0].pageY);
            this.speed = newTouchPoint.x - this.touchPoint.x, this.touchPoint = newTouchPoint, this.dispatcher.dispatch(codeplayground.events.SCROLL)
        }, CameraMan.prototype.onTouchEnd = function() {
            this.touchPoint = null, this.speed = 0
        }, CameraMan.prototype.onMouseMove = function(event) {
            this.mouseX = event.clientX
        }, CameraMan.prototype.onMouseOut = function() {
            this.speed = 0, this.mouseX = void 0
        }, CameraMan.prototype.onMouseWheel = function(event) {
            if (!this.isLocked) {
                event.preventDefault();
                var delta = event.wheelDelta || -event.detail;
                Math.abs(delta) > 1 && (delta = Math.pow(Math.abs(delta), 1 / 3) * (0 > delta ? -1 : 1)), this.speed = delta * this.MAX_SPEED, this.dispatcher.dispatch(codeplayground.events.SCROLL)
            }
        }, CameraMan.prototype.lock = function() {
            this.isLocked = !0
        }, CameraMan.prototype.unlock = function() {
            this.isLocked = !1
        }, CameraMan.prototype.update = function() {
            return this.mouseX < this.MARGIN_SIZE ? (this.speed = this.MAX_SPEED * (1 - this.mouseX / this.MARGIN_SIZE), this.dispatcher.dispatch(codeplayground.events.SCROLL)) : this.mouseX > this.viewport.width - this.MARGIN_SIZE && (this.speed = -this.MAX_SPEED * ((this.mouseX - (this.viewport.width - this.MARGIN_SIZE)) / this.MARGIN_SIZE), this.dispatcher.dispatch(codeplayground.events.SCROLL)), this.speed *= .9, Math.abs(this.speed) < .1 && (this.speed = 0), this.isLocked || (this.container.x += this.speed, this.checkBounds()), this.notifyUpdate(), 0 !== this.speed
        }, CameraMan.prototype.notifyUpdate = function() {
            var newViewport = new PIXI.Rectangle(0 - this.container.x, 0 - this.container.y, window.innerWidth, window.innerHeight);
            (this.viewport.x !== newViewport.x || this.viewport.y !== newViewport.y || this.viewport.width !== newViewport.width || this.viewport.height !== newViewport.height) && (this.viewport = newViewport, this.dispatcher.dispatch(codeplayground.events.VIEWPORT_CHANGED, {
                viewport: this.viewport
            }))
        }, CameraMan.prototype.focusPlaything = function(event) {
            var plaything = event.params && event.params.plaything;
            plaything && (this.container.x = this.viewport.width / 2 - plaything.getCenterOffsetX(), this.checkBounds(), this.notifyUpdate())
        }, CameraMan.prototype.checkBounds = function() {
            this.container.x = Math.max(Math.min(this.container.x, this.bounds.x), -(this.bounds.x + this.bounds.width - this.viewport.width))
        }, codeplayground.CameraMan = CameraMan
    }(window.codeplayground = window.codeplayground || {})
}, function() {
    ! function(utils) {
        "use strict";

        function valToHex(val) {
            var hex = Math.round(255 * val).toString(16);
            return 1 === hex.length ? "0" + hex : hex
        }
        utils.fn = {
            debounce: function(func, wait) {
                var args, maxTimeoutId, result, stamp, thisArg, timeoutId, trailingCall, lastCalled = 0,
                    trailing = !0;
                wait = Math.max(0, wait) || 0;
                var delayed = function() {
                    var remaining = wait - (Date.now() - stamp);
                    if (0 >= remaining) {
                        maxTimeoutId && clearTimeout(maxTimeoutId);
                        var isCalled = trailingCall;
                        maxTimeoutId = timeoutId = trailingCall = void 0, isCalled && (lastCalled = Date.now(), result = func.apply(thisArg, args), timeoutId || maxTimeoutId || (args = thisArg = null))
                    } else timeoutId = setTimeout(delayed, remaining)
                };
                return function() {
                    return args = arguments, stamp = Date.now(), thisArg = this, trailingCall = trailing, timeoutId || (timeoutId = setTimeout(delayed, wait)), result
                }
            },
            hsvToHex: function(h, s, v) {
                if (h = Math.max(0, Math.min(360, (h || 0) % 360)), s = Math.max(0, Math.min(1, (s || 100) / 100)), v = Math.max(0, Math.min(1, (v || 100) / 100)), h /= 60, 0 === s) return [v, v, v].map(valToHex).join("");
                var i = Math.floor(h),
                    f = h - i,
                    p = v * (1 - s),
                    q = v * (1 - s * f),
                    t = v * (1 - s * (1 - f)),
                    matrix = [
                        [v, t, p],
                        [q, v, p],
                        [p, v, t],
                        [p, q, v],
                        [t, p, v],
                        [v, p, q]
                    ];
                return matrix[i].map(valToHex).join("")
            }
        }
    }(window.utils = window.utils || {})
}, function() {
    "use strict";
    ! function(utils) {
        var promise, configPromise, language = "en-GB",
            localeFiles = {
                "en-GB": "en-GB.xml"
            },
            localePath = "/locale/",
            keySeparator = ".",
            interpolationPrefix = "__",
            interpolationSuffix = "__",
            reusePrefix = "__(",
            reuseSuffix = ")__",
            maxRecursionNum = 10,
            recursionNum = 0,
            pluralSuffix = "--plural",
            notFound = "utils.i18n: Translation not found",
            usePersistedDictionary = !1,
            i18n = function() {
                this.dictionary = null
            };
        i18n.prototype.init = function(options) {
            options && this.parseOptions(options)
        }, i18n.prototype.parseOptions = function(options) {
            options && (language = options.language || language, localePath = options.localePath || localePath, localeFiles = options.localeFiles || localeFiles, keySeparator = options.keySeparator || keySeparator, notFound = options.notFound || notFound, usePersistedDictionary = options.usePersistedDictionary || usePersistedDictionary)
        }, i18n.prototype.loadConfig = function(configUrl) {
            return configPromise = new window.promise.Promise, window.promise.get(configUrl).then(function(error, text, xhr) {
                if (!error) {
                    var options, data = xhr.responseText;
                    try {
                        options = JSON.parse(data)
                    } catch (e) {
                        options = window.JXON.build(this.stringToXML(data)).localeConfig
                    }
                    this.parseOptions(options), configPromise.done(null)
                }
            }.bind(this)), configPromise
        }, i18n.prototype.getCurrentLocale = function() {
            return language
        }, i18n.prototype.update = function(options) {
            return options && (language = options.language || language), promise = new window.promise.Promise, this.initDictionary(), promise
        }, i18n.prototype.initDictionary = function() {
            var localDictionary = null;
            window.localStorage && usePersistedDictionary ? (localDictionary = localStorage.getItem("dictionary"), null !== localDictionary ? this.setDictionary(localDictionary) : this.loadDictionary()) : this.loadDictionary()
        }, i18n.prototype.setDictionary = function(data) {
            try {
                this.dictionary = JSON.parse(data)
            } catch (e) {
                this.dictionary = window.JXON.build(this.stringToXML(data)).dictionary
            }
            promise.done(null)
        }, i18n.prototype.getDictionaryUrl = function(language) {
            for (var locale in localeFiles)
                if (-1 != locale.indexOf(language)) return localePath + localeFiles[locale];
            return null
        }, i18n.prototype.loadDictionary = function() {
            var dictionaryUrl = this.getDictionaryUrl(language);
            null !== dictionaryUrl ? window.promise.get(dictionaryUrl).then(function(error, text, xhr) {
                error || this.persistDictionary(xhr.responseText)
            }.bind(this)) : promise.done("i18n: No dictionary file")
        }, i18n.prototype.persistDictionary = function(data) {
            this.setDictionary(data), window.localStorage && usePersistedDictionary && localStorage.setItem("dictionary", this.dictionary)
        }, i18n.prototype.translateUrl = function(value) {
            var updatedUrl = value,
                qs = new RegExp("\\?.+", "g").test(value);
            return updatedUrl += qs ? "&lang=" + language : "?lang=" + language
        }, i18n.prototype.getObject = function(key) {
            var value = this.searchDictionary(key);
            return value
        }, i18n.prototype.translate = function(key, options) {
            return recursionNum = 0, this._translate(key, options)
        }, i18n.prototype._translate = function(key, options) {
            if (this.dictionary) {
                if (options = options || {}, this.hasCountModifier(options)) {
                    var optionsWithoutModifier = Object.clone(options, !0);
                    delete optionsWithoutModifier.count;
                    var suffix = options.count > 1 || "string" == typeof options.count ? pluralSuffix : "",
                        keyWithPluralSuffix = key + suffix,
                        translated = this.translate(keyWithPluralSuffix, optionsWithoutModifier);
                    if (translated) return this.replace(translated, {
                        count: options.count
                    })
                }
                var value = this.searchDictionary(key);
                return void 0 === value ? notFound : ("string" == typeof value && (value = this.reuse(value, options), value = this.replace(value, options)), value)
            }
        }, i18n.prototype.searchDictionary = function(key) {
            var splitted = key.split(keySeparator),
                obj = this.dictionary;
            try {
                for (var i = 0; i < splitted.length; i++) obj = obj[splitted[i]]
            } catch (error) {
                return void 0
            }
            return "object" == typeof obj && 0 === Object.getOwnPropertyNames(obj).length ? "" : obj
        }, i18n.prototype.reuse = function(translatedStr, options) {
            for (; - 1 !== translatedStr.indexOf(reusePrefix) && !(++recursionNum > maxRecursionNum);) {
                var prefixIndex = translatedStr.indexOf(reusePrefix),
                    suffixIndex = translatedStr.indexOf(reuseSuffix, prefixIndex) + reuseSuffix.length,
                    token = translatedStr.substring(prefixIndex, suffixIndex),
                    tokenWithoutAffixes = token.replace(reusePrefix, "").replace(reuseSuffix, ""),
                    translatedToken = this._translate(tokenWithoutAffixes, options);
                translatedStr = translatedStr.replace(token, translatedToken)
            }
            return translatedStr
        }, i18n.prototype.replace = function(translatedStr, modifiers) {
            var value = null;
            for (var key in modifiers) value = modifiers[key], translatedStr = translatedStr.split([interpolationPrefix, key, interpolationSuffix].join("")).join(value);
            return translatedStr
        }, i18n.prototype.hasCountModifier = function(options) {
            return "number" == typeof options.count || "string" == typeof options.count
        }, i18n.prototype.stringToXML = function(str) {
            var xml;
            if (window.ActiveXObject) xml = new ActiveXObject("Microsoft.XMLDOM"), xml.async = "false", xml.loadXML(str);
            else {
                var parser = new DOMParser;
                xml = parser.parseFromString(str, "text/xml")
            }
            return xml
        }, i18n.prototype.xmlToJson = function(xml) {
            var obj = {};
            if (1 == xml.nodeType) {
                if (xml.attributes.length > 0) {
                    obj["@attributes"] = {};
                    for (var j = 0; j < xml.attributes.length; j++) {
                        var attribute = xml.attributes.item(j);
                        obj["@attributes"][attribute.nodeName] = attribute.nodeValue
                    }
                }
            } else 3 == xml.nodeType && (obj = xml.nodeValue);
            if (xml.hasChildNodes())
                for (var i = 0; i < xml.childNodes.length; i++) {
                    var item = xml.childNodes.item(i),
                        nodeName = item.nodeName;
                    if ("undefined" == typeof obj[nodeName]) obj[nodeName] = this.xmlToJson(item);
                    else {
                        if ("undefined" == typeof obj[nodeName].push) {
                            var old = obj[nodeName];
                            obj[nodeName] = [], obj[nodeName].push(old)
                        }
                        obj[nodeName].push(this.xmlToJson(item))
                    }
                }
            return obj
        }, utils.i18n = i18n
    }(window.utils = window.utils || {})
}, function() {
    "use strict";
    codeplayground.pjsext = {
            createUpdateTransform: function(context) {
                return function() {
                    if (PIXI.Sprite.prototype.updateTransform.call(this), this.playing && context.isPlaying) {
                        this.currentFrame += this.animationSpeed;
                        var round = Math.round(this.currentFrame);
                        0 > round ? this.loop ? this.gotoAndPlay(this.textures.length - 1) : (this.gotoAndStop(0), this.onComplete && this.onComplete()) : this.loop || round < this.textures.length ? this.setTexture(this.textures[round % this.textures.length]) : round >= this.textures.length && (this.gotoAndStop(this.textures.length - 1), this.onComplete && this.onComplete())
                    }
                }
            }
        },
        function() {
            PIXI.Rectangle.prototype.containsRect = function(rect) {
                return this.x <= rect.x && this.y <= rect.y && rect.x + rect.width <= this.x + this.width && rect.y + rect.height <= this.y + this.height ? !0 : !1
            }, PIXI.AnimatedSprite = function(sequences, frameRate, firstSequence) {
                this.sequences = sequences, this.currentSequence = firstSequence || Object.keys(sequences)[0], PIXI.Sprite.call(this, this.sequences[this.currentSequence][0]), this.anchor.x = this.anchor.y = .5, this.frameRate = frameRate || 60, this.onComplete = null, this.currentFrame = 0, this.playing = !1, this.loop = !1
            }, PIXI.AnimatedSprite.constructor = PIXI.AnimatedSprite, PIXI.AnimatedSprite.prototype = Object.create(PIXI.Sprite.prototype), PIXI.AnimatedSprite.prototype.gotoAndPlay = function(where) {
                this.currentSequence !== where && ("string" == typeof where ? (this.currentFrame = 0, this.currentSequence = where) : this.currentFrame = where, this.playing = !0)
            }, PIXI.AnimatedSprite.prototype.gotoAndStop = function(where) {
                this.currentSequence !== where && ("string" == typeof where ? (this.currentFrame = 0, this.currentSequence = where) : this.currentFrame = where, this.setTexture(this.sequences[this.currentSequence][this.currentFrame]), this.playing = !1)
            }, PIXI.AnimatedSprite.prototype.play = function() {
                this.playing = !0
            }, PIXI.AnimatedSprite.prototype.stop = function() {
                this.playing = !1
            }, PIXI.AnimatedSprite.prototype.advanceTime = function(dt) {
                if ("undefined" == typeof dt && (dt = 1 / 60), this.playing) {
                    this.currentFrame += this.frameRate * dt;
                    var constrainedFrame = Math.floor(Math.min(this.currentFrame, this.sequences[this.currentSequence].length - 1));
                    this.setTexture(this.sequences[this.currentSequence][constrainedFrame]), this.currentFrame >= this.sequences[this.currentSequence].length && (this.loop ? this.gotoAndPlay(0) : this.stop(), this.onComplete && this.onComplete(this.currentSequence))
                }
            }
        }()
}, function() {
    ! function(codeplayground) {
        "use strict";
        var BaseButtonView = function(id, dispatcher) {
            this.id = id, this.dispatcher = dispatcher, this.stage = null, this.rootDisplayObject = null, this.buttonStates = [], this.currentStateIndex = 0
        };
        BaseButtonView.DEFAULT = "codeplayground.BaseButtonView.default", BaseButtonView.BUTTON_CLICKED = "codeplayground.BaseButtonView.buttonClicked", BaseButtonView.MUTE_BUTTON = "codeplayground.BaseButtonView.muteButton", BaseButtonView.PLAYPAUSE_BUTTON = "codeplayground.BaseButtonView.playPauseButton", BaseButtonView.RESET_BUTTON = "codeplayground.BaseButtonView.resetButton", BaseButtonView.FACEBOOK_BUTTON = "codeplayground.BaseButtonView.facebookButton", BaseButtonView.TWITTER_BUTTON = "codeplayground.BaseButtonView.twitterButton", BaseButtonView.prototype.initView = function(stage) {
            this.stage = stage, this.rootDisplayObject = new PIXI.DisplayObjectContainer, this.rootDisplayObject.buttonMode = !0, this.rootDisplayObject.interactive = !0, this.stage.addChild(this.rootDisplayObject), Modernizr.touch ? this.rootDisplayObject.tap = this.onTap.bind(this) : (this.rootDisplayObject.mouseover = this.onMouseOver.bind(this), this.rootDisplayObject.mouseout = this.onMouseOut.bind(this), this.rootDisplayObject.click = this.onClick.bind(this)), this.TEXT && (this.hintText = new PIXI.Text(this.TEXT[this.currentStateIndex], {
                font: "16px MaaxRegular, sans-serif",
                fill: "#29afd8",
                stroke: "#f8f7f6",
                strokeThickness: 4,
                align: "right"
            }), this.hintText.anchor.x = 1, this.hintText.y = 5, this.hintText.x = -15, this.hintText.visible = !1, this.rootDisplayObject.addChild(this.hintText))
        }, BaseButtonView.prototype.onMouseOver = function() {
            this.getButtonState().clip.gotoAndStop(1), this.showHint()
        }, BaseButtonView.prototype.onMouseOut = function() {
            this.getButtonState().clip.gotoAndStop(0), this.hideHint()
        }, BaseButtonView.prototype.onTap = function() {
            this.updateButtonState(), this.notifyClicked(), this.hideHint()
        }, BaseButtonView.prototype.onClick = BaseButtonView.prototype.onTap, BaseButtonView.prototype.updateButtonState = function() {
            var newStateIndex = this.currentStateIndex < this.buttonStates.length - 1 ? this.currentStateIndex + 1 : 0;
            this.updateView(newStateIndex)
        }, BaseButtonView.prototype.updateView = function(newStateIndex) {
            newStateIndex !== this.currentStateIndex && (this.getButtonState().clip.visible = !1, this.getButtonState().clip.gotoAndStop(0), this.currentStateIndex = newStateIndex, this.getButtonState().clip.visible = !0)
        }, BaseButtonView.prototype.getButtonState = function() {
            return this.buttonStates[this.currentStateIndex]
        }, BaseButtonView.prototype.setButtonState = function(stateName) {
            for (var newStateIndex = null, i = 0; i < this.buttonStates.length; i++) this.buttonStates[i].name === stateName && (newStateIndex = i);
            null !== newStateIndex && this.updateView(newStateIndex)
        }, BaseButtonView.prototype.addButtonState = function(name, textures) {
            var clip = new PIXI.MovieClip(textures);
            clip.gotoAndStop(0), this.rootDisplayObject.addChild(clip);
            var state = {
                name: name,
                clip: clip
            };
            this.buttonStates.length > 0 && (clip.visible = !1), this.buttonStates.push(state)
        }, BaseButtonView.prototype.initSelect = function() {
            this.rootDisplayObject.click = this.rootDisplayObject.tap = function() {
                this.notifySelected()
            }.bind(this)
        }, BaseButtonView.prototype.notifyClicked = function() {
            this.dispatcher.dispatch(codeplayground.BaseButtonView.BUTTON_CLICKED, {
                id: this.id,
                state: this.getButtonState().name
            })
        }, BaseButtonView.prototype.showHint = function() {
            this.hintText && this.TEXT[this.currentStateIndex] && (this.hintText.setText(this.TEXT[this.currentStateIndex]), this.hintText.visible = !0)
        }, BaseButtonView.prototype.hideHint = function() {
            this.hintText && (this.hintText.visible = !1)
        }, BaseButtonView.prototype.getText = function() {
            return this.TEXT[this.currentStateIndex]
        }, codeplayground.BaseButtonView = BaseButtonView
    }(window.codeplayground = window.codeplayground || {})
}, function() {
    ! function(codeplayground) {
        "use strict";
        var FADE_WIDTH = 150,
            BasePlaythingView = function(id, dispatcher) {
                this.proto = BasePlaythingView.prototype, BasePlaythingView.dispatcher = dispatcher, this.id = id, this.dispatcher = dispatcher, this.stage = null, this.rootDisplayObject = null, this.zIndex = 101, this.centerOffsetX = 0, this.canPlaySounds = codeplayground.canPlaySounds, this.volume = 1, this.fadeVolume = 1, this.viewObject = "rootDisplayObject", this.inView = !1, this.FADE_WIDTH = FADE_WIDTH, this.isReady = !1, this.introFinished = !1, this.isPlaying = !1, this.isMuted = !1, this.properties = null, this.worldBounds = null, this.viewport = null, this.outline = null
            };
        BasePlaythingView.prototype.initView = function(stage, worldBounds) {
            this.stage = stage, this.worldBounds = worldBounds
        }, BasePlaythingView.prototype.destroy = function() {}, BasePlaythingView.prototype.updateProperties = function(editable) {
            this.properties = editable
        }, BasePlaythingView.prototype.updateView = function() {}, BasePlaythingView.prototype.resizeView = function(worldBounds) {
            this.worldBounds = worldBounds
        }, BasePlaythingView.prototype.updateViewport = function(viewport) {
            this.viewport = viewport, this.isReady && (this.updateInView(), this.updateVolume())
        }, BasePlaythingView.prototype.updateInView = function() {
            var obj = this[this.viewObject];
            if (this.isReady && obj && this.viewport) {
                var vp = this.viewport,
                    bounds = obj.getBounds(),
                    l = bounds.x,
                    r = bounds.x + bounds.width;
                if (this.inView = l >= 0 && l <= vp.width || r >= 0 && r <= vp.width, this.sound) {
                    var leftFade = 0 > r ? (FADE_WIDTH + r) / FADE_WIDTH : 0,
                        rightFade = l > vp.width ? (FADE_WIDTH + vp.width - l) / FADE_WIDTH : 0;
                    this.fadeVolume = +this.inView || Math.max(0, leftFade, rightFade)
                }
            }
        }, BasePlaythingView.prototype.show = function() {
            this.rootDisplayObject.visible = !0
        }, BasePlaythingView.prototype.hide = function() {
            this.rootDisplayObject.visible = !1
        }, BasePlaythingView.prototype.pause = function() {
            this.isPlaying = !1, this.updateVolume()
        }, BasePlaythingView.prototype.resume = function() {
            this.isPlaying = !0, this.updateVolume()
        }, BasePlaythingView.prototype.hold = function() {
            this.isPlaying = !1, this.isHolding = !0, this.updateVolume()
        }, BasePlaythingView.prototype.release = function() {
            this.isPlaying = !0, this.isHolding = !0, this.updateVolume()
        }, BasePlaythingView.prototype.mute = function() {
            this.isMuted = !0, this.updateVolume()
        }, BasePlaythingView.prototype.unmute = function() {
            this.isMuted = !1, this.updateVolume()
        }, BasePlaythingView.prototype.updateVolume = function(sound, fadeVolume) {
            sound = sound || this.sound, sound && (fadeVolume = void 0 !== fadeVolume ? fadeVolume : this.fadeVolume, sound.volume = this.volume * fadeVolume * !this.isMuted)
        }, BasePlaythingView.prototype.lock = function() {
            try {
                this.rootDisplayObject.buttonMode = !1, this.rootDisplayObject.interactive = !1
            } catch (error) {
                throw new Error("BasePlaythingView.unlock: rootDisplayObject not defined!")
            }
        }, BasePlaythingView.prototype.unlock = function() {
            try {
                this.rootDisplayObject.buttonMode = !0, this.rootDisplayObject.interactive = !0
            } catch (error) {
                throw new Error("BasePlaythingView.unlock: rootDisplayObject not defined!")
            }
        }, BasePlaythingView.prototype.initSelect = function() {
            Modernizr.touch ? this.rootDisplayObject.tap = function() {
                //this.notifySelected()
            }.bind(this) : (this.rootDisplayObject.mouseover = function() {
               // this.onOver()
            }.bind(this), this.rootDisplayObject.mouseout = function() {
                //this.onOut()
            }.bind(this), this.rootDisplayObject.click = function() {
                //this.notifySelected()
            }.bind(this))
        }, BasePlaythingView.prototype.onOver = function() {
            this.rootDisplayObject.tint = 16777215 //16711680
        }, BasePlaythingView.prototype.onOut = function() {
            this.rootDisplayObject.tint = 16777215
        }, BasePlaythingView.prototype.drawOutline = function() {
            var bounds = this.rootDisplayObject.getBounds();
            this.outline || (this.outline = new PIXI.Graphics, this.rootDisplayObject.addChild(this.outline)), this.outline.clear(), this.outline.lineStyle(5, 16711680), this.outline.drawRect(bounds.x, bounds.y, bounds.width, bounds.height)
        }, BasePlaythingView.prototype.getWindowPostion = function() {
            var bounds = this.rootDisplayObject.getBounds();
            return bounds.x += bounds.width / 2, bounds
        }, BasePlaythingView.prototype.getCenterOffsetX = function() {
            if ("string" != typeof this.centerOffsetX) return this.worldBounds.width / 2 + this.centerOffsetX;
            if (-1 !== this.centerOffsetX.indexOf("%")) {
                var ratio = parseFloat(this.centerOffsetX) / 100;
                return this.worldBounds.width / 2 + this.worldBounds.width * ratio
            }
        }, BasePlaythingView.prototype.notifySelected = function() {
            this.dispatcher.dispatch(codeplayground.events.PLAYTHING_SELECTED, {
                playthingId: this.id,
                playthingPosition: this.getWindowPostion()
            })
        }, BasePlaythingView.prototype.notifyReady = function() {
            this.isReady = !0, this.updateInView(), this.updateVolume(), this.introFinished && this.resume(), this.dispatcher.dispatch(codeplayground.events.PLAYTHING_READY, {
                playthingId: this.id
            })
        }, BasePlaythingView.prototype.onIntroFinished = function() {
            this.introFinished = !0
        }, BasePlaythingView.prototype.loadAssets = function(assets) {
            "string" == typeof assets && (assets = [assets]);
            var loader = new PIXI.AssetLoader(assets);
            loader.on("onComplete", this.onAssetsLoaded.bind(this)), loader.load()
        }, BasePlaythingView.prototype.onAssetsLoaded = function() {
            this.assetsLoaded = !0, this.onAllLoaded()
        }, BasePlaythingView.prototype.onAllLoaded = function() {
            return this.assetsLoaded && this.soundsLoaded ? !0 : void 0
        }, BasePlaythingView.prototype.loadSounds = function(sounds) {
            this.canPlaySounds && ("string" == typeof sounds && (sounds = [sounds]), this.tracks = sounds.map(function(sound) {
                return this.tracksToLoad = sounds.length, {
                    id: sound,
                    src: sound + ".ogg",
                    data: {
                        context: this
                    }
                }
            }, this), soundQueue.push.apply(soundQueue, this.tracks), soundsLoading = !1)
        }, BasePlaythingView.prototype.onSoundsLoaded = function() {
            this.soundsLoaded = !0, this.onAllLoaded()
        }, BasePlaythingView.prototype.createSound = function(id, play) {
            return play ? createjs.Sound.play(id) : createjs.Sound.createInstance(id)
        };
        var soundQueue = [],
            soundsLoading = 0;
        BasePlaythingView.loadSounds = function() {
            codeplayground.canPlaySounds && !soundsLoading && (soundsLoading = !0, createjs.Sound.addEventListener("fileload", onSoundLoaded), createjs.Sound.registerSounds(soundQueue, "/sounds/"))
        };
        var onSoundLoaded = function(event) {
            var context = event.data && event.data.context;
            context && (--context.tracksToLoad || context.onSoundsLoaded())
        };
        BasePlaythingView.prototype.removeFromArray = function(item, arr) {
            for (var i = 0; i < arr.length; i++)
                if (arr[i] === item) return arr.splice(i, 1), !0
        }, BasePlaythingView.extend = function(obj) {
            return soma.inherit(BasePlaythingView, obj)
        }, codeplayground.BasePlaythingView = BasePlaythingView
    }(window.codeplayground = window.codeplayground || {})
}, function() {
    ! function(codeplayground) {
        "use strict";
        var ConfirmResetView = function(template, element, scope, dispatcher, i18n, breakpoint, deviceModel, analyticsModel) {
            this.element = element, this.dispatcher = dispatcher, this.scope = scope, this.deviceModel = deviceModel, this.analyticsModel = analyticsModel, this.slectedPlaything = null, dispatcher.addEventListener(codeplayground.events.RENDER, template.render.bind(template, void 0)), dispatcher.addEventListener(codeplayground.events.CONFIRM_RESET, this.show.bind(this)), dispatcher.addEventListener(codeplayground.events.HIDE_EDITOR, function() {
                this.hide()
            }.bind(this)), scope.confirmBtnOnClick = function() {
                this.dispatcher.dispatch(codeplayground.events.RESET_ALL_PROPERTIES), this.analyticsModel.track("Control", "Select", "Refresh"), this.hide({
                    params: {
                        clicked: !0
                    }
                })
            }.bind(this), scope.closeBtnOnClick = this.hide.bind(this), scope.cancelBtnOnClick = this.hide.bind(this)
        };
        ConfirmResetView.prototype.show = function() {
            if (!this.deviceModel.isMobile()) {
                var editorWidth = this.element.offsetWidth,
                    editorHeight = this.element.offsetHeight,
                    editorRect = new PIXI.Rectangle(window.innerWidth / 2 - editorWidth / 2, window.innerHeight / 2 - editorHeight / 2, this.element.offsetWidth, this.element.offsetHeight);
                this.element.vendorStyle("transform", "translate(" + editorRect.x + "px," + editorRect.y + "px)")
            }
            this.element.classList.remove("editor--hidden"), this.element.querySelector(".editor__btn--cancel").focus(), this.dispatcher.dispatch(codeplayground.events.LOCK_VIEWPORT), this.dispatcher.dispatch(codeplayground.events.LOCK_PLAYTHING)
        }, ConfirmResetView.prototype.hide = function(event) {
            this.element.classList.add("editor--hidden"), event && (this.dispatcher.dispatch(codeplayground.events.UNLOCK_PLAYTHING), this.dispatcher.dispatch(codeplayground.events.UNLOCK_VIEWPORT, {
                clicked: !!event
            }))
        }, codeplayground.ConfirmResetView = ConfirmResetView
    }(window.codeplayground = window.codeplayground || {}, PIXI)
}, function() {
    ! function(codeplayground) {
        "use strict";
        var CookieView = function(template, element, dispatcher, scope, cookieModel) {
            dispatcher.addEventListener(codeplayground.events.RENDER, function() {
                template.render(), element.addEventListener("click", function() {
                    element.classList.add("cookie--hidden"), cookieModel.createCookie("cookie_policy", "1", "30")
                });
                var moreBtn = document.querySelector(".cookie__btn-more");
                moreBtn.addEventListener("click", function(event) {
                    event.stopPropagation(), dispatcher.dispatch(codeplayground.events.SHOW_INFO, {
                        sectionId: 5
                    })
                })
            }), dispatcher.addEventListener(codeplayground.events.INTRO_FINISHED, function() {
                setTimeout(function() {
                   // "1" !== cookieModel.readCookie("cookie_policy") && element.classList.remove("cookie--hidden")
                }, 2500)
            })
        };
        codeplayground.CookieView = CookieView
    }(window.codeplayground = window.codeplayground || {})
}, function() {
    ! function(codeplayground) {
        "use strict";
        var co = codeplayground,
            InfoView = function(template, element, scope, dispatcher, i18n, breakpoint, deviceModel, analyticsModel) {
                this.id = "InfoView", this.template = template, this.element = element, this.dispatcher = dispatcher, this.scope = scope, this.i18n = i18n, this.breakpoint = breakpoint, this.analyticsModel = analyticsModel, this.sections = null, this.navSections = null, this.footerSections = null, this.seelctedSectionIndex = 0, this.selectedSection = null, this.player = null, this.hiContrast = !1, dispatcher.addEventListener(codeplayground.events.RENDER, function() {
                    this.sections = this.i18n.translate("info.section"), this.navSections = this.sections.filter(this.isNav), this.footerSections = this.sections.filter(this.isFooter), this.initView()
                }.bind(this)), dispatcher.addEventListener(codeplayground.events.SHOW_INFO, function(event) {
                    var sectionId = event.params ? event.params.sectionId : null;
                    //add mute here

                   this.dispatcher.dispatch(codeplayground.events.MUTE);
                    
                    sectionId && (this.seelctedSectionIndex = sectionId - 1, this.selectedSection = this.sections[sectionId - 1]), this.show()
                }.bind(this)), dispatcher.addEventListener(co.events.HIDE_INFO, this.hide.bind(this)), dispatcher.addEventListener(co.events.RESIZE, this.updateView.bind(this)), scope.closeBtn_onClick = function() {

                     this.dispatcher.dispatch(codeplayground.events.UNMUTE);

                    this.dispatcher.dispatch(codeplayground.events.HIDE_INFO, {

                        clicked: !0
                    });

                }.bind(this), scope.navItem_onClick = function(event, index) {
                    [].forEach.call(document.querySelectorAll(".info__nav-btn"), function(el) {
                        el.classList.remove("info__nav-btn--selected")
                    }), event.currentTarget.classList.add("info__nav-btn--selected"), this.selectedSection = this.sections[index], this.analyticsModel.track("Information", "Click", this.selectedSection.title), this.updateView()
                }.bind(this), scope.footerItem_onClick = function(event, index) {
                    [].forEach.call(document.querySelectorAll(".info__nav-btn"), function(el) {
                        el.classList.remove("info__nav-btn--selected")
                    }), this.selectedSection = this.footerSections[index], this.updateView()
                }.bind(this), scope.isSelected = function(index) {
                    return index === this.seelctedSectionIndex ? "info__nav-btn--selected" : ""
                }.bind(this), scope.contrast = "normal", scope.toggleContrast = function() {
                    this.hiContrast = !this.hiContrast, scope.contrast = this.hiContrast ? "high" : "normal", document.documentElement.classList.toggle("hi-contrast", this.hiContrast), this.updateView()
                }.bind(this)
            };
        InfoView.prototype.initView = function() {
            this.scope.navSections = this.navSections, this.scope.footerSections = this.footerSections;
            var tag = document.createElement("script");
            tag.src = "https://www.youtube.com/iframe_api";
            var firstScriptTag = document.getElementsByTagName("script")[0];
            firstScriptTag.parentNode.insertBefore(tag, firstScriptTag), window.onYouTubeIframeAPIReady = function() {}
        }, InfoView.prototype.isNav = function(section) {
            return section.in_nav === !0
        }, InfoView.prototype.isFooter = function(section) {
            return section.in_nav === !1
        }, InfoView.prototype.updateView = function() {
            if (this.navSections) {
                this.selectedSection = this.selectedSection || this.navSections[0], this.scope.sectionId = this.selectedSection.id, this.scope.sectionBody = this.selectedSection.body, this.scope.sectionTitle = this.selectedSection.title, this.template.render();
                var infoMainElement = document.querySelector(".info__main");
                infoMainElement.style.maxHeight = parseInt(window.innerHeight) - parseInt(document.querySelector(".info__nav").offsetHeight) - parseInt(document.querySelector(".info__footer").offsetHeight) - 18 + "px";
                var that = this;
                [].forEach.call(document.querySelectorAll(".info__playlist-item"), function(el) {
                    el.addEventListener("click", function() {
                        that.initPlayer(el.getAttribute("data-video-id"))
                    }, !1)
                }), this.analyticsModel.init()
            }
        }, InfoView.prototype.initPlayer = function(videoId) {
            this.player ? this.player.loadVideoById(videoId) : this.player = new YT.Player("player", {
                width: "256",
                height: "144",
                videoId: videoId,
                playerVars: {
                    origin: window.location.origin,
                    autoplay: 1,
                    controls: 1,
                    showinfo: 0,
                    modestbranding: 1,
                    enablejsapi: 1,
                    rel: 0,
                    html5: 1
                },
                events: {
                    onReady: this.onPlayerReady,
                    onStateChange: this.onPlayerStateChange
                }
            })
        }, InfoView.prototype.onPlayerReady = function(event) {
            event.target.playVideo()
        }, InfoView.prototype.onPlayerStateChange = function() {}, InfoView.prototype.show = function() {
            this.element.classList.remove("info--hidden"), this.element.querySelector("[role=tabpanel]").focus(), this.updateView(), this.dispatcher.dispatch(codeplayground.events.LOCK_VIEWPORT), this.analyticsModel.track("Information", "Click", this.selectedSection.title)
        }, InfoView.prototype.hide = function(event) {
            this.element.classList.add("info--hidden"), this.player && (this.player.stopVideo(), this.player = null), this.seelctedSectionIndex = 0, this.selectedSection = null, this.dispatcher.dispatch(codeplayground.events.UNLOCK_VIEWPORT, {
               clicked: event.params.clicked
            })
        }, codeplayground.InfoView = InfoView
    }(window.codeplayground = window.codeplayground || {})
}, function() {
    ! function(codeplayground) {
        "use strict";
        var IntroView = function(template, element, scope, dispatcher, i18n, breakpoint, cookieModel, configModel) {
            this.template = template, this.element = element, this.dispatcher = dispatcher, this.scope = scope, this.i18n = i18n, this.breakpoint = breakpoint, this.cookieModel = cookieModel, this.configModel = configModel, this.typeSpeed = 40, this.introText = "", this.typeTimeout = void 0, this.soundID = "keyboard", this.volume = .1, this.mute = !1, dispatcher.addEventListener(codeplayground.events.RENDER, function() {
                this.introText = this.i18n.translate("intro.text"), this.initView()
            }.bind(this)), dispatcher.addEventListener(codeplayground.events.INTRO_IN, function() {
                this.introIn()
            }.bind(this)), dispatcher.addEventListener(codeplayground.events.MUTE, function() {
                this.mute = !0
            }.bind(this)), createjs.Sound.addEventListener("fileload", function(event) {
                event.id === this.soundID && (this.sound = createjs.Sound.createInstance(event.id), this.sound.volume = this.volume)
            }.bind(this)), createjs.Sound.registerSound("/sounds/" + this.soundID + ".ogg", this.soundID)
        };
        IntroView.prototype.initView = function() {
            this.scope.introText = "", this.template.render()
            console.log("in typewrite?");
           
    if(!window.location.hash) {
        window.location = window.location + '#loaded';
        window.location.reload();
    }
        }, IntroView.prototype.introIn = function() {
            
            var viewed = !!this.cookieModel.readCookie("cp_viewed") && !this.configModel.skipIntro;
            this.cookieModel.createCookie("cp_viewed", 1, 30), this.typewrite(this.introText, 0, viewed)
        }, IntroView.prototype.introOut = function() {
            TweenMax.to(this.element, 6, {
                y: 2 * -document.querySelector(".intro__inner").offsetHeight,
                force3D: !0,
                delay: this.charPause / 1e3,
                ease: Linear.easeNone,
                onStart: function() {
                    this.dispatcher.dispatch(codeplayground.events.INTRO_OUT)
                }.bind(this),
                onComplete: function() {
                    this.hide(), this.dispatcher.dispatch(codeplayground.events.INTRO_FINISHED)
                }.bind(this)
            })
        }, IntroView.prototype.typewrite = function(str, characterIndex, skipIn) {
      

            str = str.replace(/ +/g, " ").replace(/(\n ?)+/g, "");
            var $introText = this.element.querySelector(".intro__inner");
            skipIn && (characterIndex = Math.max(0, str.indexOf("^") - 1));
            var humanize = Math.round(70 * Math.random()) + this.typeSpeed;
            this.typeTimeout = window.setTimeout(function() {
                this.charPause = 0;
                var substr = str.substr(characterIndex);
                if ("^" === substr.charAt(0)) {
                    var skip = 1;
                    /^\^\d+/.test(substr) && (substr = /\d+/.exec(substr)[0], skip += substr.length, this.charPause = parseInt(substr)), str = str.substring(0, characterIndex) + str.substring(characterIndex + skip), this.introOut()
                }
                for (;
                    "<" === str.substr(characterIndex).charAt(0);)
                    if ("<" === str.substr(characterIndex).charAt(0)) {
                        for (var tag = "";
                            ">" !== str.substr(characterIndex).charAt(0);) tag += str.substr(characterIndex).charAt(0), characterIndex++;
                        characterIndex++
                    }
                this.typeTimeout = window.setTimeout(function() {
                    if (characterIndex === str.length + 1) return void window.clearTimeout(this.typeTimeout);
                    var nextString = str.substr(0, characterIndex + 1);
                    nextString += '<span class="intro__cursor">|</span>', $introText.innerHTML = nextString, characterIndex++, this.typewrite(str, characterIndex)
                }.bind(this), this.charPause), !this.mute && this.sound && this.sound.play({
                    interrupt: !0,
                    offset: 0
                })
            }.bind(this), humanize)
        }, IntroView.prototype.show = function() {
            this.element.classList.remove("intro--hidden")
        }, IntroView.prototype.hide = function() {
            this.element.classList.add("intro--hidden")
        }, codeplayground.IntroView = IntroView
    }(window.codeplayground = window.codeplayground || {})
}, function() {
    ! function(codeplayground) {
        "use strict";
        codeplayground.LoaderView = function(template, element, dispatcher) {
            dispatcher.addEventListener(codeplayground.events.RENDER, function() {
                template.render()
            }), dispatcher.addEventListener(codeplayground.events.INTRO_IN, function() {
                element.classList.add("loader--hidden")
            }), dispatcher.addEventListener(codeplayground.events.INTRO_FINISHED, function() {
                element.classList.add("loader--hidden")
            })
        }
    }(window.codeplayground = window.codeplayground || {})
}, function() {
    ! function(codeplayground, PIXI) {
        "use strict";
        var PlaygroundView = function(target, dispatcher, injector, mediators, deviceModel, playgroundModel, analyticsModel, i18n, configModel) {
            this.id = "PlaygroundView", this.target = target, this.dispatcher = dispatcher, this.injector = injector, this.mediators = mediators, this.deviceModel = deviceModel, this.playgroundModel = playgroundModel, this.analyticsModel = analyticsModel, this.configModel = configModel, this.i18n = i18n, this.stage = null, this.world = null, this.worldBounds = null, this.renderer = null, this.cameraMan = null, this.views = [], this.playthings = [], this.focusedThing = 0, this.viewsToInitialize = 0, this.totalViews = 0, this.introFinished = !1, this.animationFrameId = void 0, this.now = 0, this.delta = 0, this.then = Date.now(), this.cuboidControls = null, this.aye = null, this.hands = null, dispatcher.addEventListener(codeplayground.events.INITIALIZE_PLAYGROUND, function(event) {
                var playthings = event.params.playthings;
                this.initializePlayground(playthings)
            }.bind(this)), dispatcher.addEventListener(codeplayground.events.INTRO_OUT, function() {
                this.startFrame(), this.show()
            }.bind(this)), dispatcher.addEventListener(codeplayground.events.PLAYTHING_READY, this.onPlaythingReady.bind(this)), dispatcher.addEventListener(codeplayground.events.VIEWPORT_CHANGED, this.onViewportChanged.bind(this)), dispatcher.addEventListener(codeplayground.BaseButtonView.BUTTON_CLICKED, this.onButtonClicked.bind(this)), dispatcher.addEventListener(codeplayground.events.INTRO_FINISHED, function() {
                this.introFinished = !0, this.dispatcher.dispatch(codeplayground.events.RESUME_ALL_PLAYTHING)
            }.bind(this)), dispatcher.addEventListener(codeplayground.events.SHOW_INFO, function() {
                var paused = this.lastPauseState = this.playgroundModel.isPaused;
                paused || this.togglePause(!0)
            }.bind(this)), dispatcher.addEventListener(codeplayground.events.HIDE_INFO, function() {
                var paused = this.lastPauseState;
                paused || this.togglePause(!1)
            }.bind(this)), dispatcher.addEventListener(codeplayground.events.VIEW_FOCUS, this.focusView.bind(this)), dispatcher.addEventListener(codeplayground.events.ELEMENT_FOCUS, this.focusElement.bind(this)), dispatcher.addEventListener(codeplayground.events.ELEMENT_HIT, this.hitElement.bind(this)), this.initView()
        };
        PlaygroundView.prototype.initView = function() {
            this.stage = new PIXI.Stage(16316406), this.renderer = new PIXI.autoDetectRenderer(window.innerWidth, window.innerHeight, {
                antialias: !0
            }), (this.deviceModel.isSafari() || this.deviceModel.isAndroidBrowser()) && (this.renderer = new PIXI.CanvasRenderer(window.innerWidth, window.innerHeight, {
                antialias: !0
            })), this.renderer.view.style.width = window.innerWidth, this.renderer.view.style.height = window.innerHeight, this.target.appendChild(this.renderer.view), this.world = new PIXI.DisplayObjectContainer, this.world.interactive = !0, this.stage.addChild(this.world), this.worldBounds = this.calculateWorldSize(), this.cameraMan = this.injector.createInstance(codeplayground.CameraMan, this.stage, this.world, this.worldBounds), window.addEventListener("resize", window.utils.fn.debounce(function() {
                this.resizeView()
            }.bind(this), 100)), this.stage.click = this.stage.tap = function() {
                this.dispatcher.dispatch(codeplayground.events.PLAYTHING_UNSELECTED)
            }.bind(this)
        }, PlaygroundView.prototype.initializePlayground = function(playthings) {
            var totalPlaythings = playthings.length,
                plaything = null;
            this.views = [], this.viewsToInitialize = this.totalViews = totalPlaythings;
            for (var i = 0; totalPlaythings > i; i++) {
                plaything = playthings[i];
                var view = this.injector.createInstance(codeplayground[plaything.viewClass], plaything.id);
                view.name = plaything.name, view.zIndex = plaything.zIndex, view.centerOffsetX = plaything.centerOffsetX, view.initView(this.world, this.worldBounds), view.updateProperties(plaything.editableProperties), view.updateViewport(this.cameraMan.viewport), this.views.push(view), this.playthings.push(view)
            }
            this.mediators.create(codeplayground.PlaythingMediator, this.views), this.dispatcher.dispatch(codeplayground.events.PLAYTHINGS_INITIALISED), this.resizeView(), this.initializeUI(), this.configModel.skipIntro ? (this.show(), this.startFrame(), this.dispatcher.dispatch(codeplayground.events.INTRO_FINISHED), this.dispatcher.dispatch(codeplayground.events.RESUME_ALL_PLAYTHING)) : this.dispatcher.dispatch(codeplayground.events.INTRO_IN)
        }, PlaygroundView.prototype.onPlaythingReady = function() {
            --this.viewsToInitialize <= 0 && (this.sortPlaythingsByZIndex(), codeplayground.BasePlaythingView.loadSounds(), this.dispatcher.dispatch(codeplayground.events.PLAYGROUND_READY))
        }, PlaygroundView.prototype.show = function() {
            this.target.classList.remove("playground--hidden")
        }, PlaygroundView.prototype.hide = function() {
            this.target.classList.add("playground--hidden")
        }, PlaygroundView.prototype.sortPlaythingsByZIndex = function() {
            this.playthings.sort(function(a, b) {
                return parseInt(a.zIndex) < parseInt(b.zIndex) ? -1 : parseInt(a.zIndex) > parseInt(b.zIndex) ? 1 : 0
            });
            for (var root, i = 0; i < this.playthings.length; i++) root = this.playthings[i].rootDisplayObject, root && this.world.setChildIndex(root, i)
        }, PlaygroundView.prototype.initializeUI = function() {
            if (this.cuboidControls = this.injector.createInstance(this.deviceModel.isMobile() ? codeplayground.MobileCuboidControlsView : codeplayground.CuboidControlsView, "CuboidControlsView"), this.cuboidControls.initView(this.world, this.worldBounds), this.cuboidControls.updateViewport(this.cameraMan.viewport), this.views.push(this.cuboidControls), this.aye = this.injector.createInstance(codeplayground.AyeView, "AyeView"), this.aye.initView(this.world, this.worldBounds), this.aye.updateViewport(this.cameraMan.viewport), this.views.push(this.aye), (!this.deviceModel.isMobile() || this.deviceModel.isMobile())) {
                var plane = this.injector.createInstance(codeplayground.PlaneView, "PlaneView");
                this.plane = plane, plane.initPosition(this.worldBounds.width / 3, this.worldBounds.height / 3), plane.initView(this.world, this.worldBounds), plane.updateViewport(this.cameraMan.viewport), this.views.push(plane), this.hands = this.injector.createInstance(codeplayground.HandsView, "HandsView"), this.hands.updateViewport(this.cameraMan.viewport), this.hands.initView(this.world, this.worldBounds), this.views.push(this.hands)
            }
            this.totalViews = this.views.length
        }, PlaygroundView.prototype.onViewportChanged = function(event) {
            for (var viewport = event.params.viewport, i = 0; i < this.totalViews; i++) this.views[i].updateViewport(viewport)
        }, PlaygroundView.prototype.resizeView = function() {
            if (this.views.length) {
                this.renderer.resize(window.innerWidth, window.innerHeight), this.renderer.view.style.width = window.innerWidth, this.renderer.view.style.height = window.innerHeight, this.worldBounds = this.calculateWorldSize();
                for (var i = 0; i < this.totalViews; i++) this.views[i].resizeView(this.worldBounds);
                this.dispatcher.dispatch(codeplayground.events.RESIZE, this.worldBounds)
            }
        }, PlaygroundView.prototype.calculateWorldSize = function() {
            return new PIXI.Rectangle(0, 0, Math.max(5 * window.innerWidth, 3920), window.innerHeight)
        }, PlaygroundView.prototype.updateView = function() {
            for (var i = 0; i < this.totalViews; i++) this.views[i].updateView(this.delta);
            this.renderer.render(this.stage)
        }, PlaygroundView.prototype.onButtonClicked = function(event) {
            var link;
            switch (event.params.id) {
                case codeplayground.BaseButtonView.PLAYPAUSE_BUTTON:
                    this.togglePause(event.params.state !== codeplayground.PlayPauseButtonView.PLAY), this.analyticsModel.track("Control", "Select", "Play");
                    break;
                case codeplayground.BaseButtonView.MUTE_BUTTON:
                    this.dispatcher.dispatch(event.params.state === codeplayground.MuteButtonView.SOUND_ON ? codeplayground.events.UNMUTE : codeplayground.events.MUTE), this.analyticsModel.track("Control", "Select", "Mute");
                    break;
                case codeplayground.BaseButtonView.RESET_BUTTON:
                    this.dispatcher.dispatch(codeplayground.events.CONFIRM_RESET);
                    break;
                case codeplayground.BaseButtonView.FACEBOOK_BUTTON:
                    link = [this.i18n.translate("share.facebook"), "u=" + encodeURIComponent(this.i18n.translate("url"))].join("&"), window.open(link, "_blank"), this.analyticsModel.track("button", "click", "share_facebook");
                    break;
                case codeplayground.BaseButtonView.TWITTER_BUTTON:
                    link = [this.i18n.translate("share.twitter"), "url=" + encodeURIComponent(this.i18n.translate("url")), "text=" + encodeURIComponent(this.i18n.translate("share.text"))].join("&"), window.open(link, "_blank"), this.analyticsModel.track("button", "click", "share_twitter")
            }
        }, PlaygroundView.prototype.frame = function() {
            this.now = Date.now(), this.delta = (this.now - this.then) / 1e3, this.then = this.now, this.updateView(), this.playgroundModel.isSwiping = this.cameraMan.update();
            var self = this;
            this.animationFrameId = requestAnimationFrame(function() {
                self.frame()
            })
        }, PlaygroundView.prototype.startFrame = function() {
            this.animationFrameId || this.frame()
        }, PlaygroundView.prototype.stopFrame = function() {
            this.animationFrameId && (window.cancelAnimationFrame(this.animationFrameId), this.animationFrameId = void 0)
        }, PlaygroundView.prototype.focusView = function(event) {
            return event.params.view !== this.id ? (this.dispatcher.dispatch(codeplayground.events.RESUME_ALL_PLAYTHING), void this.unFocus()) : (this.playgroundModel.isPaused || this.dispatcher.dispatch(codeplayground.events.PAUSE_ALL_PLAYTHING), void this.focus("Playground view. "))
        }, PlaygroundView.prototype.focusElement = function(event) {
            event.params.view === this.id && (this.unFocus(), event.params.direction && (this.focusedThing += event.params.direction, this.focusedThing < 0 && (this.focusedThing = this.playthings.length - 1), this.focusedThing >= this.playthings.length && (this.focusedThing = 0)), this.focus())
        }, PlaygroundView.prototype.focus = function(message) {
            message = message || "";
            var plaything = this.playthings[this.focusedThing];
            this.playthings[this.focusedThing].onOver(), this.dispatcher.dispatch(codeplayground.events.FOCUS_PLAYTHING, {
                plaything: plaything
            }), this.dispatcher.dispatch(codeplayground.events.ELEMENT_FOCUSED, {
                description: message + plaything.name + " plaything"
            })
        }, PlaygroundView.prototype.unFocus = function() {
            var plaything = this.playthings[this.focusedThing];
            plaything && plaything.onOut()
        }, PlaygroundView.prototype.hitElement = function(event) {
            event.params.view === this.id && (this.playthings[this.focusedThing].notifySelected(), document.querySelector("#editor input").focus())
        }, PlaygroundView.prototype.togglePause = function(pause) {
            "undefined" == typeof pause && (pause = !this.playgroundModel.isPaused), this.playgroundModel.isPaused = pause, this.dispatcher.dispatch(pause ? codeplayground.events.PAUSE_ALL_PLAYTHING : codeplayground.events.RESUME_ALL_PLAYTHING)
        }, codeplayground.PlaygroundView = PlaygroundView
    }(window.codeplayground = window.codeplayground || {}, PIXI)
}, function() {
    ! function(codeplayground) {
        "use strict";
        var EditablePropertiesVO = function(data) {
            this.properties = [];
            for (var total = data.length, i = 0; total > i; i++) this.properties.push(new codeplayground.PropertyVO(data[i]))
        };
        EditablePropertiesVO.prototype.getByName = function(name) {
            for (var total = this.properties.length, i = 0; total > i; i++) {
                var property = this.properties[i];
                if (property.name === name) return property
            }
            return null
        }, EditablePropertiesVO.prototype.setByName = function(name, value) {
            for (var i = 0; i < this.properties.length; i++) {
                var property = this.properties[i];
                if (property.name === name) return void this.properties[i].setValue(value)
            }
        }, EditablePropertiesVO.prototype.allValues = function() {
            var values = {};
            return this.properties.forEach(function(property) {
                values[property.name] = property.value
            }), values
        }, codeplayground.EditablePropertiesVO = EditablePropertiesVO
    }(window.codeplayground = window.codeplayground || {})
}, function() {
    ! function(codeplayground) {
        "use strict";
        var PlaythingVO = function(data, dispatcher) {
            this.dispatcher = dispatcher, this.id = data.id, this.name = data.name, this.enabled = !!data.enabled, this.solo = !!data.solo, this.mobileEnabled = !!data.mobileEnabled, this.androidMobile = !!data.androidMobile, this.requiresSound = !!data.requiresSound, this.isVisible = data.isVisible, this.needsWebGL = !!data.needsWebGL, this.editor = data.editor, this.zIndex = data.zIndex || 0, this.centerOffsetX = data.centerOffsetX || 0, this.editableProperties = new codeplayground.EditablePropertiesVO(Object.clone(data.editable, !0)), this.defaultEditableProperties = new codeplayground.EditablePropertiesVO(Object.clone(data.editable, !0)), this.viewClass = data.viewClass || null
        };
        PlaythingVO.events = {
            PROPERTIES_UPDATED: "codeplayground.PlaythingVO.events.proppertiesUpdated"
        }, PlaythingVO.prototype.resetEditableProperties = function() {
            for (var key in this.editableProperties.properties) this.editableProperties.properties[key].setValue(this.defaultEditableProperties.properties[key].value);
            this.notifyUpdated()
        }, PlaythingVO.prototype.setEditableProperties = function(properties) {
            this.editableProperties = properties, this.notifyUpdated()
        }, PlaythingVO.prototype.notifyUpdated = function() {
            this.dispatcher.dispatch(codeplayground.PlaythingVO.events.PROPERTIES_UPDATED, {
                playthingId: this.id,
                editableProperties: this.editableProperties
            })
        }, codeplayground.PlaythingVO = PlaythingVO
    }(window.codeplayground = window.codeplayground || {})
}, function() {
    ! function(codeplayground) {
        "use strict";
        var FALSY_VALS = /^(|false|0|-0|null|undefined|NaN)$/,
            PropertyVO = function(data) {
                this.map(data, this)
            };
        PropertyVO.prototype.getValue = function() {
            return this.value
        }, PropertyVO.prototype.setValue = function(value) {
            this.value = this.parseValue(value)
        }, PropertyVO.prototype.parseValue = function(value) {
            var min = this.min || 0,
                max = this.max || 1;
            switch (this.type.toLowerCase()) {
                case "string":
                    return value.substr(0, this.size);
                case "number":
                    return Math.max(Math.min(parseFloat(value) || 0, max), min);
                case "integer":
                    return Math.max(Math.min(parseInt(value) || 0, max), min);
                case "boolean":
                    return "string" == typeof value && FALSY_VALS.test(value) ? !1 : !!value
            }
            return value
        }, PropertyVO.prototype.map = function(obj, mappedObject) {
            Object.keys(obj).forEach(function(key) {
                var val = obj[key];
                val.constructor === Object ? this.map(val, mappedObject) : mappedObject[key] = val
            })
        }, codeplayground.PropertyVO = PropertyVO
    }(window.codeplayground = window.codeplayground || {})
}, function(module) {
    module.exports = "/*\n * Stately.js: A JavaScript based finite-state machine (FSM) engine.\n *\n * Copyright (c) 2012 Florian SchÃ¤fer (florian.schaefer@gmail.com)\n * Released under MIT license.\n *\n * Version: 1.2.0\n *\n */\n(function (root, factory) {\n    if (typeof exports === 'object') {\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        define(factory);\n    } else {\n        root.Stately = factory();\n    }\n})(this, function () {\n\n    var\n        toString = Object.prototype.toString,\n\n        InvalidStateError = (function () {\n\n            function InvalidStateError(message) {\n\n                this.name = 'InvalidStateError';\n\n                this.message = message;\n            }\n\n            InvalidStateError.prototype = new Error();\n\n            InvalidStateError.prototype.constructor = InvalidStateError;\n\n            return InvalidStateError;\n        })();\n\n    function Stately(statesObject, initialStateName) {\n\n        if (typeof statesObject === 'function') {\n\n            statesObject = statesObject();\n        }\n\n        if (toString.call(statesObject) !== '[object Object]') {\n\n            throw new InvalidStateError('Stately.js: Invalid states object: `' + statesObject + '`.');\n        }\n\n        var\n            currentState,\n\n            notificationStore = [],\n\n            notify = function () {\n\n                var notifications = notificationStore.slice();\n\n                for (var i = 0, l = notifications.length; i < l; i++) {\n\n                    notifications[i].apply(this, arguments);\n                }\n            },\n\n            stateStore = {\n\n                getMachineState: function getMachineState() {\n\n                    return currentState.name;\n                },\n\n                setMachineState: function setMachineState(nextState /*, eventName */) {\n\n                    var\n                        eventName = arguments[1],\n\n                        onBeforeState,\n\n                        onEnterState,\n\n                        onLeaveState,\n\n                        lastState = currentState;\n\n                    if (!nextState || !nextState.name || !stateStore[nextState.name]) {\n\n                        throw new InvalidStateError('Stately.js: Transitioned into invalid state: `' + setMachineState.caller + '`.');\n                    }\n\n                    currentState = nextState;\n\n                    onBeforeState = stateMachine['onbefore' + currentState.name];\n\n                    if (onBeforeState && typeof onBeforeState === 'function') {\n\n                        onBeforeState.call(stateStore, eventName, lastState.name, nextState.name);\n                    }\n\n                    onEnterState = stateMachine['onenter' + currentState.name] || stateMachine['on' + currentState.name];\n\n                    if (onEnterState && typeof onEnterState === 'function') {\n\n                        onEnterState.call(stateStore, eventName, lastState.name, nextState.name);\n                    }\n\n                    onLeaveState = stateMachine['onleave' + lastState.name];\n\n                    if (onLeaveState && typeof onLeaveState === 'function') {\n\n                        onLeaveState.call(stateStore, eventName, lastState.name, nextState.name);\n                    }\n\n                    notify.call(stateStore, eventName, lastState.name, nextState.name);\n\n                    return this;\n                },\n\n                getMachineEvents: function getMachineEvents() {\n\n                    var events = [];\n\n                    for (var property in currentState) {\n\n                        if (currentState.hasOwnProperty(property)) {\n\n                            if (typeof currentState[property] === 'function') {\n\n                                events.push(property);\n                            }\n                        }\n                    }\n\n                    return events;\n                }\n\n            },\n\n            stateMachine = {\n\n                getMachineState: stateStore.getMachineState,\n\n                getMachineEvents: stateStore.getMachineEvents,\n\n                bind: function bind(callback) {\n\n                    if (callback) {\n\n                        notificationStore.push(callback);\n                    }\n\n                    return this;\n                },\n\n                unbind: function unbind(callback) {\n\n                    if (!callback) {\n\n                        notificationStore = [];\n\n                    } else {\n\n                        for (var i = 0, l = notificationStore.length; i < l; i++) {\n\n                            if (notificationStore[i] === callback) {\n\n                                notificationStore.splice(i, 1);\n                            }\n                        }\n                    }\n\n                    return this;\n                }\n            },\n\n            transition = function transition(stateName, eventName, nextEvent) {\n\n                return function event() {\n\n                    var\n                        onBeforeEvent,\n\n                        onAfterEvent,\n\n                        nextState,\n\n                        eventValue = stateMachine;\n\n                    if (stateStore[stateName] !== currentState) {\n\n                        if (nextEvent) {\n\n                            eventValue = nextEvent.apply(stateStore, arguments);\n                        }\n\n                        return eventValue;\n                    }\n\n                    onBeforeEvent = stateMachine['onbefore' + eventName];\n\n                    if (onBeforeEvent && typeof onBeforeEvent === 'function') {\n\n                        onBeforeEvent.call(stateStore, eventName, currentState.name, currentState.name);\n                    }\n\n                    eventValue = stateStore[stateName][eventName].apply(stateStore, arguments);\n\n                    if (typeof eventValue === 'undefined') {\n\n                        nextState = currentState;\n\n                        eventValue = stateMachine;\n\n                    } else if (toString.call(eventValue) === '[object Object]') {\n\n                        nextState = (eventValue === stateStore ? currentState : eventValue);\n\n                        eventValue = stateMachine;\n\n                    } else if (toString.call(eventValue) === '[object Array]' && eventValue.length >= 1) {\n\n                        nextState = eventValue[0];\n\n                        eventValue = eventValue[1];\n                    }\n\n                    onAfterEvent = stateMachine['onafter' + eventName] || stateMachine['on' + eventName];\n\n                    if (onAfterEvent && typeof onAfterEvent === 'function') {\n\n                        onAfterEvent.call(stateStore, eventName, currentState.name, nextState.name);\n                    }\n\n                    stateStore.setMachineState(nextState, eventName);\n\n                    return eventValue;\n                };\n            };\n\n        for (var stateName in statesObject) {\n\n            if (statesObject.hasOwnProperty(stateName)) {\n\n                stateStore[stateName] = statesObject[stateName];\n\n                for (var eventName in stateStore[stateName]) {\n\n                    if (stateStore[stateName].hasOwnProperty(eventName)) {\n\n                        if (typeof stateStore[stateName][eventName] === 'string') {\n\n                            stateStore[stateName][eventName] = (function (stateName) {\n\n                                return function event() {\n\n                                    return this[stateName];\n                                };\n\n                            })(stateStore[stateName][eventName]);\n                        }\n\n                        if (typeof stateStore[stateName][eventName] === 'function') {\n\n                            stateMachine[eventName] = transition(stateName, eventName, stateMachine[eventName]);\n                        }\n                    }\n                }\n\n                stateStore[stateName].name = stateName;\n\n                if (!currentState) {\n\n                    currentState = stateStore[stateName];\n                }\n            }\n        }\n\n        if (typeof stateStore[initialStateName] !== 'undefined') {\n            currentState = stateStore[initialStateName];\n        }\n\n        if (!currentState) {\n\n            throw new InvalidStateError('Stately.js: Invalid initial state.');\n        }\n\n        return stateMachine;\n    }\n\n    Stately.machine = function machine(statesObject, initialStateName) {\n        return new Stately(statesObject, initialStateName);\n    };\n\n    Stately.InvalidStateError = InvalidStateError;\n\n    return Stately;\n\n});\n"
}, function(module) {
    module.exports = "/**\n * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.\n *\n * @version 1.0.3\n * @codingstandard ftlabs-jsv2\n * @copyright The Financial Times Limited [All Rights Reserved]\n * @license MIT License (see LICENSE.txt)\n */\n\n/*jslint browser:true, node:true*/\n/*global define, Event, Node*/\n\n\n/**\n * Instantiate fast-clicking listeners on the specified layer.\n *\n * @constructor\n * @param {Element} layer The layer to listen on\n * @param {Object} options The options to override the defaults\n */\nfunction FastClick(layer, options) {\n	'use strict';\n	var oldOnClick;\n\n	options = options || {};\n\n	/**\n	 * Whether a click is currently being tracked.\n	 *\n	 * @type boolean\n	 */\n	this.trackingClick = false;\n\n\n	/**\n	 * Timestamp for when click tracking started.\n	 *\n	 * @type number\n	 */\n	this.trackingClickStart = 0;\n\n\n	/**\n	 * The element being tracked for a click.\n	 *\n	 * @type EventTarget\n	 */\n	this.targetElement = null;\n\n\n	/**\n	 * X-coordinate of touch start event.\n	 *\n	 * @type number\n	 */\n	this.touchStartX = 0;\n\n\n	/**\n	 * Y-coordinate of touch start event.\n	 *\n	 * @type number\n	 */\n	this.touchStartY = 0;\n\n\n	/**\n	 * ID of the last touch, retrieved from Touch.identifier.\n	 *\n	 * @type number\n	 */\n	this.lastTouchIdentifier = 0;\n\n\n	/**\n	 * Touchmove boundary, beyond which a click will be cancelled.\n	 *\n	 * @type number\n	 */\n	this.touchBoundary = options.touchBoundary || 10;\n\n\n	/**\n	 * The FastClick layer.\n	 *\n	 * @type Element\n	 */\n	this.layer = layer;\n\n	/**\n	 * The minimum time between tap(touchstart and touchend) events\n	 *\n	 * @type number\n	 */\n	this.tapDelay = options.tapDelay || 200;\n\n	if (FastClick.notNeeded(layer)) {\n		return;\n	}\n\n	// Some old versions of Android don't have Function.prototype.bind\n	function bind(method, context) {\n		return function() { return method.apply(context, arguments); };\n	}\n\n\n	var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];\n	var context = this;\n	for (var i = 0, l = methods.length; i < l; i++) {\n		context[methods[i]] = bind(context[methods[i]], context);\n	}\n\n	// Set up event handlers as required\n	if (deviceIsAndroid) {\n		layer.addEventListener('mouseover', this.onMouse, true);\n		layer.addEventListener('mousedown', this.onMouse, true);\n		layer.addEventListener('mouseup', this.onMouse, true);\n	}\n\n	layer.addEventListener('click', this.onClick, true);\n	layer.addEventListener('touchstart', this.onTouchStart, false);\n	layer.addEventListener('touchmove', this.onTouchMove, false);\n	layer.addEventListener('touchend', this.onTouchEnd, false);\n	layer.addEventListener('touchcancel', this.onTouchCancel, false);\n\n	// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)\n	// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick\n	// layer when they are cancelled.\n	if (!Event.prototype.stopImmediatePropagation) {\n		layer.removeEventListener = function(type, callback, capture) {\n			var rmv = Node.prototype.removeEventListener;\n			if (type === 'click') {\n				rmv.call(layer, type, callback.hijacked || callback, capture);\n			} else {\n				rmv.call(layer, type, callback, capture);\n			}\n		};\n\n		layer.addEventListener = function(type, callback, capture) {\n			var adv = Node.prototype.addEventListener;\n			if (type === 'click') {\n				adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {\n					if (!event.propagationStopped) {\n						callback(event);\n					}\n				}), capture);\n			} else {\n				adv.call(layer, type, callback, capture);\n			}\n		};\n	}\n\n	// If a handler is already declared in the element's onclick attribute, it will be fired before\n	// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and\n	// adding it as listener.\n	if (typeof layer.onclick === 'function') {\n\n		// Android browser on at least 3.2 requires a new reference to the function in layer.onclick\n		// - the old one won't work if passed to addEventListener directly.\n		oldOnClick = layer.onclick;\n		layer.addEventListener('click', function(event) {\n			oldOnClick(event);\n		}, false);\n		layer.onclick = null;\n	}\n}\n\n\n/**\n * Android requires exceptions.\n *\n * @type boolean\n */\nvar deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0;\n\n\n/**\n * iOS requires exceptions.\n *\n * @type boolean\n */\nvar deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent);\n\n\n/**\n * iOS 4 requires an exception for select elements.\n *\n * @type boolean\n */\nvar deviceIsIOS4 = deviceIsIOS && (/OS 4_\\d(_\\d)?/).test(navigator.userAgent);\n\n\n/**\n * iOS 6.0(+?) requires the target element to be manually derived\n *\n * @type boolean\n */\nvar deviceIsIOSWithBadTarget = deviceIsIOS && (/OS ([6-9]|\\d{2})_\\d/).test(navigator.userAgent);\n\n/**\n * BlackBerry requires exceptions.\n *\n * @type boolean\n */\nvar deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;\n\n/**\n * Determine whether a given element requires a native click.\n *\n * @param {EventTarget|Element} target Target DOM element\n * @returns {boolean} Returns true if the element needs a native click\n */\nFastClick.prototype.needsClick = function(target) {\n	'use strict';\n	switch (target.nodeName.toLowerCase()) {\n\n	// Don't send a synthetic click to disabled inputs (issue #62)\n	case 'button':\n	case 'select':\n	case 'textarea':\n		if (target.disabled) {\n			return true;\n		}\n\n		break;\n	case 'input':\n\n		// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)\n		if ((deviceIsIOS && target.type === 'file') || target.disabled) {\n			return true;\n		}\n\n		break;\n	case 'label':\n	case 'video':\n		return true;\n	}\n\n	return (/\\bneedsclick\\b/).test(target.className);\n};\n\n\n/**\n * Determine whether a given element requires a call to focus to simulate click into element.\n *\n * @param {EventTarget|Element} target Target DOM element\n * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.\n */\nFastClick.prototype.needsFocus = function(target) {\n	'use strict';\n	switch (target.nodeName.toLowerCase()) {\n	case 'textarea':\n		return true;\n	case 'select':\n		return !deviceIsAndroid;\n	case 'input':\n		switch (target.type) {\n		case 'button':\n		case 'checkbox':\n		case 'file':\n		case 'image':\n		case 'radio':\n		case 'submit':\n			return false;\n		}\n\n		// No point in attempting to focus disabled inputs\n		return !target.disabled && !target.readOnly;\n	default:\n		return (/\\bneedsfocus\\b/).test(target.className);\n	}\n};\n\n\n/**\n * Send a click event to the specified element.\n *\n * @param {EventTarget|Element} targetElement\n * @param {Event} event\n */\nFastClick.prototype.sendClick = function(targetElement, event) {\n	'use strict';\n	var clickEvent, touch;\n\n	// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)\n	if (document.activeElement && document.activeElement !== targetElement) {\n		document.activeElement.blur();\n	}\n\n	touch = event.changedTouches[0];\n\n	// Synthesise a click event, with an extra attribute so it can be tracked\n	clickEvent = document.createEvent('MouseEvents');\n	clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);\n	clickEvent.forwardedTouchEvent = true;\n	targetElement.dispatchEvent(clickEvent);\n};\n\nFastClick.prototype.determineEventType = function(targetElement) {\n	'use strict';\n\n	//Issue #159: Android Chrome Select Box does not open with a synthetic click event\n	if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {\n		return 'mousedown';\n	}\n\n	return 'click';\n};\n\n\n/**\n * @param {EventTarget|Element} targetElement\n */\nFastClick.prototype.focus = function(targetElement) {\n	'use strict';\n	var length;\n\n	// Issue #160: on iOS 7, some input elements (e.g. date datetime) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.\n	if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time') {\n		length = targetElement.value.length;\n		targetElement.setSelectionRange(length, length);\n	} else {\n		targetElement.focus();\n	}\n};\n\n\n/**\n * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.\n *\n * @param {EventTarget|Element} targetElement\n */\nFastClick.prototype.updateScrollParent = function(targetElement) {\n	'use strict';\n	var scrollParent, parentElement;\n\n	scrollParent = targetElement.fastClickScrollParent;\n\n	// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the\n	// target element was moved to another parent.\n	if (!scrollParent || !scrollParent.contains(targetElement)) {\n		parentElement = targetElement;\n		do {\n			if (parentElement.scrollHeight > parentElement.offsetHeight) {\n				scrollParent = parentElement;\n				targetElement.fastClickScrollParent = parentElement;\n				break;\n			}\n\n			parentElement = parentElement.parentElement;\n		} while (parentElement);\n	}\n\n	// Always update the scroll top tracker if possible.\n	if (scrollParent) {\n		scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;\n	}\n};\n\n\n/**\n * @param {EventTarget} targetElement\n * @returns {Element|EventTarget}\n */\nFastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {\n	'use strict';\n\n	// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.\n	if (eventTarget.nodeType === Node.TEXT_NODE) {\n		return eventTarget.parentNode;\n	}\n\n	return eventTarget;\n};\n\n\n/**\n * On touch start, record the position and scroll offset.\n *\n * @param {Event} event\n * @returns {boolean}\n */\nFastClick.prototype.onTouchStart = function(event) {\n	'use strict';\n	var targetElement, touch, selection;\n\n	// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).\n	if (event.targetTouches.length > 1) {\n		return true;\n	}\n\n	targetElement = this.getTargetElementFromEventTarget(event.target);\n	touch = event.targetTouches[0];\n\n	if (deviceIsIOS) {\n\n		// Only trusted events will deselect text on iOS (issue #49)\n		selection = window.getSelection();\n		if (selection.rangeCount && !selection.isCollapsed) {\n			return true;\n		}\n\n		if (!deviceIsIOS4) {\n\n			// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):\n			// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched\n			// with the same identifier as the touch event that previously triggered the click that triggered the alert.\n			// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an\n			// immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.\n			// Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,\n			// which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,\n			// random integers, it's safe to to continue if the identifier is 0 here.\n			if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {\n				event.preventDefault();\n				return false;\n			}\n\n			this.lastTouchIdentifier = touch.identifier;\n\n			// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:\n			// 1) the user does a fling scroll on the scrollable layer\n			// 2) the user stops the fling scroll with another tap\n			// then the event.target of the last 'touchend' event will be the element that was under the user's finger\n			// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check\n			// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).\n			this.updateScrollParent(targetElement);\n		}\n	}\n\n	this.trackingClick = true;\n	this.trackingClickStart = event.timeStamp;\n	this.targetElement = targetElement;\n\n	this.touchStartX = touch.pageX;\n	this.touchStartY = touch.pageY;\n\n	// Prevent phantom clicks on fast double-tap (issue #36)\n	if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {\n		event.preventDefault();\n	}\n\n	return true;\n};\n\n\n/**\n * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.\n *\n * @param {Event} event\n * @returns {boolean}\n */\nFastClick.prototype.touchHasMoved = function(event) {\n	'use strict';\n	var touch = event.changedTouches[0], boundary = this.touchBoundary;\n\n	if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {\n		return true;\n	}\n\n	return false;\n};\n\n\n/**\n * Update the last position.\n *\n * @param {Event} event\n * @returns {boolean}\n */\nFastClick.prototype.onTouchMove = function(event) {\n	'use strict';\n	if (!this.trackingClick) {\n		return true;\n	}\n\n	// If the touch has moved, cancel the click tracking\n	if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {\n		this.trackingClick = false;\n		this.targetElement = null;\n	}\n\n	return true;\n};\n\n\n/**\n * Attempt to find the labelled control for the given label element.\n *\n * @param {EventTarget|HTMLLabelElement} labelElement\n * @returns {Element|null}\n */\nFastClick.prototype.findControl = function(labelElement) {\n	'use strict';\n\n	// Fast path for newer browsers supporting the HTML5 control attribute\n	if (labelElement.control !== undefined) {\n		return labelElement.control;\n	}\n\n	// All browsers under test that support touch events also support the HTML5 htmlFor attribute\n	if (labelElement.htmlFor) {\n		return document.getElementById(labelElement.htmlFor);\n	}\n\n	// If no for attribute exists, attempt to retrieve the first labellable descendant element\n	// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label\n	return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');\n};\n\n\n/**\n * On touch end, determine whether to send a click event at once.\n *\n * @param {Event} event\n * @returns {boolean}\n */\nFastClick.prototype.onTouchEnd = function(event) {\n	'use strict';\n	var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;\n\n	if (!this.trackingClick) {\n		return true;\n	}\n\n	// Prevent phantom clicks on fast double-tap (issue #36)\n	if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {\n		this.cancelNextClick = true;\n		return true;\n	}\n\n	// Reset to prevent wrong click cancel on input (issue #156).\n	this.cancelNextClick = false;\n\n	this.lastClickTime = event.timeStamp;\n\n	trackingClickStart = this.trackingClickStart;\n	this.trackingClick = false;\n	this.trackingClickStart = 0;\n\n	// On some iOS devices, the targetElement supplied with the event is invalid if the layer\n	// is performing a transition or scroll, and has to be re-detected manually. Note that\n	// for this to function correctly, it must be called *after* the event target is checked!\n	// See issue #57; also filed as rdar://13048589 .\n	if (deviceIsIOSWithBadTarget) {\n		touch = event.changedTouches[0];\n\n		// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null\n		targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;\n		targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;\n	}\n\n	targetTagName = targetElement.tagName.toLowerCase();\n	if (targetTagName === 'label') {\n		forElement = this.findControl(targetElement);\n		if (forElement) {\n			this.focus(targetElement);\n			if (deviceIsAndroid) {\n				return false;\n			}\n\n			targetElement = forElement;\n		}\n	} else if (this.needsFocus(targetElement)) {\n\n		// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.\n		// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).\n		if ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {\n			this.targetElement = null;\n			return false;\n		}\n\n		this.focus(targetElement);\n		this.sendClick(targetElement, event);\n\n		// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.\n		// Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)\n		if (!deviceIsIOS || targetTagName !== 'select') {\n			this.targetElement = null;\n			event.preventDefault();\n		}\n\n		return false;\n	}\n\n	if (deviceIsIOS && !deviceIsIOS4) {\n\n		// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled\n		// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).\n		scrollParent = targetElement.fastClickScrollParent;\n		if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {\n			return true;\n		}\n	}\n\n	// Prevent the actual click from going though - unless the target node is marked as requiring\n	// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.\n	if (!this.needsClick(targetElement)) {\n		event.preventDefault();\n		this.sendClick(targetElement, event);\n	}\n\n	return false;\n};\n\n\n/**\n * On touch cancel, stop tracking the click.\n *\n * @returns {void}\n */\nFastClick.prototype.onTouchCancel = function() {\n	'use strict';\n	this.trackingClick = false;\n	this.targetElement = null;\n};\n\n\n/**\n * Determine mouse events which should be permitted.\n *\n * @param {Event} event\n * @returns {boolean}\n */\nFastClick.prototype.onMouse = function(event) {\n	'use strict';\n\n	// If a target element was never set (because a touch event was never fired) allow the event\n	if (!this.targetElement) {\n		return true;\n	}\n\n	if (event.forwardedTouchEvent) {\n		return true;\n	}\n\n	// Programmatically generated events targeting a specific element should be permitted\n	if (!event.cancelable) {\n		return true;\n	}\n\n	// Derive and check the target element to see whether the mouse event needs to be permitted;\n	// unless explicitly enabled, prevent non-touch click events from triggering actions,\n	// to prevent ghost/doubleclicks.\n	if (!this.needsClick(this.targetElement) || this.cancelNextClick) {\n\n		// Prevent any user-added listeners declared on FastClick element from being fired.\n		if (event.stopImmediatePropagation) {\n			event.stopImmediatePropagation();\n		} else {\n\n			// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)\n			event.propagationStopped = true;\n		}\n\n		// Cancel the event\n		event.stopPropagation();\n		event.preventDefault();\n\n		return false;\n	}\n\n	// If the mouse event is permitted, return true for the action to go through.\n	return true;\n};\n\n\n/**\n * On actual clicks, determine whether this is a touch-generated click, a click action occurring\n * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or\n * an actual click which should be permitted.\n *\n * @param {Event} event\n * @returns {boolean}\n */\nFastClick.prototype.onClick = function(event) {\n	'use strict';\n	var permitted;\n\n	// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.\n	if (this.trackingClick) {\n		this.targetElement = null;\n		this.trackingClick = false;\n		return true;\n	}\n\n	// Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.\n	if (event.target.type === 'submit' && event.detail === 0) {\n		return true;\n	}\n\n	permitted = this.onMouse(event);\n\n	// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.\n	if (!permitted) {\n		this.targetElement = null;\n	}\n\n	// If clicks are permitted, return true for the action to go through.\n	return permitted;\n};\n\n\n/**\n * Remove all FastClick's event listeners.\n *\n * @returns {void}\n */\nFastClick.prototype.destroy = function() {\n	'use strict';\n	var layer = this.layer;\n\n	if (deviceIsAndroid) {\n		layer.removeEventListener('mouseover', this.onMouse, true);\n		layer.removeEventListener('mousedown', this.onMouse, true);\n		layer.removeEventListener('mouseup', this.onMouse, true);\n	}\n\n	layer.removeEventListener('click', this.onClick, true);\n	layer.removeEventListener('touchstart', this.onTouchStart, false);\n	layer.removeEventListener('touchmove', this.onTouchMove, false);\n	layer.removeEventListener('touchend', this.onTouchEnd, false);\n	layer.removeEventListener('touchcancel', this.onTouchCancel, false);\n};\n\n\n/**\n * Check whether FastClick is needed.\n *\n * @param {Element} layer The layer to listen on\n */\nFastClick.notNeeded = function(layer) {\n	'use strict';\n	var metaViewport;\n	var chromeVersion;\n	var blackberryVersion;\n\n	// Devices that don't support touch don't need FastClick\n	if (typeof window.ontouchstart === 'undefined') {\n		return true;\n	}\n\n	// Chrome version - zero for other browsers\n	chromeVersion = +(/Chrome\\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];\n\n	if (chromeVersion) {\n\n		if (deviceIsAndroid) {\n			metaViewport = document.querySelector('meta[name=viewport]');\n\n			if (metaViewport) {\n				// Chrome on Android with user-scalable=\"no\" doesn't need FastClick (issue #89)\n				if (metaViewport.content.indexOf('user-scalable=no') !== -1) {\n					return true;\n				}\n				// Chrome 32 and above with width=device-width or less don't need FastClick\n				if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {\n					return true;\n				}\n			}\n\n		// Chrome desktop doesn't need FastClick (issue #15)\n		} else {\n			return true;\n		}\n	}\n\n	if (deviceIsBlackBerry10) {\n		blackberryVersion = navigator.userAgent.match(/Version\\/([0-9]*)\\.([0-9]*)/);\n\n		// BlackBerry 10.3+ does not require Fastclick library.\n		// https://github.com/ftlabs/fastclick/issues/251\n		if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {\n			metaViewport = document.querySelector('meta[name=viewport]');\n\n			if (metaViewport) {\n				// user-scalable=no eliminates click delay.\n				if (metaViewport.content.indexOf('user-scalable=no') !== -1) {\n					return true;\n				}\n				// width=device-width (or less than device-width) eliminates click delay.\n				if (document.documentElement.scrollWidth <= window.outerWidth) {\n					return true;\n				}\n			}\n		}\n	}\n\n	// IE10 with -ms-touch-action: none, which disables double-tap-to-zoom (issue #97)\n	if (layer.style.msTouchAction === 'none') {\n		return true;\n	}\n\n	return false;\n};\n\n\n/**\n * Factory method for creating a FastClick object\n *\n * @param {Element} layer The layer to listen on\n * @param {Object} options The options to override the defaults\n */\nFastClick.attach = function(layer, options) {\n	'use strict';\n	return new FastClick(layer, options);\n};\n\n\nif (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n\n	// AMD. Register as an anonymous module.\n	define(function() {\n		'use strict';\n		return FastClick;\n	});\n} else if (typeof module !== 'undefined' && module.exports) {\n	module.exports = FastClick.attach;\n	module.exports.FastClick = FastClick;\n} else {\n	window.FastClick = FastClick;\n}\n"
}, function(module) {
    module.exports = "/**\n * @license\n * pixi.js - v2.1.0\n * Copyright (c) 2012-2014, Mat Groves\n * http://goodboydigital.com/\n *\n * Compiled: 2014-11-12\n *\n * pixi.js is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license.php\n */\n/**\r\n * @author Mat Groves http://matgroves.com/ @Doormat23\r\n */\r\n\r\n(function(){\r\n\r\n    var root = this;\r\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * @module PIXI\n */\nvar PIXI = PIXI || {};\n\n/* \n* \n* This file contains a lot of pixi consts which are used across the rendering engine\n* @class Consts\n*/\nPIXI.WEBGL_RENDERER = 0;\nPIXI.CANVAS_RENDERER = 1;\n\n// useful for testing against if your lib is using pixi.\nPIXI.VERSION = \"v2.1.0\";\n\n\n// the various blend modes supported by pixi\nPIXI.blendModes = {\n    NORMAL:0,\n    ADD:1,\n    MULTIPLY:2,\n    SCREEN:3,\n    OVERLAY:4,\n    DARKEN:5,\n    LIGHTEN:6,\n    COLOR_DODGE:7,\n    COLOR_BURN:8,\n    HARD_LIGHT:9,\n    SOFT_LIGHT:10,\n    DIFFERENCE:11,\n    EXCLUSION:12,\n    HUE:13,\n    SATURATION:14,\n    COLOR:15,\n    LUMINOSITY:16\n};\n\n// the scale modes\nPIXI.scaleModes = {\n    DEFAULT:0,\n    LINEAR:0,\n    NEAREST:1\n};\n\n// used to create uids for various pixi objects..\nPIXI._UID = 0;\n\nif(typeof(Float32Array) != 'undefined')\n{\n    PIXI.Float32Array = Float32Array;\n    PIXI.Uint16Array = Uint16Array;\n}\nelse\n{\n    PIXI.Float32Array = Array;\n    PIXI.Uint16Array = Array;\n}\n\n// interaction frequency \nPIXI.INTERACTION_FREQUENCY = 30;\nPIXI.AUTO_PREVENT_DEFAULT = true;\n\nPIXI.PI_2 = Math.PI * 2;\nPIXI.RAD_TO_DEG = 180 / Math.PI;\nPIXI.DEG_TO_RAD = Math.PI / 180;\n\nPIXI.RETINA_PREFIX = \"@2x\";\n//PIXI.SCALE_PREFIX \"@x%%\";\n\nPIXI.dontSayHello = false;\n\n\nPIXI.defaultRenderOptions = {\n    view:null, \n    transparent:false, \n    antialias:false, \n    preserveDrawingBuffer:false,\n    resolution:1,\n    clearBeforeRender:true,\n    autoResize:false\n}\n\nPIXI.sayHello = function (type) \n{\n    if(PIXI.dontSayHello)return;\n\n    if ( navigator.userAgent.toLowerCase().indexOf('chrome') > -1 )\n    {\n        var args = [\n            '%c %c %c Pixi.js ' + PIXI.VERSION + ' - ' + type + '  %c ' + ' %c ' + ' http://www.pixijs.com/  %c %c â™¥%câ™¥%câ™¥ ',\n            'background: #ff66a5',\n            'background: #ff66a5',\n            'color: #ff66a5; background: #030307;',\n            'background: #ff66a5',\n            'background: #ffc3dc',\n            'background: #ff66a5',\n            'color: #ff2424; background: #fff',\n            'color: #ff2424; background: #fff',\n            'color: #ff2424; background: #fff'\n        ];\n\n       \n\n        console.log.apply(console, args);\n    }\n    else if (window['console'])\n    {\n        console.log('Pixi.js ' + PIXI.VERSION + ' - http://www.pixijs.com/');\n    }\n\n    PIXI.dontSayHello = true;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * The Point object represents a location in a two-dimensional coordinate system, where x represents the horizontal axis and y represents the vertical axis.\n *\n * @class Point\n * @constructor\n * @param x {Number} position of the point on the x axis\n * @param y {Number} position of the point on the y axis\n */\nPIXI.Point = function(x, y)\n{\n    /**\n     * @property x\n     * @type Number\n     * @default 0\n     */\n    this.x = x || 0;\n\n    /**\n     * @property y\n     * @type Number\n     * @default 0\n     */\n    this.y = y || 0;\n};\n\n/**\n * Creates a clone of this point\n *\n * @method clone\n * @return {Point} a copy of the point\n */\nPIXI.Point.prototype.clone = function()\n{\n    return new PIXI.Point(this.x, this.y);\n};\n\n/**\n * Sets the point to a new x and y position.\n * If y is omitted, both x and y will be set to x.\n * \n * @method set\n * @param [x=0] {Number} position of the point on the x axis\n * @param [y=0] {Number} position of the point on the y axis\n */\nPIXI.Point.prototype.set = function(x, y)\n{\n    this.x = x || 0;\n    this.y = y || ( (y !== 0) ? this.x : 0 ) ;\n};\n\n// constructor\nPIXI.Point.prototype.constructor = PIXI.Point;\n/**\n * @author Mat Groves http://matgroves.com/\n */\n\n/**\n * the Rectangle object is an area defined by its position, as indicated by its top-left corner point (x, y) and by its width and its height.\n *\n * @class Rectangle\n * @constructor\n * @param x {Number} The X coordinate of the upper-left corner of the rectangle\n * @param y {Number} The Y coordinate of the upper-left corner of the rectangle\n * @param width {Number} The overall width of this rectangle\n * @param height {Number} The overall height of this rectangle\n */\nPIXI.Rectangle = function(x, y, width, height)\n{\n    /**\n     * @property x\n     * @type Number\n     * @default 0\n     */\n    this.x = x || 0;\n\n    /**\n     * @property y\n     * @type Number\n     * @default 0\n     */\n    this.y = y || 0;\n\n    /**\n     * @property width\n     * @type Number\n     * @default 0\n     */\n    this.width = width || 0;\n\n    /**\n     * @property height\n     * @type Number\n     * @default 0\n     */\n    this.height = height || 0;\n};\n\n/**\n * Creates a clone of this Rectangle\n *\n * @method clone\n * @return {Rectangle} a copy of the rectangle\n */\nPIXI.Rectangle.prototype.clone = function()\n{\n    return new PIXI.Rectangle(this.x, this.y, this.width, this.height);\n};\n\n/**\n * Checks whether the x and y coordinates given are contained within this Rectangle\n *\n * @method contains\n * @param x {Number} The X coordinate of the point to test\n * @param y {Number} The Y coordinate of the point to test\n * @return {Boolean} Whether the x/y coordinates are within this Rectangle\n */\nPIXI.Rectangle.prototype.contains = function(x, y)\n{\n    if(this.width <= 0 || this.height <= 0)\n        return false;\n\n    var x1 = this.x;\n    if(x >= x1 && x <= x1 + this.width)\n    {\n        var y1 = this.y;\n\n        if(y >= y1 && y <= y1 + this.height)\n        {\n            return true;\n        }\n    }\n\n    return false;\n};\n\n// constructor\nPIXI.Rectangle.prototype.constructor = PIXI.Rectangle;\n\nPIXI.EmptyRectangle = new PIXI.Rectangle(0,0,0,0);\n/**\n * @author Adrien Brault <adrien.brault@gmail.com>\n */\n\n/**\n * @class Polygon\n * @constructor\n * @param points* {Array<Point>|Array<Number>|Point...|Number...} This can be an array of Points that form the polygon,\n *      a flat array of numbers that will be interpreted as [x,y, x,y, ...], or the arguments passed can be\n *      all the points of the polygon e.g. `new PIXI.Polygon(new PIXI.Point(), new PIXI.Point(), ...)`, or the\n *      arguments passed can be flat x,y values e.g. `new PIXI.Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are\n *      Numbers.\n */\nPIXI.Polygon = function(points)\n{\n    //if points isn't an array, use arguments as the array\n    if(!(points instanceof Array))points = Array.prototype.slice.call(arguments);\n\n    //if this is a flat array of numbers, convert it to points\n    if(points[0] instanceof PIXI.Point)\n    {\n        var p = [];\n        for(var i = 0, il = points.length; i < il; i++)\n        {\n            p.push(points[i].x, points[i].y);\n        }\n\n        points = p;\n    }\n\n    this.closed = true;\n    this.points = points;\n};\n\n/**\n * Creates a clone of this polygon\n *\n * @method clone\n * @return {Polygon} a copy of the polygon\n */\nPIXI.Polygon.prototype.clone = function()\n{\n    var points = this.points.slice();\n    return new PIXI.Polygon(points);\n};\n\n/**\n * Checks whether the x and y coordinates passed to this function are contained within this polygon\n *\n * @method contains\n * @param x {Number} The X coordinate of the point to test\n * @param y {Number} The Y coordinate of the point to test\n * @return {Boolean} Whether the x/y coordinates are within this polygon\n */\nPIXI.Polygon.prototype.contains = function(x, y)\n{\n    var inside = false;\n\n    // use some raycasting to test hits\n    // https://github.com/substack/point-in-polygon/blob/master/index.js\n    var length = this.points.length / 2;\n\n    for(var i = 0, j = length - 1; i < length; j = i++)\n    {\n        var xi = this.points[i * 2], yi = this.points[i * 2 + 1],\n            xj = this.points[j * 2], yj = this.points[j * 2 + 1],\n            intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n\n        if(intersect) inside = !inside;\n    }\n\n    return inside;\n};\n\n// constructor\nPIXI.Polygon.prototype.constructor = PIXI.Polygon;\n\n/**\n * @author Chad Engler <chad@pantherdev.com>\n */\n\n/**\n * The Circle object can be used to specify a hit area for displayObjects\n *\n * @class Circle\n * @constructor\n * @param x {Number} The X coordinate of the center of this circle\n * @param y {Number} The Y coordinate of the center of this circle\n * @param radius {Number} The radius of the circle\n */\nPIXI.Circle = function(x, y, radius)\n{\n    /**\n     * @property x\n     * @type Number\n     * @default 0\n     */\n    this.x = x || 0;\n\n    /**\n     * @property y\n     * @type Number\n     * @default 0\n     */\n    this.y = y || 0;\n\n    /**\n     * @property radius\n     * @type Number\n     * @default 0\n     */\n    this.radius = radius || 0;\n};\n\n/**\n * Creates a clone of this Circle instance\n *\n * @method clone\n * @return {Circle} a copy of the Circle\n */\nPIXI.Circle.prototype.clone = function()\n{\n    return new PIXI.Circle(this.x, this.y, this.radius);\n};\n\n/**\n * Checks whether the x and y coordinates given are contained within this circle\n *\n * @method contains\n * @param x {Number} The X coordinate of the point to test\n * @param y {Number} The Y coordinate of the point to test\n * @return {Boolean} Whether the x/y coordinates are within this Circle\n */\nPIXI.Circle.prototype.contains = function(x, y)\n{\n    if(this.radius <= 0)\n        return false;\n\n    var dx = (this.x - x),\n        dy = (this.y - y),\n        r2 = this.radius * this.radius;\n\n    dx *= dx;\n    dy *= dy;\n\n    return (dx + dy <= r2);\n};\n\n/**\n* Returns the framing rectangle of the circle as a PIXI.Rectangle object\n*\n* @method getBounds\n* @return {Rectangle} the framing rectangle\n*/\nPIXI.Circle.prototype.getBounds = function()\n{\n    return new PIXI.Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);\n};\n\n// constructor\nPIXI.Circle.prototype.constructor = PIXI.Circle;\n\n/**\n * @author Chad Engler <chad@pantherdev.com>\n */\n\n/**\n * The Ellipse object can be used to specify a hit area for displayObjects\n *\n * @class Ellipse\n * @constructor\n * @param x {Number} The X coordinate of the center of the ellipse\n * @param y {Number} The Y coordinate of the center of the ellipse\n * @param width {Number} The half width of this ellipse\n * @param height {Number} The half height of this ellipse\n */\nPIXI.Ellipse = function(x, y, width, height)\n{\n    /**\n     * @property x\n     * @type Number\n     * @default 0\n     */\n    this.x = x || 0;\n\n    /**\n     * @property y\n     * @type Number\n     * @default 0\n     */\n    this.y = y || 0;\n\n    /**\n     * @property width\n     * @type Number\n     * @default 0\n     */\n    this.width = width || 0;\n\n    /**\n     * @property height\n     * @type Number\n     * @default 0\n     */\n    this.height = height || 0;\n};\n\n/**\n * Creates a clone of this Ellipse instance\n *\n * @method clone\n * @return {Ellipse} a copy of the ellipse\n */\nPIXI.Ellipse.prototype.clone = function()\n{\n    return new PIXI.Ellipse(this.x, this.y, this.width, this.height);\n};\n\n/**\n * Checks whether the x and y coordinates given are contained within this ellipse\n *\n * @method contains\n * @param x {Number} The X coordinate of the point to test\n * @param y {Number} The Y coordinate of the point to test\n * @return {Boolean} Whether the x/y coords are within this ellipse\n */\nPIXI.Ellipse.prototype.contains = function(x, y)\n{\n    if(this.width <= 0 || this.height <= 0)\n        return false;\n\n    //normalize the coords to an ellipse with center 0,0\n    var normx = ((x - this.x) / this.width),\n        normy = ((y - this.y) / this.height);\n\n    normx *= normx;\n    normy *= normy;\n\n    return (normx + normy <= 1);\n};\n\n/**\n* Returns the framing rectangle of the ellipse as a PIXI.Rectangle object\n*\n* @method getBounds\n* @return {Rectangle} the framing rectangle\n*/\nPIXI.Ellipse.prototype.getBounds = function()\n{\n    return new PIXI.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);\n};\n\n// constructor\nPIXI.Ellipse.prototype.constructor = PIXI.Ellipse;\n\n/**\n * @author Mat Groves http://matgroves.com/\n */\n\n/**\n * the Rounded Rectangle object is an area defined by its position and has nice rounded corners, as indicated by its top-left corner point (x, y) and by its width and its height.\n *\n * @class Rounded Rectangle\n * @constructor\n * @param x {Number} The X coordinate of the upper-left corner of the rounded rectangle\n * @param y {Number} The Y coordinate of the upper-left corner of the rounded rectangle\n * @param width {Number} The overall width of this rounded rectangle\n * @param height {Number} The overall height of this rounded rectangle\n * @param radius {Number} The overall radius of this corners of this rounded rectangle\n */\nPIXI.RoundedRectangle = function(x, y, width, height, radius)\n{\n    /**\n     * @property x\n     * @type Number\n     * @default 0\n     */\n    this.x = x || 0;\n\n    /**\n     * @property y\n     * @type Number\n     * @default 0\n     */\n    this.y = y || 0;\n\n    /**\n     * @property width\n     * @type Number\n     * @default 0\n     */\n    this.width = width || 0;\n\n    /**\n     * @property height\n     * @type Number\n     * @default 0\n     */\n    this.height = height || 0;\n\n    /**\n     * @property radius\n     * @type Number\n     * @default 20\n     */\n    this.radius = radius || 20;\n};\n\n/**\n * Creates a clone of this Rounded Rectangle\n *\n * @method clone\n * @return {rounded Rectangle} a copy of the rounded rectangle\n */\nPIXI.RoundedRectangle.prototype.clone = function()\n{\n    return new PIXI.RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);\n};\n\n/**\n * Checks whether the x and y coordinates given are contained within this Rounded Rectangle\n *\n * @method contains\n * @param x {Number} The X coordinate of the point to test\n * @param y {Number} The Y coordinate of the point to test\n * @return {Boolean} Whether the x/y coordinates are within this Rounded Rectangle\n */\nPIXI.RoundedRectangle.prototype.contains = function(x, y)\n{\n    if(this.width <= 0 || this.height <= 0)\n        return false;\n\n    var x1 = this.x;\n    if(x >= x1 && x <= x1 + this.width)\n    {\n        var y1 = this.y;\n\n        if(y >= y1 && y <= y1 + this.height)\n        {\n            return true;\n        }\n    }\n\n    return false;\n};\n\n// constructor\nPIXI.RoundedRectangle.prototype.constructor = PIXI.RoundedRectangle;\n\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * The Matrix class is now an object, which makes it a lot faster, \n * here is a representation of it : \n * | a | b | tx|\n * | c | d | ty|\n * | 0 | 0 | 1 |\n *\n * @class Matrix\n * @constructor\n */\nPIXI.Matrix = function()\n{\n    /**\n     * @property a\n     * @type Number\n     * @default 1\n     */\n    this.a = 1;\n\n    /**\n     * @property b\n     * @type Number\n     * @default 0\n     */\n    this.b = 0;\n\n    /**\n     * @property c\n     * @type Number\n     * @default 0\n     */\n    this.c = 0;\n\n    /**\n     * @property d\n     * @type Number\n     * @default 1\n     */\n    this.d = 1;\n\n    /**\n     * @property tx\n     * @type Number\n     * @default 0\n     */\n    this.tx = 0;\n\n    /**\n     * @property ty\n     * @type Number\n     * @default 0\n     */\n    this.ty = 0;\n};\n\n/**\n * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:\n *\n * a = array[0]\n * b = array[1]\n * c = array[3]\n * d = array[4]\n * tx = array[2]\n * ty = array[5]\n *\n * @method fromArray\n * @param array {Array} The array that the matrix will be populated from.\n */\nPIXI.Matrix.prototype.fromArray = function(array)\n{\n    this.a = array[0];\n    this.b = array[1];\n    this.c = array[3];\n    this.d = array[4];\n    this.tx = array[2];\n    this.ty = array[5];\n};\n\n/**\n * Creates an array from the current Matrix object.\n *\n * @method toArray\n * @param transpose {Boolean} Whether we need to transpose the matrix or not\n * @return {Array} the newly created array which contains the matrix\n */\nPIXI.Matrix.prototype.toArray = function(transpose)\n{\n    if(!this.array) this.array = new PIXI.Float32Array(9);\n    var array = this.array;\n\n    if(transpose)\n    {\n        array[0] = this.a;\n        array[1] = this.b;\n        array[2] = 0;\n        array[3] = this.c;\n        array[4] = this.d;\n        array[5] = 0;\n        array[6] = this.tx;\n        array[7] = this.ty;\n        array[8] = 1;\n    }\n    else\n    {\n        array[0] = this.a;\n        array[1] = this.c;\n        array[2] = this.tx;\n        array[3] = this.b;\n        array[4] = this.d;\n        array[5] = this.ty;\n        array[6] = 0;\n        array[7] = 0;\n        array[8] = 1;\n    }\n\n    return array;\n};\n\n/**\n * Get a new position with the current transformation applied.\n * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)\n *\n * @method apply\n * @param pos {Point} The origin\n * @param [newPos] {Point} The point that the new position is assigned to (allowed to be same as input)\n * @return {Point} The new point, transformed through this matrix\n */\nPIXI.Matrix.prototype.apply = function(pos, newPos)\n{\n    newPos = newPos || new PIXI.Point();\n\n    newPos.x = this.a * pos.x + this.c * pos.y + this.tx;\n    newPos.y = this.b * pos.x + this.d * pos.y + this.ty;\n\n    return newPos;\n};\n\n/**\n * Get a new position with the inverse of the current transformation applied.\n * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)\n *\n * @method applyInverse\n * @param pos {Point} The origin\n * @param [newPos] {Point} The point that the new position is assigned to (allowed to be same as input)\n * @return {Point} The new point, inverse-transformed through this matrix\n */\nPIXI.Matrix.prototype.applyInverse = function(pos, newPos)\n{\n    newPos = newPos || new PIXI.Point();\n\n    var id = 1 / (this.a * this.d + this.c * -this.b);\n     \n    newPos.x = this.d * id * pos.x + -this.c * id * pos.y + (this.ty * this.c - this.tx * this.d) * id;\n    newPos.y = this.a * id * pos.y + -this.b * id * pos.x + (-this.ty * this.a + this.tx * this.b) * id;\n\n    return newPos;\n};\n\n/**\n * Translates the matrix on the x and y.\n * \n * @method translate\n * @param {Number} x\n * @param {Number} y\n * @return {Matrix} This matrix. Good for chaining method calls.\n **/\nPIXI.Matrix.prototype.translate = function(x, y)\n{\n    this.tx += x;\n    this.ty += y;\n    \n    return this;\n};\n\n/**\n * Applies a scale transformation to the matrix.\n * \n * @method scale\n * @param {Number} x The amount to scale horizontally\n * @param {Number} y The amount to scale vertically\n * @return {Matrix} This matrix. Good for chaining method calls.\n **/\nPIXI.Matrix.prototype.scale = function(x, y)\n{\n    this.a *= x;\n    this.d *= y;\n    this.c *= x;\n    this.b *= y;\n    this.tx *= x;\n    this.ty *= y;\n\n    return this;\n};\n\n\n/**\n * Applies a rotation transformation to the matrix.\n * @method rotate\n * @param {Number} angle The angle in radians.\n * @return {Matrix} This matrix. Good for chaining method calls.\n **/\nPIXI.Matrix.prototype.rotate = function(angle)\n{\n    var cos = Math.cos( angle );\n    var sin = Math.sin( angle );\n\n    var a1 = this.a;\n    var c1 = this.c;\n    var tx1 = this.tx;\n\n    this.a = a1 * cos-this.b * sin;\n    this.b = a1 * sin+this.b * cos;\n    this.c = c1 * cos-this.d * sin;\n    this.d = c1 * sin+this.d * cos;\n    this.tx = tx1 * cos - this.ty * sin;\n    this.ty = tx1 * sin + this.ty * cos;\n \n    return this;\n};\n\n/**\n * Appends the given Matrix to this Matrix.\n * \n * @method append\n * @param {Matrix} matrix\n * @return {Matrix} This matrix. Good for chaining method calls.\n */\nPIXI.Matrix.prototype.append = function(matrix)\n{\n    var a1 = this.a;\n    var b1 = this.b;\n    var c1 = this.c;\n    var d1 = this.d;\n\n    this.a  = matrix.a * a1 + matrix.b * c1;\n    this.b  = matrix.a * b1 + matrix.b * d1;\n    this.c  = matrix.c * a1 + matrix.d * c1;\n    this.d  = matrix.c * b1 + matrix.d * d1;\n\n    this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;\n    this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;\n    \n    return this;\n};\n\n/**\n * Resets this Matix to an identity (default) matrix.\n * \n * @method identity\n * @return {Matrix} This matrix. Good for chaining method calls.\n */\nPIXI.Matrix.prototype.identity = function()\n{\n    this.a = 1;\n    this.b = 0;\n    this.c = 0;\n    this.d = 1;\n    this.tx = 0;\n    this.ty = 0;\n\n    return this;\n};\n\nPIXI.identityMatrix = new PIXI.Matrix();\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * The base class for all objects that are rendered on the screen.\n * This is an abstract class and should not be used on its own rather it should be extended.\n *\n * @class DisplayObject\n * @constructor\n */\nPIXI.DisplayObject = function()\n{\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     *\n     * @property position\n     * @type Point\n     */\n    this.position = new PIXI.Point();\n\n    /**\n     * The scale factor of the object.\n     *\n     * @property scale\n     * @type Point\n     */\n    this.scale = new PIXI.Point(1,1);//{x:1, y:1};\n\n    /**\n     * The pivot point of the displayObject that it rotates around\n     *\n     * @property pivot\n     * @type Point\n     */\n    this.pivot = new PIXI.Point(0,0);\n\n    /**\n     * The rotation of the object in radians.\n     *\n     * @property rotation\n     * @type Number\n     */\n    this.rotation = 0;\n\n    /**\n     * The opacity of the object.\n     *\n     * @property alpha\n     * @type Number\n     */\n    this.alpha = 1;\n\n    /**\n     * The visibility of the object.\n     *\n     * @property visible\n     * @type Boolean\n     */\n    this.visible = true;\n\n    /**\n     * This is the defined area that will pick up mouse / touch events. It is null by default.\n     * Setting it is a neat way of optimising the hitTest function that the interactionManager will use (as it will not need to hit test all the children)\n     *\n     * @property hitArea\n     * @type Rectangle|Circle|Ellipse|Polygon\n     */\n    this.hitArea = null;\n\n    /**\n     * This is used to indicate if the displayObject should display a mouse hand cursor on rollover\n     *\n     * @property buttonMode\n     * @type Boolean\n     */\n    this.buttonMode = false;\n\n    /**\n     * Can this object be rendered\n     *\n     * @property renderable\n     * @type Boolean\n     */\n    this.renderable = false;\n\n    /**\n     * [read-only] The display object container that contains this display object.\n     *\n     * @property parent\n     * @type DisplayObjectContainer\n     * @readOnly\n     */\n    this.parent = null;\n\n    /**\n     * [read-only] The stage the display object is connected to, or undefined if it is not connected to the stage.\n     *\n     * @property stage\n     * @type Stage\n     * @readOnly\n     */\n    this.stage = null;\n\n    /**\n     * [read-only] The multiplied alpha of the displayObject\n     *\n     * @property worldAlpha\n     * @type Number\n     * @readOnly\n     */\n    this.worldAlpha = 1;\n\n    /**\n     * [read-only] Whether or not the object is interactive, do not toggle directly! use the `interactive` property\n     *\n     * @property _interactive\n     * @type Boolean\n     * @readOnly\n     * @private\n     */\n    this._interactive = false;\n\n    /**\n     * This is the cursor that will be used when the mouse is over this object. To enable this the element must have interaction = true and buttonMode = true\n     *\n     * @property defaultCursor\n     * @type String\n     *\n    */\n    this.defaultCursor = 'pointer';\n\n    /**\n     * [read-only] Current transform of the object based on world (parent) factors\n     *\n     * @property worldTransform\n     * @type Matrix\n     * @readOnly\n     * @private\n     */\n    this.worldTransform = new PIXI.Matrix();\n\n    /**\n     * cached sin rotation and cos rotation\n     *\n     * @property _sr\n     * @type Number\n     * @private\n     */\n    this._sr = 0;\n\n    /**\n     * cached sin rotation and cos rotation\n     *\n     * @property _cr\n     * @type Number\n     * @private\n     */\n    this._cr = 1;\n\n    /**\n     * The area the filter is applied to like the hitArea this is used as more of an optimisation\n     * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle\n     *\n     * @property filterArea\n     * @type Rectangle\n     */\n    this.filterArea = null;//new PIXI.Rectangle(0,0,1,1);\n\n    /**\n     * The original, cached bounds of the object\n     *\n     * @property _bounds\n     * @type Rectangle\n     * @private\n     */\n    this._bounds = new PIXI.Rectangle(0, 0, 1, 1);\n\n    /**\n     * The most up-to-date bounds of the object\n     *\n     * @property _currentBounds\n     * @type Rectangle\n     * @private\n     */\n    this._currentBounds = null;\n\n    /**\n     * The original, cached mask of the object\n     *\n     * @property _currentBounds\n     * @type Rectangle\n     * @private\n     */\n    this._mask = null;\n\n    /**\n     * Cached internal flag.\n     *\n     * @property _cacheAsBitmap\n     * @type Boolean\n     * @private\n     */\n    this._cacheAsBitmap = false;\n\n    /**\n     * Cached internal flag.\n     *\n     * @property _cacheIsDirty\n     * @type Boolean\n     * @private\n     */\n    this._cacheIsDirty = false;\n\n\n    /*\n     * MOUSE Callbacks\n     */\n    \n    /**\n     * A callback that is used when the users mouse rolls over the displayObject\n     * @method mouseover\n     * @param interactionData {InteractionData}\n     */\n\n    /**\n     * A callback that is used when the users mouse leaves the displayObject\n     * @method mouseout\n     * @param interactionData {InteractionData}\n     */\n\n    //Left button\n    /**\n     * A callback that is used when the users clicks on the displayObject with their mouse's left button\n     * @method click\n     * @param interactionData {InteractionData}\n     */\n\n    /**\n     * A callback that is used when the user clicks the mouse's left button down over the sprite\n     * @method mousedown\n     * @param interactionData {InteractionData}\n     */\n\n    /**\n     * A callback that is used when the user releases the mouse's left button that was over the displayObject\n     * for this callback to be fired, the mouse's left button must have been pressed down over the displayObject\n     * @method mouseup\n     * @param interactionData {InteractionData}\n     */\n\n    /**\n     * A callback that is used when the user releases the mouse's left button that was over the displayObject but is no longer over the displayObject\n     * for this callback to be fired, the mouse's left button must have been pressed down over the displayObject\n     * @method mouseupoutside\n     * @param interactionData {InteractionData}\n     */\n\n    //Right button\n    /**\n     * A callback that is used when the users clicks on the displayObject with their mouse's right button\n     * @method rightclick\n     * @param interactionData {InteractionData}\n     */\n\n    /**\n     * A callback that is used when the user clicks the mouse's right button down over the sprite\n     * @method rightdown\n     * @param interactionData {InteractionData}\n     */\n\n    /**\n     * A callback that is used when the user releases the mouse's right button that was over the displayObject\n     * for this callback to be fired the mouse's right button must have been pressed down over the displayObject\n     * @method rightup\n     * @param interactionData {InteractionData}\n     */\n\n    /**\n     * A callback that is used when the user releases the mouse's right button that was over the displayObject but is no longer over the displayObject\n     * for this callback to be fired, the mouse's right button must have been pressed down over the displayObject\n     * @method rightupoutside\n     * @param interactionData {InteractionData}\n     */\n\n    /*\n     * TOUCH Callbacks\n     */\n\n    /**\n     * A callback that is used when the users taps on the sprite with their finger\n     * basically a touch version of click\n     * @method tap\n     * @param interactionData {InteractionData}\n     */\n\n    /**\n     * A callback that is used when the user touches over the displayObject\n     * @method touchstart\n     * @param interactionData {InteractionData}\n     */\n\n    /**\n     * A callback that is used when the user releases a touch over the displayObject\n     * @method touchend\n     * @param interactionData {InteractionData}\n     */\n\n    /**\n     * A callback that is used when the user releases the touch that was over the displayObject\n     * for this callback to be fired, The touch must have started over the sprite\n     * @method touchendoutside\n     * @param interactionData {InteractionData}\n     */\n};\n\n// constructor\nPIXI.DisplayObject.prototype.constructor = PIXI.DisplayObject;\n\n/**\n * Indicates if the sprite will have touch and mouse interactivity. It is false by default\n *\n * @property interactive\n * @type Boolean\n * @default false\n */\nObject.defineProperty(PIXI.DisplayObject.prototype, 'interactive', {\n    get: function() {\n        return this._interactive;\n    },\n    set: function(value) {\n        this._interactive = value;\n\n        // TODO more to be done here..\n        // need to sort out a re-crawl!\n        if(this.stage)this.stage.dirty = true;\n    }\n});\n\n/**\n * [read-only] Indicates if the sprite is globally visible.\n *\n * @property worldVisible\n * @type Boolean\n */\nObject.defineProperty(PIXI.DisplayObject.prototype, 'worldVisible', {\n    get: function() {\n        var item = this;\n\n        do\n        {\n            if(!item.visible)return false;\n            item = item.parent;\n        }\n        while(item);\n\n        return true;\n    }\n});\n\n/**\n * Sets a mask for the displayObject. A mask is an object that limits the visibility of an object to the shape of the mask applied to it.\n * In PIXI a regular mask must be a PIXI.Graphics object. This allows for much faster masking in canvas as it utilises shape clipping.\n * To remove a mask, set this property to null.\n *\n * @property mask\n * @type Graphics\n */\nObject.defineProperty(PIXI.DisplayObject.prototype, 'mask', {\n    get: function() {\n        return this._mask;\n    },\n    set: function(value) {\n\n        if(this._mask)this._mask.isMask = false;\n        this._mask = value;\n        if(this._mask)this._mask.isMask = true;\n    }\n});\n\n/**\n * Sets the filters for the displayObject.\n * * IMPORTANT: This is a webGL only feature and will be ignored by the canvas renderer.\n * To remove filters simply set this property to 'null'\n * @property filters\n * @type Array An array of filters\n */\nObject.defineProperty(PIXI.DisplayObject.prototype, 'filters', {\n\n    get: function() {\n        return this._filters;\n    },\n\n    set: function(value) {\n\n        if(value)\n        {\n            // now put all the passes in one place..\n            var passes = [];\n            for (var i = 0; i < value.length; i++)\n            {\n                var filterPasses = value[i].passes;\n                for (var j = 0; j < filterPasses.length; j++)\n                {\n                    passes.push(filterPasses[j]);\n                }\n            }\n\n            // TODO change this as it is legacy\n            this._filterBlock = {target:this, filterPasses:passes};\n        }\n\n        this._filters = value;\n    }\n});\n\n/**\n * Set if this display object is cached as a bitmap.\n * This basically takes a snap shot of the display object as it is at that moment. It can provide a performance benefit for complex static displayObjects.\n * To remove simply set this property to 'null'\n * @property cacheAsBitmap\n * @type Boolean\n */\nObject.defineProperty(PIXI.DisplayObject.prototype, 'cacheAsBitmap', {\n\n    get: function() {\n        return  this._cacheAsBitmap;\n    },\n\n    set: function(value) {\n\n        if(this._cacheAsBitmap === value)return;\n\n        if(value)\n        {\n            this._generateCachedSprite();\n        }\n        else\n        {\n            this._destroyCachedSprite();\n        }\n\n        this._cacheAsBitmap = value;\n    }\n});\n\n/*\n * Updates the object transform for rendering\n *\n * @method updateTransform\n * @private\n */\nPIXI.DisplayObject.prototype.updateTransform = function()\n{\n    // create some matrix refs for easy access\n    var pt = this.parent.worldTransform;\n    var wt = this.worldTransform;\n\n    // temporary matrix variables\n    var a, b, c, d, tx, ty;\n\n    // TODO create a const for 2_PI \n    // so if rotation is between 0 then we can simplify the multiplication process..\n    if(this.rotation % PIXI.PI_2)\n    {\n        // check to see if the rotation is the same as the previous render. This means we only need to use sin and cos when rotation actually changes\n        if(this.rotation !== this.rotationCache)\n        {\n            this.rotationCache = this.rotation;\n            this._sr = Math.sin(this.rotation);\n            this._cr = Math.cos(this.rotation);\n        }\n\n        // get the matrix values of the displayobject based on its transform properties..\n        a  =  this._cr * this.scale.x;\n        b  =  this._sr * this.scale.x;\n        c  = -this._sr * this.scale.y;\n        d  =  this._cr * this.scale.y;\n        tx =  this.position.x;\n        ty =  this.position.y;\n        \n        // check for pivot.. not often used so geared towards that fact!\n        if(this.pivot.x || this.pivot.y)\n        {\n            tx -= this.pivot.x * a + this.pivot.y * c;\n            ty -= this.pivot.x * b + this.pivot.y * d;\n        }\n\n        // concat the parent matrix with the objects transform.\n        wt.a  = a  * pt.a + b  * pt.c;\n        wt.b  = a  * pt.b + b  * pt.d;\n        wt.c  = c  * pt.a + d  * pt.c;\n        wt.d  = c  * pt.b + d  * pt.d;\n        wt.tx = tx * pt.a + ty * pt.c + pt.tx;\n        wt.ty = tx * pt.b + ty * pt.d + pt.ty;\n\n        \n    }\n    else\n    {\n        // lets do the fast version as we know there is no rotation..\n        a  = this.scale.x;\n        d  = this.scale.y;\n\n        tx = this.position.x - this.pivot.x * a;\n        ty = this.position.y - this.pivot.y * d;\n\n        wt.a  = a  * pt.a;\n        wt.b  = a  * pt.b;\n        wt.c  = d  * pt.c;\n        wt.d  = d  * pt.d;\n        wt.tx = tx * pt.a + ty * pt.c + pt.tx;\n        wt.ty = tx * pt.b + ty * pt.d + pt.ty;\n    }\n\n    // multiply the alphas..\n    this.worldAlpha = this.alpha * this.parent.worldAlpha;\n};\n\n// performance increase to avoid using call.. (10x faster)\nPIXI.DisplayObject.prototype.displayObjectUpdateTransform = PIXI.DisplayObject.prototype.updateTransform;\n\n/**\n * Retrieves the bounds of the displayObject as a rectangle object\n *\n * @method getBounds\n * @param matrix {Matrix}\n * @return {Rectangle} the rectangular bounding area\n */\nPIXI.DisplayObject.prototype.getBounds = function(matrix)\n{\n    matrix = matrix;//just to get passed js hinting (and preserve inheritance)\n    return PIXI.EmptyRectangle;\n};\n\n/**\n * Retrieves the local bounds of the displayObject as a rectangle object\n *\n * @method getLocalBounds\n * @return {Rectangle} the rectangular bounding area\n */\nPIXI.DisplayObject.prototype.getLocalBounds = function()\n{\n    return this.getBounds(PIXI.identityMatrix);///PIXI.EmptyRectangle();\n};\n\n/**\n * Sets the object's stage reference, the stage this object is connected to\n *\n * @method setStageReference\n * @param stage {Stage} the stage that the object will have as its current stage reference\n */\nPIXI.DisplayObject.prototype.setStageReference = function(stage)\n{\n    this.stage = stage;\n    if(this._interactive)this.stage.dirty = true;\n};\n\n/**\n * Useful function that returns a texture of the displayObject object that can then be used to create sprites\n * This can be quite useful if your displayObject is static / complicated and needs to be reused multiple times.\n *\n * @method generateTexture\n * @param resolution {Number} The resolution of the texture being generated\n * @param scaleMode {Number} Should be one of the PIXI.scaleMode consts\n * @param renderer {CanvasRenderer|WebGLRenderer} The renderer used to generate the texture.\n * @return {Texture} a texture of the graphics object\n */\nPIXI.DisplayObject.prototype.generateTexture = function(resolution, scaleMode, renderer)\n{\n    var bounds = this.getLocalBounds();\n\n    var renderTexture = new PIXI.RenderTexture(bounds.width | 0, bounds.height | 0, renderer, scaleMode, resolution);\n    \n    PIXI.DisplayObject._tempMatrix.tx = -bounds.x;\n    PIXI.DisplayObject._tempMatrix.ty = -bounds.y;\n    \n    renderTexture.render(this, PIXI.DisplayObject._tempMatrix);\n\n    return renderTexture;\n};\n\n/**\n * Generates and updates the cached sprite for this object.\n *\n * @method updateCache\n */\nPIXI.DisplayObject.prototype.updateCache = function()\n{\n    this._generateCachedSprite();\n};\n\n/**\n * Calculates the global position of the display object\n *\n * @method toGlobal\n * @param position {Point} The world origin to calculate from\n * @return {Point} A point object representing the position of this object\n */\nPIXI.DisplayObject.prototype.toGlobal = function(position)\n{\n    this.updateTransform();\n    return this.worldTransform.apply(position);\n};\n\n/**\n * Calculates the local position of the display object relative to another point\n *\n * @method toLocal\n * @param position {Point} The world origin to calculate from\n * @param [from] {DisplayObject} The DisplayObject to calculate the global position from\n * @return {Point} A point object representing the position of this object\n */\nPIXI.DisplayObject.prototype.toLocal = function(position, from)\n{\n    if (from)\n    {\n        position = from.toGlobal(position);\n    }\n\n    this.updateTransform();\n\n    return this.worldTransform.applyInverse(position);\n};\n\n/**\n * Internal method.\n *\n * @method _renderCachedSprite\n * @param renderSession {Object} The render session\n * @private\n */\nPIXI.DisplayObject.prototype._renderCachedSprite = function(renderSession)\n{\n    this._cachedSprite.worldAlpha = this.worldAlpha;\n\n    if(renderSession.gl)\n    {\n        PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, renderSession);\n    }\n    else\n    {\n        PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, renderSession);\n    }\n};\n\n/**\n * Internal method.\n *\n * @method _generateCachedSprite\n * @private\n */\nPIXI.DisplayObject.prototype._generateCachedSprite = function()\n{\n    this._cacheAsBitmap = false;\n    var bounds = this.getLocalBounds();\n\n    if(!this._cachedSprite)\n    {\n        var renderTexture = new PIXI.RenderTexture(bounds.width | 0, bounds.height | 0);//, renderSession.renderer);\n\n        this._cachedSprite = new PIXI.Sprite(renderTexture);\n        this._cachedSprite.worldTransform = this.worldTransform;\n    }\n    else\n    {\n        this._cachedSprite.texture.resize(bounds.width | 0, bounds.height | 0);\n    }\n\n    //REMOVE filter!\n    var tempFilters = this._filters;\n    this._filters = null;\n\n    this._cachedSprite.filters = tempFilters;\n\n    PIXI.DisplayObject._tempMatrix.tx = -bounds.x;\n    PIXI.DisplayObject._tempMatrix.ty = -bounds.y;\n    \n    this._cachedSprite.texture.render(this, PIXI.DisplayObject._tempMatrix );\n\n    this._cachedSprite.anchor.x = -( bounds.x / bounds.width );\n    this._cachedSprite.anchor.y = -( bounds.y / bounds.height );\n\n    this._filters = tempFilters;\n\n    this._cacheAsBitmap = true;\n};\n\n/**\n* Destroys the cached sprite.\n*\n* @method _destroyCachedSprite\n* @private\n*/\nPIXI.DisplayObject.prototype._destroyCachedSprite = function()\n{\n    if(!this._cachedSprite)return;\n\n    this._cachedSprite.texture.destroy(true);\n\n    // TODO could be object pooled!\n    this._cachedSprite = null;\n};\n\n/**\n* Renders the object using the WebGL renderer\n*\n* @method _renderWebGL\n* @param renderSession {RenderSession}\n* @private\n*/\nPIXI.DisplayObject.prototype._renderWebGL = function(renderSession)\n{\n    // OVERWRITE;\n    // this line is just here to pass jshinting :)\n    renderSession = renderSession;\n};\n\n/**\n* Renders the object using the Canvas renderer\n*\n* @method _renderCanvas\n* @param renderSession {RenderSession}\n* @private\n*/\nPIXI.DisplayObject.prototype._renderCanvas = function(renderSession)\n{\n    // OVERWRITE;\n    // this line is just here to pass jshinting :)\n    renderSession = renderSession;\n};\n\n\nPIXI.DisplayObject._tempMatrix = new PIXI.Matrix();\n\n/**\n * The position of the displayObject on the x axis relative to the local coordinates of the parent.\n *\n * @property x\n * @type Number\n */\nObject.defineProperty(PIXI.DisplayObject.prototype, 'x', {\n    get: function() {\n        return  this.position.x;\n    },\n    set: function(value) {\n        this.position.x = value;\n    }\n});\n\n/**\n * The position of the displayObject on the y axis relative to the local coordinates of the parent.\n *\n * @property y\n * @type Number\n */\nObject.defineProperty(PIXI.DisplayObject.prototype, 'y', {\n    get: function() {\n        return  this.position.y;\n    },\n    set: function(value) {\n        this.position.y = value;\n    }\n});\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * A DisplayObjectContainer represents a collection of display objects.\n * It is the base class of all display objects that act as a container for other objects.\n *\n * @class DisplayObjectContainer\n * @extends DisplayObject\n * @constructor\n */\nPIXI.DisplayObjectContainer = function()\n{\n    PIXI.DisplayObject.call( this );\n\n    /**\n     * [read-only] The array of children of this container.\n     *\n     * @property children\n     * @type Array<DisplayObject>\n     * @readOnly\n     */\n    this.children = [];\n\n    // fast access to update transform..\n    \n};\n\n// constructor\nPIXI.DisplayObjectContainer.prototype = Object.create( PIXI.DisplayObject.prototype );\nPIXI.DisplayObjectContainer.prototype.constructor = PIXI.DisplayObjectContainer;\n\n\n/**\n * The width of the displayObjectContainer, setting this will actually modify the scale to achieve the value set\n *\n * @property width\n * @type Number\n */\nObject.defineProperty(PIXI.DisplayObjectContainer.prototype, 'width', {\n    get: function() {\n        return this.scale.x * this.getLocalBounds().width;\n    },\n    set: function(value) {\n        \n        var width = this.getLocalBounds().width;\n\n        if(width !== 0)\n        {\n            this.scale.x = value / width;\n        }\n        else\n        {\n            this.scale.x = 1;\n        }\n\n        \n        this._width = value;\n    }\n});\n\n/**\n * The height of the displayObjectContainer, setting this will actually modify the scale to achieve the value set\n *\n * @property height\n * @type Number\n */\nObject.defineProperty(PIXI.DisplayObjectContainer.prototype, 'height', {\n    get: function() {\n        return  this.scale.y * this.getLocalBounds().height;\n    },\n    set: function(value) {\n\n        var height = this.getLocalBounds().height;\n\n        if(height !== 0)\n        {\n            this.scale.y = value / height ;\n        }\n        else\n        {\n            this.scale.y = 1;\n        }\n\n        this._height = value;\n    }\n});\n\n/**\n * Adds a child to the container.\n *\n * @method addChild\n * @param child {DisplayObject} The DisplayObject to add to the container\n * @return {DisplayObject} The child that was added.\n */\nPIXI.DisplayObjectContainer.prototype.addChild = function(child)\n{\n    return this.addChildAt(child, this.children.length);\n};\n\n/**\n * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown\n *\n * @method addChildAt\n * @param child {DisplayObject} The child to add\n * @param index {Number} The index to place the child in\n * @return {DisplayObject} The child that was added.\n */\nPIXI.DisplayObjectContainer.prototype.addChildAt = function(child, index)\n{\n    if(index >= 0 && index <= this.children.length)\n    {\n        if(child.parent)\n        {\n            child.parent.removeChild(child);\n        }\n\n        child.parent = this;\n\n        this.children.splice(index, 0, child);\n\n        if(this.stage)child.setStageReference(this.stage);\n\n        return child;\n    }\n    else\n    {\n        throw new Error(child + 'addChildAt: The index '+ index +' supplied is out of bounds ' + this.children.length);\n    }\n};\n\n/**\n * Swaps the position of 2 Display Objects within this container.\n *\n * @method swapChildren\n * @param child {DisplayObject}\n * @param child2 {DisplayObject}\n */\nPIXI.DisplayObjectContainer.prototype.swapChildren = function(child, child2)\n{\n    if(child === child2) {\n        return;\n    }\n\n    var index1 = this.getChildIndex(child);\n    var index2 = this.getChildIndex(child2);\n\n    if(index1 < 0 || index2 < 0) {\n        throw new Error('swapChildren: Both the supplied DisplayObjects must be a child of the caller.');\n    }\n\n    this.children[index1] = child2;\n    this.children[index2] = child;\n\n};\n\n/**\n * Returns the index position of a child DisplayObject instance\n *\n * @method getChildIndex\n * @param child {DisplayObject} The DisplayObject instance to identify\n * @return {Number} The index position of the child display object to identify\n */\nPIXI.DisplayObjectContainer.prototype.getChildIndex = function(child)\n{\n    var index = this.children.indexOf(child);\n    if (index === -1)\n    {\n        throw new Error('The supplied DisplayObject must be a child of the caller');\n    }\n    return index;\n};\n\n/**\n * Changes the position of an existing child in the display object container\n *\n * @method setChildIndex\n * @param child {DisplayObject} The child DisplayObject instance for which you want to change the index number\n * @param index {Number} The resulting index number for the child display object\n */\nPIXI.DisplayObjectContainer.prototype.setChildIndex = function(child, index)\n{\n    if (index < 0 || index >= this.children.length)\n    {\n        throw new Error('The supplied index is out of bounds');\n    }\n    var currentIndex = this.getChildIndex(child);\n    this.children.splice(currentIndex, 1); //remove from old position\n    this.children.splice(index, 0, child); //add at new position\n};\n\n/**\n * Returns the child at the specified index\n *\n * @method getChildAt\n * @param index {Number} The index to get the child from\n * @return {DisplayObject} The child at the given index, if any.\n */\nPIXI.DisplayObjectContainer.prototype.getChildAt = function(index)\n{\n    if (index < 0 || index >= this.children.length)\n    {\n        throw new Error('getChildAt: Supplied index '+ index +' does not exist in the child list, or the supplied DisplayObject must be a child of the caller');\n    }\n    return this.children[index];\n    \n};\n\n/**\n * Removes a child from the container.\n *\n * @method removeChild\n * @param child {DisplayObject} The DisplayObject to remove\n * @return {DisplayObject} The child that was removed.\n */\nPIXI.DisplayObjectContainer.prototype.removeChild = function(child)\n{\n    var index = this.children.indexOf( child );\n    if(index === -1)return;\n    \n    return this.removeChildAt( index );\n};\n\n/**\n * Removes a child from the specified index position.\n *\n * @method removeChildAt\n * @param index {Number} The index to get the child from\n * @return {DisplayObject} The child that was removed.\n */\nPIXI.DisplayObjectContainer.prototype.removeChildAt = function(index)\n{\n    var child = this.getChildAt( index );\n    if(this.stage)\n        child.removeStageReference();\n\n    child.parent = undefined;\n    this.children.splice( index, 1 );\n    return child;\n};\n\n/**\n* Removes all children from this container that are within the begin and end indexes.\n*\n* @method removeChildren\n* @param beginIndex {Number} The beginning position. Default value is 0.\n* @param endIndex {Number} The ending position. Default value is size of the container.\n*/\nPIXI.DisplayObjectContainer.prototype.removeChildren = function(beginIndex, endIndex)\n{\n    var begin = beginIndex || 0;\n    var end = typeof endIndex === 'number' ? endIndex : this.children.length;\n    var range = end - begin;\n\n    if (range > 0 && range <= end)\n    {\n        var removed = this.children.splice(begin, range);\n        for (var i = 0; i < removed.length; i++) {\n            var child = removed[i];\n            if(this.stage)\n                child.removeStageReference();\n            child.parent = undefined;\n        }\n        return removed;\n    }\n    else if (range === 0 && this.children.length === 0)\n    {\n        return [];\n    }\n    else\n    {\n        throw new Error( 'removeChildren: Range Error, numeric values are outside the acceptable range' );\n    }\n};\n\n/*\n * Updates the transform on all children of this container for rendering\n *\n * @method updateTransform\n * @private\n */\nPIXI.DisplayObjectContainer.prototype.updateTransform = function()\n{\n    if(!this.visible)return;\n\n    this.displayObjectUpdateTransform();\n\n    //PIXI.DisplayObject.prototype.updateTransform.call( this );\n\n    if(this._cacheAsBitmap)return;\n\n    for(var i=0,j=this.children.length; i<j; i++)\n    {\n        this.children[i].updateTransform();\n    }\n};\n\n// performance increase to avoid using call.. (10x faster)\nPIXI.DisplayObjectContainer.prototype.displayObjectContainerUpdateTransform = PIXI.DisplayObjectContainer.prototype.updateTransform;\n\n/**\n * Retrieves the bounds of the displayObjectContainer as a rectangle. The bounds calculation takes all visible children into consideration.\n *\n * @method getBounds\n * @return {Rectangle} The rectangular bounding area\n */\nPIXI.DisplayObjectContainer.prototype.getBounds = function()\n{\n    if(this.children.length === 0)return PIXI.EmptyRectangle;\n\n    // TODO the bounds have already been calculated this render session so return what we have\n\n    var minX = Infinity;\n    var minY = Infinity;\n\n    var maxX = -Infinity;\n    var maxY = -Infinity;\n\n    var childBounds;\n    var childMaxX;\n    var childMaxY;\n\n    var childVisible = false;\n\n    for(var i=0,j=this.children.length; i<j; i++)\n    {\n        var child = this.children[i];\n        \n        if(!child.visible)continue;\n\n        childVisible = true;\n\n        childBounds = this.children[i].getBounds();\n     \n        minX = minX < childBounds.x ? minX : childBounds.x;\n        minY = minY < childBounds.y ? minY : childBounds.y;\n\n        childMaxX = childBounds.width + childBounds.x;\n        childMaxY = childBounds.height + childBounds.y;\n\n        maxX = maxX > childMaxX ? maxX : childMaxX;\n        maxY = maxY > childMaxY ? maxY : childMaxY;\n    }\n\n    if(!childVisible)\n        return PIXI.EmptyRectangle;\n\n    var bounds = this._bounds;\n\n    bounds.x = minX;\n    bounds.y = minY;\n    bounds.width = maxX - minX;\n    bounds.height = maxY - minY;\n\n    // TODO: store a reference so that if this function gets called again in the render cycle we do not have to recalculate\n    //this._currentBounds = bounds;\n   \n    return bounds;\n};\n\n/**\n * Retrieves the non-global local bounds of the displayObjectContainer as a rectangle. The calculation takes all visible children into consideration.\n *\n * @method getLocalBounds\n * @return {Rectangle} The rectangular bounding area\n */\nPIXI.DisplayObjectContainer.prototype.getLocalBounds = function()\n{\n    var matrixCache = this.worldTransform;\n\n    this.worldTransform = PIXI.identityMatrix;\n\n    for(var i=0,j=this.children.length; i<j; i++)\n    {\n        this.children[i].updateTransform();\n    }\n\n    var bounds = this.getBounds();\n\n    this.worldTransform = matrixCache;\n\n    return bounds;\n};\n\n/**\n * Sets the containers Stage reference. This is the Stage that this object, and all of its children, is connected to.\n *\n * @method setStageReference\n * @param stage {Stage} the stage that the container will have as its current stage reference\n */\nPIXI.DisplayObjectContainer.prototype.setStageReference = function(stage)\n{\n    this.stage = stage;\n    if(this._interactive)this.stage.dirty = true;\n\n    for(var i=0,j=this.children.length; i<j; i++)\n    {\n        var child = this.children[i];\n        child.setStageReference(stage);\n    }\n};\n\n/**\n * Removes the current stage reference from the container and all of its children.\n *\n * @method removeStageReference\n */\nPIXI.DisplayObjectContainer.prototype.removeStageReference = function()\n{\n\n    for(var i=0,j=this.children.length; i<j; i++)\n    {\n        var child = this.children[i];\n        child.removeStageReference();\n    }\n\n    if(this._interactive)this.stage.dirty = true;\n    \n    this.stage = null;\n};\n\n/**\n* Renders the object using the WebGL renderer\n*\n* @method _renderWebGL\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.DisplayObjectContainer.prototype._renderWebGL = function(renderSession)\n{\n    if(!this.visible || this.alpha <= 0)return;\n    \n    if(this._cacheAsBitmap)\n    {\n        this._renderCachedSprite(renderSession);\n        return;\n    }\n    \n    var i,j;\n\n    if(this._mask || this._filters)\n    {\n        \n        // push filter first as we need to ensure the stencil buffer is correct for any masking\n        if(this._filters)\n        {\n            renderSession.spriteBatch.flush();\n            renderSession.filterManager.pushFilter(this._filterBlock);\n        }\n\n        if(this._mask)\n        {\n            renderSession.spriteBatch.stop();\n            renderSession.maskManager.pushMask(this.mask, renderSession);\n            renderSession.spriteBatch.start();\n        }\n\n        // simple render children!\n        for(i=0,j=this.children.length; i<j; i++)\n        {\n            this.children[i]._renderWebGL(renderSession);\n        }\n\n        renderSession.spriteBatch.stop();\n\n        if(this._mask)renderSession.maskManager.popMask(this._mask, renderSession);\n        if(this._filters)renderSession.filterManager.popFilter();\n        \n        renderSession.spriteBatch.start();\n    }\n    else\n    {\n        // simple render children!\n        for(i=0,j=this.children.length; i<j; i++)\n        {\n            this.children[i]._renderWebGL(renderSession);\n        }\n    }\n};\n\n/**\n* Renders the object using the Canvas renderer\n*\n* @method _renderCanvas\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.DisplayObjectContainer.prototype._renderCanvas = function(renderSession)\n{\n    if(this.visible === false || this.alpha === 0)return;\n\n    if(this._cacheAsBitmap)\n    {\n\n        this._renderCachedSprite(renderSession);\n        return;\n    }\n\n    if(this._mask)\n    {\n        renderSession.maskManager.pushMask(this._mask, renderSession);\n    }\n\n    for(var i=0,j=this.children.length; i<j; i++)\n    {\n        var child = this.children[i];\n        child._renderCanvas(renderSession);\n    }\n\n    if(this._mask)\n    {\n        renderSession.maskManager.popMask(renderSession);\n    }\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * The Sprite object is the base for all textured objects that are rendered to the screen\n *\n * @class Sprite\n * @extends DisplayObjectContainer\n * @constructor\n * @param texture {Texture} The texture for this sprite\n *\n * A sprite can be created directly from an image like this :\n * var sprite = new PIXI.Sprite.fromImage('assets/image.png');\n * yourStage.addChild(sprite);\n * then obviously don't forget to add it to the stage you have already created\n */\nPIXI.Sprite = function(texture)\n{\n    PIXI.DisplayObjectContainer.call( this );\n\n    /**\n     * The anchor sets the origin point of the texture.\n     * The default is 0,0 this means the texture's origin is the top left\n     * Setting than anchor to 0.5,0.5 means the textures origin is centered\n     * Setting the anchor to 1,1 would mean the textures origin points will be the bottom right corner\n     *\n     * @property anchor\n     * @type Point\n     */\n    this.anchor = new PIXI.Point();\n\n    /**\n     * The texture that the sprite is using\n     *\n     * @property texture\n     * @type Texture\n     */\n    this.texture = texture;\n\n    /**\n     * The width of the sprite (this is initially set by the texture)\n     *\n     * @property _width\n     * @type Number\n     * @private\n     */\n    this._width = 0;\n\n    /**\n     * The height of the sprite (this is initially set by the texture)\n     *\n     * @property _height\n     * @type Number\n     * @private\n     */\n    this._height = 0;\n\n    /**\n     * The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF will remove any tint effect.\n     *\n     * @property tint\n     * @type Number\n     * @default 0xFFFFFF\n     */\n    this.tint = 0xFFFFFF;\n\n    /**\n     * The blend mode to be applied to the sprite. Set to PIXI.blendModes.NORMAL to remove any blend mode.\n     *\n     * @property blendMode\n     * @type Number\n     * @default PIXI.blendModes.NORMAL;\n     */\n    this.blendMode = PIXI.blendModes.NORMAL;\n\n    /**\n     * The shader that will be used to render the texture to the stage. Set to null to remove a current shader.\n     *\n     * @property shader\n     * @type PIXI.AbstractFilter\n     * @default null\n     */\n    this.shader = null;\n\n    if(texture.baseTexture.hasLoaded)\n    {\n        this.onTextureUpdate();\n    }\n    else\n    {\n        this.texture.on( 'update', this.onTextureUpdate.bind(this) );\n    }\n\n    this.renderable = true;\n\n};\n\n// constructor\nPIXI.Sprite.prototype = Object.create( PIXI.DisplayObjectContainer.prototype );\nPIXI.Sprite.prototype.constructor = PIXI.Sprite;\n\n/**\n * The width of the sprite, setting this will actually modify the scale to achieve the value set\n *\n * @property width\n * @type Number\n */\nObject.defineProperty(PIXI.Sprite.prototype, 'width', {\n    get: function() {\n        return this.scale.x * this.texture.frame.width;\n    },\n    set: function(value) {\n        this.scale.x = value / this.texture.frame.width;\n        this._width = value;\n    }\n});\n\n/**\n * The height of the sprite, setting this will actually modify the scale to achieve the value set\n *\n * @property height\n * @type Number\n */\nObject.defineProperty(PIXI.Sprite.prototype, 'height', {\n    get: function() {\n        return  this.scale.y * this.texture.frame.height;\n    },\n    set: function(value) {\n        this.scale.y = value / this.texture.frame.height;\n        this._height = value;\n    }\n});\n\n/**\n * Sets the texture of the sprite\n *\n * @method setTexture\n * @param texture {Texture} The PIXI texture that is displayed by the sprite\n */\nPIXI.Sprite.prototype.setTexture = function(texture)\n{\n    this.texture = texture;\n    this.cachedTint = 0xFFFFFF;\n};\n\n/**\n * When the texture is updated, this event will fire to update the scale and frame\n *\n * @method onTextureUpdate\n * @param event\n * @private\n */\nPIXI.Sprite.prototype.onTextureUpdate = function()\n{\n    // so if _width is 0 then width was not set..\n    if(this._width)this.scale.x = this._width / this.texture.frame.width;\n    if(this._height)this.scale.y = this._height / this.texture.frame.height;\n\n    //this.updateFrame = true;\n};\n\n/**\n* Returns the bounds of the Sprite as a rectangle. The bounds calculation takes the worldTransform into account.\n*\n* @method getBounds\n* @param matrix {Matrix} the transformation matrix of the sprite\n* @return {Rectangle} the framing rectangle\n*/\nPIXI.Sprite.prototype.getBounds = function(matrix)\n{\n    var width = this.texture.frame.width;\n    var height = this.texture.frame.height;\n\n    var w0 = width * (1-this.anchor.x);\n    var w1 = width * -this.anchor.x;\n\n    var h0 = height * (1-this.anchor.y);\n    var h1 = height * -this.anchor.y;\n\n    var worldTransform = matrix || this.worldTransform ;\n\n    var a = worldTransform.a;\n    var b = worldTransform.b;\n    var c = worldTransform.c;\n    var d = worldTransform.d;\n    var tx = worldTransform.tx;\n    var ty = worldTransform.ty;\n\n    var x1 = a * w1 + c * h1 + tx;\n    var y1 = d * h1 + b * w1 + ty;\n\n    var x2 = a * w0 + c * h1 + tx;\n    var y2 = d * h1 + b * w0 + ty;\n\n    var x3 = a * w0 + c * h0 + tx;\n    var y3 = d * h0 + b * w0 + ty;\n\n    var x4 =  a * w1 + c * h0 + tx;\n    var y4 =  d * h0 + b * w1 + ty;\n\n    var maxX = -Infinity;\n    var maxY = -Infinity;\n\n    var minX = Infinity;\n    var minY = Infinity;\n\n    minX = x1 < minX ? x1 : minX;\n    minX = x2 < minX ? x2 : minX;\n    minX = x3 < minX ? x3 : minX;\n    minX = x4 < minX ? x4 : minX;\n\n    minY = y1 < minY ? y1 : minY;\n    minY = y2 < minY ? y2 : minY;\n    minY = y3 < minY ? y3 : minY;\n    minY = y4 < minY ? y4 : minY;\n\n    maxX = x1 > maxX ? x1 : maxX;\n    maxX = x2 > maxX ? x2 : maxX;\n    maxX = x3 > maxX ? x3 : maxX;\n    maxX = x4 > maxX ? x4 : maxX;\n\n    maxY = y1 > maxY ? y1 : maxY;\n    maxY = y2 > maxY ? y2 : maxY;\n    maxY = y3 > maxY ? y3 : maxY;\n    maxY = y4 > maxY ? y4 : maxY;\n\n    var bounds = this._bounds;\n\n    bounds.x = minX;\n    bounds.width = maxX - minX;\n\n    bounds.y = minY;\n    bounds.height = maxY - minY;\n\n    // store a reference so that if this function gets called again in the render cycle we do not have to recalculate\n    this._currentBounds = bounds;\n\n    return bounds;\n};\n\n/**\n* Renders the object using the WebGL renderer\n*\n* @method _renderWebGL\n* @param renderSession {RenderSession}\n* @private\n*/\nPIXI.Sprite.prototype._renderWebGL = function(renderSession)\n{\n    // if the sprite is not visible or the alpha is 0 then no need to render this element\n    if(!this.visible || this.alpha <= 0)return;\n\n    var i,j;\n\n    // do a quick check to see if this element has a mask or a filter.\n    if(this._mask || this._filters)\n    {\n        var spriteBatch =  renderSession.spriteBatch;\n\n        // push filter first as we need to ensure the stencil buffer is correct for any masking\n        if(this._filters)\n        {\n            spriteBatch.flush();\n            renderSession.filterManager.pushFilter(this._filterBlock);\n        }\n\n        if(this._mask)\n        {\n            spriteBatch.stop();\n            renderSession.maskManager.pushMask(this.mask, renderSession);\n            spriteBatch.start();\n        }\n\n        // add this sprite to the batch\n        spriteBatch.render(this);\n\n        // now loop through the children and make sure they get rendered\n        for(i=0,j=this.children.length; i<j; i++)\n        {\n            this.children[i]._renderWebGL(renderSession);\n        }\n\n        // time to stop the sprite batch as either a mask element or a filter draw will happen next\n        spriteBatch.stop();\n\n        if(this._mask)renderSession.maskManager.popMask(this._mask, renderSession);\n        if(this._filters)renderSession.filterManager.popFilter();\n\n        spriteBatch.start();\n    }\n    else\n    {\n        renderSession.spriteBatch.render(this);\n\n        // simple render children!\n        for(i=0,j=this.children.length; i<j; i++)\n        {\n            this.children[i]._renderWebGL(renderSession);\n        }\n\n    }\n};\n\n/**\n* Renders the object using the Canvas renderer\n*\n* @method _renderCanvas\n* @param renderSession {RenderSession}\n* @private\n*/\nPIXI.Sprite.prototype._renderCanvas = function(renderSession)\n{\n    // If the sprite is not visible or the alpha is 0 then no need to render this element\n    if (this.visible === false || this.alpha === 0 || this.texture.crop.width <= 0 || this.texture.crop.height <= 0) return;\n\n    if (this.blendMode !== renderSession.currentBlendMode)\n    {\n        renderSession.currentBlendMode = this.blendMode;\n        renderSession.context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode];\n    }\n\n    if (this._mask)\n    {\n        renderSession.maskManager.pushMask(this._mask, renderSession);\n    }\n\n    //  Ignore null sources\n    if (this.texture.valid)\n    {\n        var resolution = this.texture.baseTexture.resolution / renderSession.resolution;\n\n        renderSession.context.globalAlpha = this.worldAlpha;\n\n        //  Allow for pixel rounding\n        if (renderSession.roundPixels)\n        {\n            renderSession.context.setTransform(\n                this.worldTransform.a,\n                this.worldTransform.b,\n                this.worldTransform.c,\n                this.worldTransform.d,\n                (this.worldTransform.tx* renderSession.resolution) | 0,\n                (this.worldTransform.ty* renderSession.resolution) | 0);\n        }\n        else\n        {\n            renderSession.context.setTransform(\n                this.worldTransform.a,\n                this.worldTransform.b,\n                this.worldTransform.c,\n                this.worldTransform.d,\n                this.worldTransform.tx * renderSession.resolution,\n                this.worldTransform.ty * renderSession.resolution);\n        }\n\n        //  If smoothingEnabled is supported and we need to change the smoothing property for this texture\n        if (renderSession.smoothProperty && renderSession.scaleMode !== this.texture.baseTexture.scaleMode)\n        {\n            renderSession.scaleMode = this.texture.baseTexture.scaleMode;\n            renderSession.context[renderSession.smoothProperty] = (renderSession.scaleMode === PIXI.scaleModes.LINEAR);\n        }\n\n        //  If the texture is trimmed we offset by the trim x/y, otherwise we use the frame dimensions\n        var dx = (this.texture.trim) ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width;\n        var dy = (this.texture.trim) ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height;\n\n        if (this.tint !== 0xFFFFFF)\n        {\n            if (this.cachedTint !== this.tint)\n            {\n                this.cachedTint = this.tint;\n\n                //  TODO clean up caching - how to clean up the caches?\n                this.tintedTexture = PIXI.CanvasTinter.getTintedTexture(this, this.tint);\n            }\n\n            renderSession.context.drawImage(\n                                this.tintedTexture,\n                                0,\n                                0,\n                                this.texture.crop.width,\n                                this.texture.crop.height,\n                                dx / resolution,\n                                dy / resolution,\n                                this.texture.crop.width / resolution,\n                                this.texture.crop.height / resolution);\n        }\n        else\n        {\n            renderSession.context.drawImage(\n                                this.texture.baseTexture.source,\n                                this.texture.crop.x,\n                                this.texture.crop.y,\n                                this.texture.crop.width,\n                                this.texture.crop.height,\n                                dx / resolution,\n                                dy / resolution,\n                                this.texture.crop.width / resolution,\n                                this.texture.crop.height / resolution);\n        }\n    }\n\n    // OVERWRITE\n    for (var i = 0, j = this.children.length; i < j; i++)\n    {\n        this.children[i]._renderCanvas(renderSession);\n    }\n\n    if (this._mask)\n    {\n        renderSession.maskManager.popMask(renderSession);\n    }\n};\n\n// some helper functions..\n\n/**\n *\n * Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId\n * The frame ids are created when a Texture packer file has been loaded\n *\n * @method fromFrame\n * @static\n * @param frameId {String} The frame Id of the texture in the cache\n * @return {Sprite} A new Sprite using a texture from the texture cache matching the frameId\n */\nPIXI.Sprite.fromFrame = function(frameId)\n{\n    var texture = PIXI.TextureCache[frameId];\n    if(!texture) throw new Error('The frameId \"' + frameId + '\" does not exist in the texture cache' + this);\n    return new PIXI.Sprite(texture);\n};\n\n/**\n *\n * Helper function that creates a sprite that will contain a texture based on an image url\n * If the image is not in the texture cache it will be loaded\n *\n * @method fromImage\n * @static\n * @param imageId {String} The image url of the texture\n * @return {Sprite} A new Sprite using a texture from the texture cache matching the image id\n */\nPIXI.Sprite.fromImage = function(imageId, crossorigin, scaleMode)\n{\n    var texture = PIXI.Texture.fromImage(imageId, crossorigin, scaleMode);\n    return new PIXI.Sprite(texture);\n};\n\n/**\n * @author Mat Groves http://matgroves.com/\n */\n\n/**\n * The SpriteBatch class is a really fast version of the DisplayObjectContainer \n * built solely for speed, so use when you need a lot of sprites or particles.\n * And it's extremely easy to use : \n\n    var container = new PIXI.SpriteBatch();\n \n    stage.addChild(container);\n \n    for(var i  = 0; i < 100; i++)\n    {\n        var sprite = new PIXI.Sprite.fromImage(\"myImage.png\");\n        container.addChild(sprite);\n    }\n * And here you have a hundred sprites that will be renderer at the speed of light\n *\n * @class SpriteBatch\n * @constructor\n * @param texture {Texture}\n */\n\n//TODO RENAME to PARTICLE CONTAINER?\nPIXI.SpriteBatch = function(texture)\n{\n    PIXI.DisplayObjectContainer.call( this);\n\n    this.textureThing = texture;\n\n    this.ready = false;\n};\n\nPIXI.SpriteBatch.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);\nPIXI.SpriteBatch.prototype.constructor = PIXI.SpriteBatch;\n\n/*\n * Initialises the spriteBatch\n *\n * @method initWebGL\n * @param gl {WebGLContext} the current WebGL drawing context\n */\nPIXI.SpriteBatch.prototype.initWebGL = function(gl)\n{\n    // TODO only one needed for the whole engine really?\n    this.fastSpriteBatch = new PIXI.WebGLFastSpriteBatch(gl);\n\n    this.ready = true;\n};\n\n/*\n * Updates the object transform for rendering\n *\n * @method updateTransform\n * @private\n */\nPIXI.SpriteBatch.prototype.updateTransform = function()\n{\n    // TODO don't need to!\n    PIXI.DisplayObject.prototype.updateTransform.call( this );\n    //  PIXI.DisplayObjectContainer.prototype.updateTransform.call( this );\n};\n\n/**\n* Renders the object using the WebGL renderer\n*\n* @method _renderWebGL\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.SpriteBatch.prototype._renderWebGL = function(renderSession)\n{\n    if(!this.visible || this.alpha <= 0 || !this.children.length)return;\n\n    if(!this.ready)this.initWebGL( renderSession.gl );\n    \n    renderSession.spriteBatch.stop();\n    \n    renderSession.shaderManager.setShader(renderSession.shaderManager.fastShader);\n    \n    this.fastSpriteBatch.begin(this, renderSession);\n    this.fastSpriteBatch.render(this);\n\n    renderSession.spriteBatch.start();\n \n};\n\n/**\n* Renders the object using the Canvas renderer\n*\n* @method _renderCanvas\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.SpriteBatch.prototype._renderCanvas = function(renderSession)\n{\n    if(!this.visible || this.alpha <= 0 || !this.children.length)return;\n    \n    var context = renderSession.context;\n    context.globalAlpha = this.worldAlpha;\n\n    PIXI.DisplayObject.prototype.updateTransform.call(this);\n\n    var transform = this.worldTransform;\n    // alow for trimming\n       \n    var isRotated = true;\n\n    for (var i = 0; i < this.children.length; i++) {\n       \n        var child = this.children[i];\n\n        if(!child.visible)continue;\n\n        var texture = child.texture;\n        var frame = texture.frame;\n\n        context.globalAlpha = this.worldAlpha * child.alpha;\n\n        if(child.rotation % (Math.PI * 2) === 0)\n        {\n            if(isRotated)\n            {\n                context.setTransform(transform.a, transform.b, transform.c, transform.d, transform.tx, transform.ty);\n                isRotated = false;\n            }\n\n            // this is the fastest  way to optimise! - if rotation is 0 then we can avoid any kind of setTransform call\n            context.drawImage(texture.baseTexture.source,\n                                 frame.x,\n                                 frame.y,\n                                 frame.width,\n                                 frame.height,\n                                 ((child.anchor.x) * (-frame.width * child.scale.x) + child.position.x  + 0.5) | 0,\n                                 ((child.anchor.y) * (-frame.height * child.scale.y) + child.position.y  + 0.5) | 0,\n                                 frame.width * child.scale.x,\n                                 frame.height * child.scale.y);\n        }\n        else\n        {\n            if(!isRotated)isRotated = true;\n    \n            PIXI.DisplayObject.prototype.updateTransform.call(child);\n           \n            var childTransform = child.worldTransform;\n\n            // allow for trimming\n           \n            if (renderSession.roundPixels)\n            {\n                context.setTransform(childTransform.a, childTransform.b, childTransform.c, childTransform.d, childTransform.tx | 0, childTransform.ty | 0);\n            }\n            else\n            {\n                context.setTransform(childTransform.a, childTransform.b, childTransform.c, childTransform.d, childTransform.tx, childTransform.ty);\n            }\n\n            context.drawImage(texture.baseTexture.source,\n                                 frame.x,\n                                 frame.y,\n                                 frame.width,\n                                 frame.height,\n                                 ((child.anchor.x) * (-frame.width) + 0.5) | 0,\n                                 ((child.anchor.y) * (-frame.height) + 0.5) | 0,\n                                 frame.width,\n                                 frame.height);\n           \n\n        }\n\n       // context.restore();\n    }\n\n//    context.restore();\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * A MovieClip is a simple way to display an animation depicted by a list of textures.\n *\n * @class MovieClip\n * @extends Sprite\n * @constructor\n * @param textures {Array<Texture>} an array of {Texture} objects that make up the animation\n */\nPIXI.MovieClip = function(textures)\n{\n    PIXI.Sprite.call(this, textures[0]);\n\n    /**\n     * The array of textures that make up the animation\n     *\n     * @property textures\n     * @type Array\n     */\n    this.textures = textures;\n\n    /**\n     * The speed that the MovieClip will play at. Higher is faster, lower is slower\n     *\n     * @property animationSpeed\n     * @type Number\n     * @default 1\n     */\n    this.animationSpeed = 1;\n\n    /**\n     * Whether or not the movie clip repeats after playing.\n     *\n     * @property loop\n     * @type Boolean\n     * @default true\n     */\n    this.loop = true;\n\n    /**\n     * Function to call when a MovieClip finishes playing\n     *\n     * @property onComplete\n     * @type Function\n     */\n    this.onComplete = null;\n\n    /**\n     * [read-only] The MovieClips current frame index (this may not have to be a whole number)\n     *\n     * @property currentFrame\n     * @type Number\n     * @default 0\n     * @readOnly\n     */\n    this.currentFrame = 0;\n\n    /**\n     * [read-only] Indicates if the MovieClip is currently playing\n     *\n     * @property playing\n     * @type Boolean\n     * @readOnly\n     */\n    this.playing = false;\n};\n\n// constructor\nPIXI.MovieClip.prototype = Object.create( PIXI.Sprite.prototype );\nPIXI.MovieClip.prototype.constructor = PIXI.MovieClip;\n\n/**\n* [read-only] totalFrames is the total number of frames in the MovieClip. This is the same as number of textures\n* assigned to the MovieClip.\n*\n* @property totalFrames\n* @type Number\n* @default 0\n* @readOnly\n*/\nObject.defineProperty( PIXI.MovieClip.prototype, 'totalFrames', {\n	get: function() {\n\n		return this.textures.length;\n	}\n});\n\n/**\n * Stops the MovieClip\n *\n * @method stop\n */\nPIXI.MovieClip.prototype.stop = function()\n{\n    this.playing = false;\n};\n\n/**\n * Plays the MovieClip\n *\n * @method play\n */\nPIXI.MovieClip.prototype.play = function()\n{\n    this.playing = true;\n};\n\n/**\n * Stops the MovieClip and goes to a specific frame\n *\n * @method gotoAndStop\n * @param frameNumber {Number} frame index to stop at\n */\nPIXI.MovieClip.prototype.gotoAndStop = function(frameNumber)\n{\n    this.playing = false;\n    this.currentFrame = frameNumber;\n    var round = (this.currentFrame + 0.5) | 0;\n    this.setTexture(this.textures[round % this.textures.length]);\n};\n\n/**\n * Goes to a specific frame and begins playing the MovieClip\n *\n * @method gotoAndPlay\n * @param frameNumber {Number} frame index to start at\n */\nPIXI.MovieClip.prototype.gotoAndPlay = function(frameNumber)\n{\n    this.currentFrame = frameNumber;\n    this.playing = true;\n};\n\n/*\n * Updates the object transform for rendering\n *\n * @method updateTransform\n * @private\n */\nPIXI.MovieClip.prototype.updateTransform = function()\n{\n    PIXI.Sprite.prototype.updateTransform.call(this);\n\n    if(!this.playing)return;\n\n    this.currentFrame += this.animationSpeed;\n\n    var round = (this.currentFrame + 0.5) | 0;\n\n    this.currentFrame = this.currentFrame % this.textures.length;\n\n    if(this.loop || round < this.textures.length)\n    {\n        this.setTexture(this.textures[round % this.textures.length]);\n    }\n    else if(round >= this.textures.length)\n    {\n        this.gotoAndStop(this.textures.length - 1);\n        if(this.onComplete)\n        {\n            this.onComplete();\n        }\n    }\n};\n\n/**\n * A short hand way of creating a movieclip from an array of frame ids\n *\n * @static\n * @method fromFrames\n * @param frames {Array} the array of frames ids the movieclip will use as its texture frames\n */\nPIXI.MovieClip.fromFrames = function(frames)\n{\n    var textures = [];\n\n    for (var i = 0; i < frames.length; i++)\n    {\n        textures.push(new PIXI.Texture.fromFrame(frames[i]));\n    }\n\n    return new PIXI.MovieClip(textures);\n};\n\n/**\n * A short hand way of creating a movieclip from an array of image ids\n *\n * @static\n * @method fromImages\n * @param frames {Array} the array of image ids the movieclip will use as its texture frames\n */\nPIXI.MovieClip.fromImages = function(images)\n{\n    var textures = [];\n\n    for (var i = 0; i < images.length; i++)\n    {\n        textures.push(new PIXI.Texture.fromImage(images[i]));\n    }\n\n    return new PIXI.MovieClip(textures);\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * A target and pass info object for filters.\n * \n * @class FilterBlock\n * @constructor\n */\nPIXI.FilterBlock = function()\n{\n    /**\n     * The visible state of this FilterBlock.\n     *\n     * @property visible\n     * @type Boolean\n     */\n    this.visible = true;\n\n    /**\n     * The renderable state of this FilterBlock.\n     *\n     * @property renderable\n     * @type Boolean\n     */\n    this.renderable = true;\n};\n\nPIXI.FilterBlock.prototype.constructor = PIXI.FilterBlock;\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n * Modified by Tom Slezakowski http://www.tomslezakowski.com @TomSlezakowski (24/03/2014) - Added dropShadowColor.\n */\n\n/**\n * A Text Object will create a line or multiple lines of text. To split a line you can use '\\n' in your text string,\n * or add a wordWrap property set to true and and wordWrapWidth property with a value in the style object.\n *\n * @class Text\n * @extends Sprite\n * @constructor\n * @param text {String} The copy that you would like the text to display\n * @param [style] {Object} The style parameters\n * @param [style.font] {String} default 'bold 20px Arial' The style and size of the font\n * @param [style.fill='black'] {String|Number} A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'\n * @param [style.align='left'] {String} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text\n * @param [style.stroke] {String|Number} A canvas fillstyle that will be used on the text stroke e.g 'blue', '#FCFF00'\n * @param [style.strokeThickness=0] {Number} A number that represents the thickness of the stroke. Default is 0 (no stroke)\n * @param [style.wordWrap=false] {Boolean} Indicates if word wrap should be used\n * @param [style.wordWrapWidth=100] {Number} The width at which text will wrap, it needs wordWrap to be set to true\n * @param [style.dropShadow=false] {Boolean} Set a drop shadow for the text\n * @param [style.dropShadowColor='#000000'] {String} A fill style to be used on the dropshadow e.g 'red', '#00FF00'\n * @param [style.dropShadowAngle=Math.PI/4] {Number} Set a angle of the drop shadow\n * @param [style.dropShadowDistance=5] {Number} Set a distance of the drop shadow\n */\nPIXI.Text = function(text, style)\n{\n    /**\n     * The canvas element that everything is drawn to\n     *\n     * @property canvas\n     * @type HTMLCanvasElement\n     */\n    this.canvas = document.createElement('canvas');\n\n    /**\n     * The canvas 2d context that everything is drawn with\n     * @property context\n     * @type HTMLCanvasElement\n     */\n    this.context = this.canvas.getContext('2d');\n\n    /**\n     * The resolution of the canvas.\n     * @property resolution\n     * @type Number\n     */\n    this.resolution = 1;\n\n    PIXI.Sprite.call(this, PIXI.Texture.fromCanvas(this.canvas));\n\n    this.setText(text);\n    this.setStyle(style);\n\n};\n\n// constructor\nPIXI.Text.prototype = Object.create(PIXI.Sprite.prototype);\nPIXI.Text.prototype.constructor = PIXI.Text;\n\n/**\n * The width of the Text, setting this will actually modify the scale to achieve the value set\n *\n * @property width\n * @type Number\n */\nObject.defineProperty(PIXI.Text.prototype, 'width', {\n    get: function() {\n\n        if(this.dirty)\n        {\n            this.updateText();\n            this.dirty = false;\n        }\n\n\n        return this.scale.x * this.texture.frame.width;\n    },\n    set: function(value) {\n        this.scale.x = value / this.texture.frame.width;\n        this._width = value;\n    }\n});\n\n/**\n * The height of the Text, setting this will actually modify the scale to achieve the value set\n *\n * @property height\n * @type Number\n */\nObject.defineProperty(PIXI.Text.prototype, 'height', {\n    get: function() {\n\n        if(this.dirty)\n        {\n            this.updateText();\n            this.dirty = false;\n        }\n\n\n        return  this.scale.y * this.texture.frame.height;\n    },\n    set: function(value) {\n        this.scale.y = value / this.texture.frame.height;\n        this._height = value;\n    }\n});\n\n/**\n * Set the style of the text\n *\n * @method setStyle\n * @param [style] {Object} The style parameters\n * @param [style.font='bold 20pt Arial'] {String} The style and size of the font\n * @param [style.fill='black'] {Object} A canvas fillstyle that will be used on the text eg 'red', '#00FF00'\n * @param [style.align='left'] {String} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text\n * @param [style.stroke='black'] {String} A canvas fillstyle that will be used on the text stroke eg 'blue', '#FCFF00'\n * @param [style.strokeThickness=0] {Number} A number that represents the thickness of the stroke. Default is 0 (no stroke)\n * @param [style.wordWrap=false] {Boolean} Indicates if word wrap should be used\n * @param [style.wordWrapWidth=100] {Number} The width at which text will wrap\n * @param [style.dropShadow=false] {Boolean} Set a drop shadow for the text\n * @param [style.dropShadowColor='#000000'] {String} A fill style to be used on the dropshadow e.g 'red', '#00FF00'\n * @param [style.dropShadowAngle=Math.PI/4] {Number} Set a angle of the drop shadow\n * @param [style.dropShadowDistance=5] {Number} Set a distance of the drop shadow\n */\nPIXI.Text.prototype.setStyle = function(style)\n{\n    style = style || {};\n    style.font = style.font || 'bold 20pt Arial';\n    style.fill = style.fill || 'black';\n    style.align = style.align || 'left';\n    style.stroke = style.stroke || 'black'; //provide a default, see: https://github.com/GoodBoyDigital/pixi.js/issues/136\n    style.strokeThickness = style.strokeThickness || 0;\n    style.wordWrap = style.wordWrap || false;\n    style.wordWrapWidth = style.wordWrapWidth || 100;\n    \n    style.dropShadow = style.dropShadow || false;\n    style.dropShadowAngle = style.dropShadowAngle || Math.PI / 6;\n    style.dropShadowDistance = style.dropShadowDistance || 4;\n    style.dropShadowColor = style.dropShadowColor || 'black';\n\n    this.style = style;\n    this.dirty = true;\n};\n\n/**\n * Set the copy for the text object. To split a line you can use '\\n'.\n *\n * @method setText\n * @param text {String} The copy that you would like the text to display\n */\nPIXI.Text.prototype.setText = function(text)\n{\n    this.text = text.toString() || ' ';\n    this.dirty = true;\n};\n\n/**\n * Renders text and updates it when needed\n *\n * @method updateText\n * @private\n */\nPIXI.Text.prototype.updateText = function()\n{\n    this.texture.baseTexture.resolution = this.resolution;\n\n    this.context.font = this.style.font;\n\n    var outputText = this.text;\n\n    // word wrap\n    // preserve original text\n    if(this.style.wordWrap)outputText = this.wordWrap(this.text);\n\n    //split text into lines\n    var lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n\n    //calculate text width\n    var lineWidths = [];\n    var maxLineWidth = 0;\n    var fontProperties = this.determineFontProperties(this.style.font);\n    for (var i = 0; i < lines.length; i++)\n    {\n        var lineWidth = this.context.measureText(lines[i]).width;\n        lineWidths[i] = lineWidth;\n        maxLineWidth = Math.max(maxLineWidth, lineWidth);\n    }\n\n    var width = maxLineWidth + this.style.strokeThickness;\n    if(this.style.dropShadow)width += this.style.dropShadowDistance;\n\n    this.canvas.width = ( width + this.context.lineWidth ) * this.resolution;\n    \n    //calculate text height\n    var lineHeight = fontProperties.fontSize + this.style.strokeThickness;\n \n    var height = lineHeight * lines.length;\n    if(this.style.dropShadow)height += this.style.dropShadowDistance;\n\n    this.canvas.height = height * this.resolution;\n\n    this.context.scale( this.resolution, this.resolution);\n\n    if(navigator.isCocoonJS) this.context.clearRect(0,0,this.canvas.width,this.canvas.height);\n    \n    this.context.font = this.style.font;\n    this.context.strokeStyle = this.style.stroke;\n    this.context.lineWidth = this.style.strokeThickness;\n    this.context.textBaseline = 'alphabetic';\n    //this.context.lineJoin = 'round';\n\n    var linePositionX;\n    var linePositionY;\n\n    if(this.style.dropShadow)\n    {\n        this.context.fillStyle = this.style.dropShadowColor;\n\n        var xShadowOffset = Math.sin(this.style.dropShadowAngle) * this.style.dropShadowDistance;\n        var yShadowOffset = Math.cos(this.style.dropShadowAngle) * this.style.dropShadowDistance;\n\n        for (i = 0; i < lines.length; i++)\n        {\n            linePositionX = this.style.strokeThickness / 2;\n            linePositionY = (this.style.strokeThickness / 2 + i * lineHeight) + fontProperties.ascent;\n\n            if(this.style.align === 'right')\n            {\n                linePositionX += maxLineWidth - lineWidths[i];\n            }\n            else if(this.style.align === 'center')\n            {\n                linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n            }\n\n            if(this.style.fill)\n            {\n                this.context.fillText(lines[i], linePositionX + xShadowOffset, linePositionY + yShadowOffset);\n            }\n\n          //  if(dropShadow)\n        }\n    }\n\n    //set canvas text styles\n    this.context.fillStyle = this.style.fill;\n    \n    //draw lines line by line\n    for (i = 0; i < lines.length; i++)\n    {\n        linePositionX = this.style.strokeThickness / 2;\n        linePositionY = (this.style.strokeThickness / 2 + i * lineHeight) + fontProperties.ascent;\n\n        if(this.style.align === 'right')\n        {\n            linePositionX += maxLineWidth - lineWidths[i];\n        }\n        else if(this.style.align === 'center')\n        {\n            linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n        }\n\n        if(this.style.stroke && this.style.strokeThickness)\n        {\n            this.context.strokeText(lines[i], linePositionX, linePositionY);\n        }\n\n        if(this.style.fill)\n        {\n            this.context.fillText(lines[i], linePositionX, linePositionY);\n        }\n\n      //  if(dropShadow)\n    }\n\n    this.updateTexture();\n};\n\n/**\n * Updates texture size based on canvas size\n *\n * @method updateTexture\n * @private\n */\nPIXI.Text.prototype.updateTexture = function()\n{\n    this.texture.baseTexture.width = this.canvas.width;\n    this.texture.baseTexture.height = this.canvas.height;\n    this.texture.crop.width = this.texture.frame.width = this.canvas.width;\n    this.texture.crop.height = this.texture.frame.height = this.canvas.height;\n\n    this._width = this.canvas.width;\n    this._height = this.canvas.height;\n\n    // update the dirty base textures\n    this.texture.baseTexture.dirty();\n};\n\n/**\n* Renders the object using the WebGL renderer\n*\n* @method _renderWebGL\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.Text.prototype._renderWebGL = function(renderSession)\n{\n    if(this.dirty)\n    {\n        this.resolution = renderSession.resolution;\n\n        this.updateText();\n        this.dirty = false;\n    }\n\n    PIXI.Sprite.prototype._renderWebGL.call(this, renderSession);\n};\n\n/**\n* Renders the object using the Canvas renderer\n*\n* @method _renderCanvas\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.Text.prototype._renderCanvas = function(renderSession)\n{\n    if(this.dirty)\n    {\n        this.resolution = renderSession.resolution;\n\n        this.updateText();\n        this.dirty = false;\n    }\n     \n    PIXI.Sprite.prototype._renderCanvas.call(this, renderSession);\n};\n\n/**\n* Calculates the ascent, descent and fontSize of a given fontStyle\n*\n* @method determineFontProperties\n* @param fontStyle {Object}\n* @private\n*/\nPIXI.Text.prototype.determineFontProperties = function(fontStyle)\n{\n    var properties = PIXI.Text.fontPropertiesCache[fontStyle];\n\n    if(!properties)\n    {\n        properties = {};\n        \n        var canvas = PIXI.Text.fontPropertiesCanvas;\n        var context = PIXI.Text.fontPropertiesContext;\n\n        context.font = fontStyle;\n\n        var width = Math.ceil(context.measureText('|Mq').width);\n        var baseline = Math.ceil(context.measureText('M').width);\n        var height = 2 * baseline;\n\n        baseline = baseline * 1.4 | 0;\n\n        canvas.width = width;\n        canvas.height = height;\n\n        context.fillStyle = '#f00';\n        context.fillRect(0, 0, width, height);\n\n        context.font = fontStyle;\n\n        context.textBaseline = 'alphabetic';\n        context.fillStyle = '#000';\n        context.fillText('|Mq', 0, baseline);\n\n        var imagedata = context.getImageData(0, 0, width, height).data;\n        var pixels = imagedata.length;\n        var line = width * 4;\n\n        var i, j;\n\n        var idx = 0;\n        var stop = false;\n\n        // ascent. scan from top to bottom until we find a non red pixel\n        for(i = 0; i < baseline; i++)\n        {\n            for(j = 0; j < line; j += 4)\n            {\n                if(imagedata[idx + j] !== 255)\n                {\n                    stop = true;\n                    break;\n                }\n            }\n            if(!stop)\n            {\n                idx += line;\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        properties.ascent = baseline - i;\n\n        idx = pixels - line;\n        stop = false;\n\n        // descent. scan from bottom to top until we find a non red pixel\n        for(i = height; i > baseline; i--)\n        {\n            for(j = 0; j < line; j += 4)\n            {\n                if(imagedata[idx + j] !== 255)\n                {\n                    stop = true;\n                    break;\n                }\n            }\n            if(!stop)\n            {\n                idx -= line;\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        properties.descent = i - baseline;\n        properties.fontSize = properties.ascent + properties.descent;\n\n        PIXI.Text.fontPropertiesCache[fontStyle] = properties;\n    }\n\n    return properties;\n};\n\n/**\n * Applies newlines to a string to have it optimally fit into the horizontal\n * bounds set by the Text object's wordWrapWidth property.\n *\n * @method wordWrap\n * @param text {String}\n * @private\n */\nPIXI.Text.prototype.wordWrap = function(text)\n{\n    // Greedy wrapping algorithm that will wrap words as the line grows longer\n    // than its horizontal bounds.\n    var result = '';\n    var lines = text.split('\\n');\n    for (var i = 0; i < lines.length; i++)\n    {\n        var spaceLeft = this.style.wordWrapWidth;\n        var words = lines[i].split(' ');\n        for (var j = 0; j < words.length; j++)\n        {\n            var wordWidth = this.context.measureText(words[j]).width;\n            var wordWidthWithSpace = wordWidth + this.context.measureText(' ').width;\n            if(j === 0 || wordWidthWithSpace > spaceLeft)\n            {\n                // Skip printing the newline if it's the first word of the line that is\n                // greater than the word wrap width.\n                if(j > 0)\n                {\n                    result += '\\n';\n                }\n                result += words[j];\n                spaceLeft = this.style.wordWrapWidth - wordWidth;\n            }\n            else\n            {\n                spaceLeft -= wordWidthWithSpace;\n                result += ' ' + words[j];\n            }\n        }\n\n        if (i < lines.length-1)\n        {\n            result += '\\n';\n        }\n    }\n    return result;\n};\n\n/**\n* Returns the bounds of the Text as a rectangle. The bounds calculation takes the worldTransform into account.\n*\n* @method getBounds\n* @param matrix {Matrix} the transformation matrix of the Text\n* @return {Rectangle} the framing rectangle\n*/\nPIXI.Text.prototype.getBounds = function(matrix)\n{\n    if(this.dirty)\n    {\n        this.updateText();\n        this.dirty = false;\n    }\n\n    return PIXI.Sprite.prototype.getBounds.call(this, matrix);\n};\n\n/**\n * Destroys this text object.\n *\n * @method destroy\n * @param destroyBaseTexture {Boolean} whether to destroy the base texture as well\n */\nPIXI.Text.prototype.destroy = function(destroyBaseTexture)\n{\n    // make sure to reset the the context and canvas.. dont want this hanging around in memory!\n    this.context = null;\n    this.canvas = null;\n\n    this.texture.destroy(destroyBaseTexture === undefined ? true : destroyBaseTexture);\n};\n\nPIXI.Text.fontPropertiesCache = {};\nPIXI.Text.fontPropertiesCanvas = document.createElement('canvas');\nPIXI.Text.fontPropertiesContext = PIXI.Text.fontPropertiesCanvas.getContext('2d');\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * A BitmapText object will create a line or multiple lines of text using bitmap font. To split a line you can use '\\n', '\\r' or '\\r\\n' in your string.\n * You can generate the fnt files using\n * http://www.angelcode.com/products/bmfont/ for windows or\n * http://www.bmglyph.com/ for mac.\n *\n * @class BitmapText\n * @extends DisplayObjectContainer\n * @constructor\n * @param text {String} The copy that you would like the text to display\n * @param style {Object} The style parameters\n * @param style.font {String} The size (optional) and bitmap font id (required) eq 'Arial' or '20px Arial' (must have loaded previously)\n * @param [style.align='left'] {String} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text\n */\nPIXI.BitmapText = function(text, style)\n{\n    PIXI.DisplayObjectContainer.call(this);\n\n    /**\n     * [read-only] The width of the overall text, different from fontSize,\n     * which is defined in the style object\n     *\n     * @property textWidth\n     * @type Number\n     * @readOnly\n     */\n    this.textWidth = 0;\n\n    /**\n     * [read-only] The height of the overall text, different from fontSize,\n     * which is defined in the style object\n     *\n     * @property textHeight\n     * @type Number\n     * @readOnly\n     */\n    this.textHeight = 0;\n\n    /**\n     * @property _pool\n     * @type Array\n     * @private\n     */\n    this._pool = [];\n\n    this.setText(text);\n    this.setStyle(style);\n    this.updateText();\n\n    /**\n     * The dirty state of this object.\n     * @property dirty\n     * @type Boolean\n     */\n    this.dirty = false;\n};\n\n// constructor\nPIXI.BitmapText.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);\nPIXI.BitmapText.prototype.constructor = PIXI.BitmapText;\n\n/**\n * Set the text string to be rendered.\n *\n * @method setText\n * @param text {String} The text that you would like displayed\n */\nPIXI.BitmapText.prototype.setText = function(text)\n{\n    this.text = text || ' ';\n    this.dirty = true;\n};\n\n/**\n * Set the style of the text\n * style.font {String} The size (optional) and bitmap font id (required) eq 'Arial' or '20px Arial' (must have loaded previously)\n * [style.align='left'] {String} Alignment for multiline text ('left', 'center' or 'right'), does not affect single lines of text\n *\n * @method setStyle\n * @param style {Object} The style parameters, contained as properties of an object\n */\nPIXI.BitmapText.prototype.setStyle = function(style)\n{\n    style = style || {};\n    style.align = style.align || 'left';\n    this.style = style;\n\n    var font = style.font.split(' ');\n    this.fontName = font[font.length - 1];\n    this.fontSize = font.length >= 2 ? parseInt(font[font.length - 2], 10) : PIXI.BitmapText.fonts[this.fontName].size;\n\n    this.dirty = true;\n    this.tint = style.tint;\n};\n\n/**\n * Renders text and updates it when needed\n *\n * @method updateText\n * @private\n */\nPIXI.BitmapText.prototype.updateText = function()\n{\n    var data = PIXI.BitmapText.fonts[this.fontName];\n    var pos = new PIXI.Point();\n    var prevCharCode = null;\n    var chars = [];\n    var maxLineWidth = 0;\n    var lineWidths = [];\n    var line = 0;\n    var scale = this.fontSize / data.size;\n\n    for(var i = 0; i < this.text.length; i++)\n    {\n        var charCode = this.text.charCodeAt(i);\n\n        if(/(?:\\r\\n|\\r|\\n)/.test(this.text.charAt(i)))\n        {\n            lineWidths.push(pos.x);\n            maxLineWidth = Math.max(maxLineWidth, pos.x);\n            line++;\n\n            pos.x = 0;\n            pos.y += data.lineHeight;\n            prevCharCode = null;\n            continue;\n        }\n\n        var charData = data.chars[charCode];\n\n        if(!charData) continue;\n\n        if(prevCharCode && charData.kerning[prevCharCode])\n        {\n            pos.x += charData.kerning[prevCharCode];\n        }\n\n        chars.push({texture:charData.texture, line: line, charCode: charCode, position: new PIXI.Point(pos.x + charData.xOffset, pos.y + charData.yOffset)});\n        pos.x += charData.xAdvance;\n\n        prevCharCode = charCode;\n    }\n\n    lineWidths.push(pos.x);\n    maxLineWidth = Math.max(maxLineWidth, pos.x);\n\n    var lineAlignOffsets = [];\n\n    for(i = 0; i <= line; i++)\n    {\n        var alignOffset = 0;\n        if(this.style.align === 'right')\n        {\n            alignOffset = maxLineWidth - lineWidths[i];\n        }\n        else if(this.style.align === 'center')\n        {\n            alignOffset = (maxLineWidth - lineWidths[i]) / 2;\n        }\n        lineAlignOffsets.push(alignOffset);\n    }\n\n    var lenChildren = this.children.length;\n    var lenChars = chars.length;\n    var tint = this.tint || 0xFFFFFF;\n\n    for(i = 0; i < lenChars; i++)\n    {\n        var c = i < lenChildren ? this.children[i] : this._pool.pop(); // get old child if have. if not - take from pool.\n\n        if (c) c.setTexture(chars[i].texture); // check if got one before.\n        else c = new PIXI.Sprite(chars[i].texture); // if no create new one.\n\n        c.position.x = (chars[i].position.x + lineAlignOffsets[chars[i].line]) * scale;\n        c.position.y = chars[i].position.y * scale;\n        c.scale.x = c.scale.y = scale;\n        c.tint = tint;\n        if (!c.parent) this.addChild(c);\n    }\n\n    // remove unnecessary children.\n    // and put their into the pool.\n    while(this.children.length > lenChars)\n    {\n        var child = this.getChildAt(this.children.length - 1);\n        this._pool.push(child);\n        this.removeChild(child);\n    }\n\n    this.textWidth = maxLineWidth * scale;\n    this.textHeight = (pos.y + data.lineHeight) * scale;\n};\n\n/**\n * Updates the transform of this object\n *\n * @method updateTransform\n * @private\n */\nPIXI.BitmapText.prototype.updateTransform = function()\n{\n    if(this.dirty)\n    {\n        this.updateText();\n        this.dirty = false;\n    }\n\n    PIXI.DisplayObjectContainer.prototype.updateTransform.call(this);\n};\n\nPIXI.BitmapText.fonts = {};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * Holds all information related to an Interaction event\n *\n * @class InteractionData\n * @constructor\n */\nPIXI.InteractionData = function()\n{\n    /**\n     * This point stores the global coords of where the touch/mouse event happened\n     *\n     * @property global\n     * @type Point\n     */\n    this.global = new PIXI.Point();\n\n    /**\n     * The target Sprite that was interacted with\n     *\n     * @property target\n     * @type Sprite\n     */\n    this.target = null;\n\n    /**\n     * When passed to an event handler, this will be the original DOM Event that was captured\n     *\n     * @property originalEvent\n     * @type Event\n     */\n    this.originalEvent = null;\n};\n\n/**\n * This will return the local coordinates of the specified displayObject for this InteractionData\n *\n * @method getLocalPosition\n * @param displayObject {DisplayObject} The DisplayObject that you would like the local coords off\n * @param [point] {Point} A Point object in which to store the value, optional (otherwise will create a new point)\n * @return {Point} A point containing the coordinates of the InteractionData position relative to the DisplayObject\n */\nPIXI.InteractionData.prototype.getLocalPosition = function(displayObject, point)\n{\n    var worldTransform = displayObject.worldTransform;\n    var global = this.global;\n\n    // do a cheeky transform to get the mouse coords;\n    var a00 = worldTransform.a, a01 = worldTransform.c, a02 = worldTransform.tx,\n        a10 = worldTransform.b, a11 = worldTransform.d, a12 = worldTransform.ty,\n        id = 1 / (a00 * a11 + a01 * -a10);\n\n    point = point || new PIXI.Point();\n\n    point.x = a11 * id * global.x + -a01 * id * global.y + (a12 * a01 - a02 * a11) * id;\n    point.y = a00 * id * global.y + -a10 * id * global.x + (-a12 * a00 + a02 * a10) * id;\n\n    // set the mouse coords...\n    return point;\n};\n\n// constructor\nPIXI.InteractionData.prototype.constructor = PIXI.InteractionData;\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n /**\n * The interaction manager deals with mouse and touch events. Any DisplayObject can be interactive\n * if its interactive parameter is set to true\n * This manager also supports multitouch.\n *\n * @class InteractionManager\n * @constructor\n * @param stage {Stage} The stage to handle interactions\n */\nPIXI.InteractionManager = function(stage)\n{\n    /**\n     * A reference to the stage\n     *\n     * @property stage\n     * @type Stage\n     */\n    this.stage = stage;\n\n    /**\n     * The mouse data\n     *\n     * @property mouse\n     * @type InteractionData\n     */\n    this.mouse = new PIXI.InteractionData();\n\n    /**\n     * An object that stores current touches (InteractionData) by id reference\n     *\n     * @property touches\n     * @type Object\n     */\n    this.touches = {};\n\n    /**\n     * @property tempPoint\n     * @type Point\n     * @private\n     */\n    this.tempPoint = new PIXI.Point();\n\n    /**\n     * @property mouseoverEnabled\n     * @type Boolean\n     * @default\n     */\n    this.mouseoverEnabled = true;\n\n    /**\n     * Tiny little interactiveData pool !\n     *\n     * @property pool\n     * @type Array\n     */\n    this.pool = [];\n\n    /**\n     * An array containing all the iterative items from the our interactive tree\n     * @property interactiveItems\n     * @type Array\n     * @private\n     */\n    this.interactiveItems = [];\n\n    /**\n     * Our canvas\n     * @property interactionDOMElement\n     * @type HTMLCanvasElement\n     * @private\n     */\n    this.interactionDOMElement = null;\n\n    //this will make it so that you don't have to call bind all the time\n\n    /**\n     * @property onMouseMove\n     * @type Function\n     */\n    this.onMouseMove = this.onMouseMove.bind( this );\n\n    /**\n     * @property onMouseDown\n     * @type Function\n     */\n    this.onMouseDown = this.onMouseDown.bind(this);\n\n    /**\n     * @property onMouseOut\n     * @type Function\n     */\n    this.onMouseOut = this.onMouseOut.bind(this);\n\n    /**\n     * @property onMouseUp\n     * @type Function\n     */\n    this.onMouseUp = this.onMouseUp.bind(this);\n\n    /**\n     * @property onTouchStart\n     * @type Function\n     */\n    this.onTouchStart = this.onTouchStart.bind(this);\n\n    /**\n     * @property onTouchEnd\n     * @type Function\n     */\n    this.onTouchEnd = this.onTouchEnd.bind(this);\n\n    /**\n     * @property onTouchMove\n     * @type Function\n     */\n    this.onTouchMove = this.onTouchMove.bind(this);\n\n    /**\n     * @property last\n     * @type Number\n     */\n    this.last = 0;\n\n    /**\n     * The css style of the cursor that is being used\n     * @property currentCursorStyle\n     * @type String\n     */\n    this.currentCursorStyle = 'inherit';\n\n    /**\n     * Is set to true when the mouse is moved out of the canvas\n     * @property mouseOut\n     * @type Boolean\n     */\n    this.mouseOut = false;\n\n    /**\n     * @property resolution\n     * @type Number\n     */\n    this.resolution = 1;\n};\n\n// constructor\nPIXI.InteractionManager.prototype.constructor = PIXI.InteractionManager;\n\n/**\n * Collects an interactive sprite recursively to have their interactions managed\n *\n * @method collectInteractiveSprite\n * @param displayObject {DisplayObject} the displayObject to collect\n * @param iParent {DisplayObject} the display object's parent\n * @private\n */\nPIXI.InteractionManager.prototype.collectInteractiveSprite = function(displayObject, iParent)\n{\n    var children = displayObject.children;\n    var length = children.length;\n\n    // make an interaction tree... {item.__interactiveParent}\n    for (var i = length - 1; i >= 0; i--)\n    {\n        var child = children[i];\n\n        // push all interactive bits\n        if (child._interactive)\n        {\n            iParent.interactiveChildren = true;\n            //child.__iParent = iParent;\n            this.interactiveItems.push(child);\n\n            if (child.children.length > 0) {\n                this.collectInteractiveSprite(child, child);\n            }\n        }\n        else\n        {\n            child.__iParent = null;\n            if (child.children.length > 0)\n            {\n                this.collectInteractiveSprite(child, iParent);\n            }\n        }\n\n    }\n};\n\n/**\n * Sets the target for event delegation\n *\n * @method setTarget\n * @param target {WebGLRenderer|CanvasRenderer} the renderer to bind events to\n * @private\n */\nPIXI.InteractionManager.prototype.setTarget = function(target)\n{\n    this.target = target;\n    this.resolution = target.resolution;\n\n    // Check if the dom element has been set. If it has don't do anything.\n    if (this.interactionDOMElement !== null) return;\n\n    this.setTargetDomElement (target.view);\n};\n\n/**\n * Sets the DOM element which will receive mouse/touch events. This is useful for when you have other DOM\n * elements on top of the renderers Canvas element. With this you'll be able to delegate another DOM element\n * to receive those events\n *\n * @method setTargetDomElement\n * @param domElement {DOMElement} the DOM element which will receive mouse and touch events\n * @private\n */\nPIXI.InteractionManager.prototype.setTargetDomElement = function(domElement)\n{\n    this.removeEvents();\n\n    if (window.navigator.msPointerEnabled)\n    {\n        // time to remove some of that zoom in ja..\n        domElement.style['-ms-content-zooming'] = 'none';\n        domElement.style['-ms-touch-action'] = 'none';\n    }\n\n    this.interactionDOMElement = domElement;\n\n    domElement.addEventListener('mousemove',  this.onMouseMove, true);\n    domElement.addEventListener('mousedown',  this.onMouseDown, true);\n    domElement.addEventListener('mouseout',   this.onMouseOut, true);\n\n    // aint no multi touch just yet!\n    domElement.addEventListener('touchstart', this.onTouchStart, true);\n    domElement.addEventListener('touchend', this.onTouchEnd, true);\n    domElement.addEventListener('touchmove', this.onTouchMove, true);\n\n    window.addEventListener('mouseup',  this.onMouseUp, true);\n};\n\n/**\n * @method removeEvents\n * @private\n */\nPIXI.InteractionManager.prototype.removeEvents = function()\n{\n    if (!this.interactionDOMElement) return;\n\n    this.interactionDOMElement.style['-ms-content-zooming'] = '';\n    this.interactionDOMElement.style['-ms-touch-action'] = '';\n\n    this.interactionDOMElement.removeEventListener('mousemove',  this.onMouseMove, true);\n    this.interactionDOMElement.removeEventListener('mousedown',  this.onMouseDown, true);\n    this.interactionDOMElement.removeEventListener('mouseout',   this.onMouseOut, true);\n\n    // aint no multi touch just yet!\n    this.interactionDOMElement.removeEventListener('touchstart', this.onTouchStart, true);\n    this.interactionDOMElement.removeEventListener('touchend', this.onTouchEnd, true);\n    this.interactionDOMElement.removeEventListener('touchmove', this.onTouchMove, true);\n\n    this.interactionDOMElement = null;\n\n    window.removeEventListener('mouseup',  this.onMouseUp, true);\n};\n\n/**\n * updates the state of interactive objects\n *\n * @method update\n * @private\n */\nPIXI.InteractionManager.prototype.update = function()\n{\n    if (!this.target) return;\n\n    // frequency of 30fps??\n    var now = Date.now();\n    var diff = now - this.last;\n    diff = (diff * PIXI.INTERACTION_FREQUENCY ) / 1000;\n    if (diff < 1) return;\n    this.last = now;\n\n    var i = 0;\n\n    // ok.. so mouse events??\n    // yes for now :)\n    // OPTIMISE - how often to check??\n    if (this.dirty)\n    {\n        this.rebuildInteractiveGraph();\n    }\n\n    // loop through interactive objects!\n    var length = this.interactiveItems.length;\n    var cursor = 'inherit';\n    var over = false;\n\n    for (i = 0; i < length; i++)\n    {\n        var item = this.interactiveItems[i];\n\n        // OPTIMISATION - only calculate every time if the mousemove function exists..\n        // OK so.. does the object have any other interactive functions?\n        // hit-test the clip!\n       // if (item.mouseover || item.mouseout || item.buttonMode)\n       // {\n        // ok so there are some functions so lets hit test it..\n        item.__hit = this.hitTest(item, this.mouse);\n        this.mouse.target = item;\n        // ok so deal with interactions..\n        // looks like there was a hit!\n        if (item.__hit && !over)\n        {\n            if (item.buttonMode) cursor = item.defaultCursor;\n\n            if (!item.interactiveChildren)\n            {\n                over = true;\n            }\n\n            if (!item.__isOver)\n            {\n                if (item.mouseover)\n                {\n                    item.mouseover (this.mouse);\n                }\n                item.__isOver = true;\n            }\n        }\n        else\n        {\n            if (item.__isOver)\n            {\n                // roll out!\n                if (item.mouseout)\n                {\n                    item.mouseout (this.mouse);\n                }\n                item.__isOver = false;\n            }\n        }\n    }\n\n    if (this.currentCursorStyle !== cursor)\n    {\n        this.currentCursorStyle = cursor;\n        this.interactionDOMElement.style.cursor = cursor;\n    }\n};\n\n/**\n * @method rebuildInteractiveGraph\n * @private\n */\nPIXI.InteractionManager.prototype.rebuildInteractiveGraph = function()\n{\n    this.dirty = false;\n\n    var len = this.interactiveItems.length;\n\n    for (var i = 0; i < len; i++) {\n        this.interactiveItems[i].interactiveChildren = false;\n    }\n\n    this.interactiveItems = [];\n\n    if (this.stage.interactive)\n    {\n        this.interactiveItems.push(this.stage);\n    }\n\n    // Go through and collect all the objects that are interactive..\n    this.collectInteractiveSprite(this.stage, this.stage);\n};\n\n/**\n * Is called when the mouse moves across the renderer element\n *\n * @method onMouseMove\n * @param event {Event} The DOM event of the mouse moving\n * @private\n */\nPIXI.InteractionManager.prototype.onMouseMove = function(event)\n{\n    if (this.dirty)\n    {\n        this.rebuildInteractiveGraph();\n    }\n\n    this.mouse.originalEvent = event;\n\n    // TODO optimize by not check EVERY TIME! maybe half as often? //\n    var rect = this.interactionDOMElement.getBoundingClientRect();\n\n    this.mouse.global.x = (event.clientX - rect.left) * (this.target.width / rect.width) / this.resolution;\n    this.mouse.global.y = (event.clientY - rect.top) * ( this.target.height / rect.height) / this.resolution;\n\n    var length = this.interactiveItems.length;\n\n    for (var i = 0; i < length; i++)\n    {\n        var item = this.interactiveItems[i];\n\n        // Call the function!\n        if (item.mousemove)\n        {\n            item.mousemove(this.mouse);\n        }\n    }\n};\n\n/**\n * Is called when the mouse button is pressed down on the renderer element\n *\n * @method onMouseDown\n * @param event {Event} The DOM event of a mouse button being pressed down\n * @private\n */\nPIXI.InteractionManager.prototype.onMouseDown = function(event)\n{\n    if (this.dirty)\n    {\n        this.rebuildInteractiveGraph();\n    }\n\n    this.mouse.originalEvent = event;\n\n    if (PIXI.AUTO_PREVENT_DEFAULT)\n    {\n        this.mouse.originalEvent.preventDefault();\n    }\n\n    // loop through interaction tree...\n    // hit test each item! ->\n    // get interactive items under point??\n    //stage.__i\n    var length = this.interactiveItems.length;\n\n    var e = this.mouse.originalEvent;\n    var isRightButton = e.button === 2 || e.which === 3;\n    var downFunction = isRightButton ? 'rightdown' : 'mousedown';\n    var clickFunction = isRightButton ? 'rightclick' : 'click';\n    var buttonIsDown = isRightButton ? '__rightIsDown' : '__mouseIsDown';\n    var isDown = isRightButton ? '__isRightDown' : '__isDown';\n\n    // while\n    // hit test\n    for (var i = 0; i < length; i++)\n    {\n        var item = this.interactiveItems[i];\n\n        if (item[downFunction] || item[clickFunction])\n        {\n            item[buttonIsDown] = true;\n            item.__hit = this.hitTest(item, this.mouse);\n\n            if (item.__hit)\n            {\n                //call the function!\n                if (item[downFunction])\n                {\n                    item[downFunction](this.mouse);\n                }\n                item[isDown] = true;\n\n                // just the one!\n                if (!item.interactiveChildren) break;\n            }\n        }\n    }\n};\n\n/**\n * Is called when the mouse is moved out of the renderer element\n *\n * @method onMouseOut\n * @param event {Event} The DOM event of a mouse being moved out\n * @private\n */\nPIXI.InteractionManager.prototype.onMouseOut = function(event)\n{\n    if (this.dirty)\n    {\n        this.rebuildInteractiveGraph();\n    }\n\n    this.mouse.originalEvent = event;\n\n    var length = this.interactiveItems.length;\n\n    this.interactionDOMElement.style.cursor = 'inherit';\n\n    for (var i = 0; i < length; i++)\n    {\n        var item = this.interactiveItems[i];\n        if (item.__isOver)\n        {\n            this.mouse.target = item;\n            if (item.mouseout)\n            {\n                item.mouseout(this.mouse);\n            }\n            item.__isOver = false;\n        }\n    }\n\n    this.mouseOut = true;\n\n    // move the mouse to an impossible position\n    this.mouse.global.x = -10000;\n    this.mouse.global.y = -10000;\n};\n\n/**\n * Is called when the mouse button is released on the renderer element\n *\n * @method onMouseUp\n * @param event {Event} The DOM event of a mouse button being released\n * @private\n */\nPIXI.InteractionManager.prototype.onMouseUp = function(event)\n{\n    if (this.dirty)\n    {\n        this.rebuildInteractiveGraph();\n    }\n\n    this.mouse.originalEvent = event;\n\n    var length = this.interactiveItems.length;\n    var up = false;\n\n    var e = this.mouse.originalEvent;\n    var isRightButton = e.button === 2 || e.which === 3;\n\n    var upFunction = isRightButton ? 'rightup' : 'mouseup';\n    var clickFunction = isRightButton ? 'rightclick' : 'click';\n    var upOutsideFunction = isRightButton ? 'rightupoutside' : 'mouseupoutside';\n    var isDown = isRightButton ? '__isRightDown' : '__isDown';\n\n    for (var i = 0; i < length; i++)\n    {\n        var item = this.interactiveItems[i];\n\n        if (item[clickFunction] || item[upFunction] || item[upOutsideFunction])\n        {\n            item.__hit = this.hitTest(item, this.mouse);\n\n            if (item.__hit && !up)\n            {\n                //call the function!\n                if (item[upFunction])\n                {\n                    item[upFunction](this.mouse);\n                }\n                if (item[isDown])\n                {\n                    if (item[clickFunction])\n                    {\n                        item[clickFunction](this.mouse);\n                    }\n                }\n\n                if (!item.interactiveChildren)\n                {\n                    up = true;\n                }\n            }\n            else\n            {\n                if (item[isDown])\n                {\n                    if (item[upOutsideFunction]) item[upOutsideFunction](this.mouse);\n                }\n            }\n\n            item[isDown] = false;\n        }\n    }\n};\n\n/**\n * Tests if the current mouse coordinates hit a sprite\n *\n * @method hitTest\n * @param item {DisplayObject} The displayObject to test for a hit\n * @param interactionData {InteractionData} The interactionData object to update in the case there is a hit\n * @private\n */\nPIXI.InteractionManager.prototype.hitTest = function(item, interactionData)\n{\n    var global = interactionData.global;\n\n    if (!item.worldVisible)\n    {\n        return false;\n    }\n\n    // temp fix for if the element is in a non visible\n\n    var worldTransform = item.worldTransform, i,\n        a = worldTransform.a, b = worldTransform.b,\n        c = worldTransform.c, tx = worldTransform.tx,\n        d = worldTransform.d, ty = worldTransform.ty,\n     \n        id = 1 / (a * d + c * -b),\n        x = d * id * global.x + -c * id * global.y + (ty * c - tx * d) * id,\n        y = a * id * global.y + -b * id * global.x + (-ty * a + tx * b) * id;\n\n\n    interactionData.target = item;\n\n    //a sprite or display object with a hit area defined\n    if (item.hitArea && item.hitArea.contains)\n    {\n        if (item.hitArea.contains(x, y))\n        {\n            interactionData.target = item;\n            return true;\n        }\n        return false;\n    }\n    // a sprite with no hitarea defined\n    else if(item instanceof PIXI.Sprite)\n    {\n        var width = item.texture.frame.width;\n        var height = item.texture.frame.height;\n        var x1 = -width * item.anchor.x;\n        var y1;\n\n        if (x > x1 && x < x1 + width)\n        {\n            y1 = -height * item.anchor.y;\n\n            if (y > y1 && y < y1 + height)\n            {\n                // set the target property if a hit is true!\n                interactionData.target = item;\n                return true;\n            }\n        }\n    }\n    else if(item instanceof PIXI.Graphics)\n    {\n        var graphicsData = item.graphicsData;\n        for (i = 0; i < graphicsData.length; i++)\n        {\n            var data = graphicsData[i];\n            if(!data.fill)continue;\n\n            // only deal with fills..\n            if(data.shape)\n            {\n                if(data.shape.contains(x, y))\n                {\n                    interactionData.target = item;\n                    return true;\n                }\n            }\n        }\n    }\n\n    var length = item.children.length;\n\n    for (i = 0; i < length; i++)\n    {\n        var tempItem = item.children[i];\n        var hit = this.hitTest(tempItem, interactionData);\n        if (hit)\n        {\n            // hmm.. TODO SET CORRECT TARGET?\n            interactionData.target = item;\n            return true;\n        }\n    }\n    return false;\n};\n\n/**\n * Is called when a touch is moved across the renderer element\n *\n * @method onTouchMove\n * @param event {Event} The DOM event of a touch moving across the renderer view\n * @private\n */\nPIXI.InteractionManager.prototype.onTouchMove = function(event)\n{\n    if (this.dirty)\n    {\n        this.rebuildInteractiveGraph();\n    }\n\n    var rect = this.interactionDOMElement.getBoundingClientRect();\n    var changedTouches = event.changedTouches;\n    var touchData;\n    var i = 0;\n\n    for (i = 0; i < changedTouches.length; i++)\n    {\n        var touchEvent = changedTouches[i];\n        touchData = this.touches[touchEvent.identifier];\n        touchData.originalEvent = event;\n\n        // update the touch position\n        touchData.global.x = ( (touchEvent.clientX - rect.left) * (this.target.width / rect.width) ) / this.resolution;\n        touchData.global.y = ( (touchEvent.clientY - rect.top)  * (this.target.height / rect.height) )  / this.resolution;\n        if (navigator.isCocoonJS && !rect.left && !rect.top && !event.target.style.width && !event.target.style.height)\n        {\n            //Support for CocoonJS fullscreen scale modes\n            touchData.global.x = touchEvent.clientX;\n            touchData.global.y = touchEvent.clientY;\n        }\n\n        for (var j = 0; j < this.interactiveItems.length; j++)\n        {\n            var item = this.interactiveItems[j];\n            if (item.touchmove && item.__touchData && item.__touchData[touchEvent.identifier])\n            {\n                item.touchmove(touchData);\n            }\n        }\n    }\n};\n\n/**\n * Is called when a touch is started on the renderer element\n *\n * @method onTouchStart\n * @param event {Event} The DOM event of a touch starting on the renderer view\n * @private\n */\nPIXI.InteractionManager.prototype.onTouchStart = function(event)\n{\n    if (this.dirty)\n    {\n        this.rebuildInteractiveGraph();\n    }\n\n    var rect = this.interactionDOMElement.getBoundingClientRect();\n\n    if (PIXI.AUTO_PREVENT_DEFAULT)\n    {\n        event.preventDefault();\n    }\n\n    var changedTouches = event.changedTouches;\n    for (var i=0; i < changedTouches.length; i++)\n    {\n        var touchEvent = changedTouches[i];\n\n        var touchData = this.pool.pop();\n        if (!touchData)\n        {\n            touchData = new PIXI.InteractionData();\n        }\n\n        touchData.originalEvent = event;\n\n        this.touches[touchEvent.identifier] = touchData;\n        touchData.global.x = ( (touchEvent.clientX - rect.left) * (this.target.width / rect.width) ) / this.resolution;\n        touchData.global.y = ( (touchEvent.clientY - rect.top)  * (this.target.height / rect.height) ) / this.resolution;\n        if (navigator.isCocoonJS && !rect.left && !rect.top && !event.target.style.width && !event.target.style.height)\n        {\n            //Support for CocoonJS fullscreen scale modes\n            touchData.global.x = touchEvent.clientX;\n            touchData.global.y = touchEvent.clientY;\n        }\n\n        var length = this.interactiveItems.length;\n\n        for (var j = 0; j < length; j++)\n        {\n            var item = this.interactiveItems[j];\n\n            if (item.touchstart || item.tap)\n            {\n                item.__hit = this.hitTest(item, touchData);\n\n                if (item.__hit)\n                {\n                    //call the function!\n                    if (item.touchstart)item.touchstart(touchData);\n                    item.__isDown = true;\n                    item.__touchData = item.__touchData || {};\n                    item.__touchData[touchEvent.identifier] = touchData;\n\n                    if (!item.interactiveChildren) break;\n                }\n            }\n        }\n    }\n};\n\n/**\n * Is called when a touch is ended on the renderer element\n *\n * @method onTouchEnd\n * @param event {Event} The DOM event of a touch ending on the renderer view\n * @private\n */\nPIXI.InteractionManager.prototype.onTouchEnd = function(event)\n{\n    if (this.dirty)\n    {\n        this.rebuildInteractiveGraph();\n    }\n\n    var rect = this.interactionDOMElement.getBoundingClientRect();\n    var changedTouches = event.changedTouches;\n\n    for (var i=0; i < changedTouches.length; i++)\n    {\n        var touchEvent = changedTouches[i];\n        var touchData = this.touches[touchEvent.identifier];\n        var up = false;\n        touchData.global.x = ( (touchEvent.clientX - rect.left) * (this.target.width / rect.width) ) / this.resolution;\n        touchData.global.y = ( (touchEvent.clientY - rect.top)  * (this.target.height / rect.height) ) / this.resolution;\n        if (navigator.isCocoonJS && !rect.left && !rect.top && !event.target.style.width && !event.target.style.height)\n        {\n            //Support for CocoonJS fullscreen scale modes\n            touchData.global.x = touchEvent.clientX;\n            touchData.global.y = touchEvent.clientY;\n        }\n\n        var length = this.interactiveItems.length;\n        for (var j = 0; j < length; j++)\n        {\n            var item = this.interactiveItems[j];\n\n            if (item.__touchData && item.__touchData[touchEvent.identifier])\n            {\n\n                item.__hit = this.hitTest(item, item.__touchData[touchEvent.identifier]);\n\n                // so this one WAS down...\n                touchData.originalEvent = event;\n                // hitTest??\n\n                if (item.touchend || item.tap)\n                {\n                    if (item.__hit && !up)\n                    {\n                        if (item.touchend)\n                        {\n                            item.touchend(touchData);\n                        }\n                        if (item.__isDown && item.tap)\n                        {\n                            item.tap(touchData);\n                        }\n                        if (!item.interactiveChildren)\n                        {\n                            up = true;\n                        }\n                    }\n                    else\n                    {\n                        if (item.__isDown && item.touchendoutside)\n                        {\n                            item.touchendoutside(touchData);\n                        }\n                    }\n\n                    item.__isDown = false;\n                }\n\n                item.__touchData[touchEvent.identifier] = null;\n            }\n        }\n        // remove the touch..\n        this.pool.push(touchData);\n        this.touches[touchEvent.identifier] = null;\n    }\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * A Stage represents the root of the display tree. Everything connected to the stage is rendered\n *\n * @class Stage\n * @extends DisplayObjectContainer\n * @constructor\n * @param backgroundColor {Number} the background color of the stage, you have to pass this in is in hex format\n *      like: 0xFFFFFF for white\n * \n * Creating a stage is a mandatory process when you use Pixi, which is as simple as this : \n * var stage = new PIXI.Stage(0xFFFFFF);\n * where the parameter given is the background colour of the stage, in hex\n * you will use this stage instance to add your sprites to it and therefore to the renderer\n * Here is how to add a sprite to the stage : \n * stage.addChild(sprite);\n */\nPIXI.Stage = function(backgroundColor)\n{\n    PIXI.DisplayObjectContainer.call( this );\n\n    /**\n     * [read-only] Current transform of the object based on world (parent) factors\n     *\n     * @property worldTransform\n     * @type Matrix\n     * @readOnly\n     * @private\n     */\n    this.worldTransform = new PIXI.Matrix();\n\n    /**\n     * Whether or not the stage is interactive\n     *\n     * @property interactive\n     * @type Boolean\n     */\n    this.interactive = true;\n\n    /**\n     * The interaction manage for this stage, manages all interactive activity on the stage\n     *\n     * @property interactionManager\n     * @type InteractionManager\n     */\n    this.interactionManager = new PIXI.InteractionManager(this);\n\n    /**\n     * Whether the stage is dirty and needs to have interactions updated\n     *\n     * @property dirty\n     * @type Boolean\n     * @private\n     */\n    this.dirty = true;\n\n    //the stage is its own stage\n    this.stage = this;\n\n    //optimize hit detection a bit\n    this.stage.hitArea = new PIXI.Rectangle(0, 0, 100000, 100000);\n\n    this.setBackgroundColor(backgroundColor);\n};\n\n// constructor\nPIXI.Stage.prototype = Object.create( PIXI.DisplayObjectContainer.prototype );\nPIXI.Stage.prototype.constructor = PIXI.Stage;\n\n/**\n * Sets another DOM element which can receive mouse/touch interactions instead of the default Canvas element.\n * This is useful for when you have other DOM elements on top of the Canvas element.\n *\n * @method setInteractionDelegate\n * @param domElement {DOMElement} This new domElement which will receive mouse/touch events\n */\nPIXI.Stage.prototype.setInteractionDelegate = function(domElement)\n{\n    this.interactionManager.setTargetDomElement( domElement );\n};\n\n/*\n * Updates the object transform for rendering\n *\n * @method updateTransform\n * @private\n */\nPIXI.Stage.prototype.updateTransform = function()\n{\n    this.worldAlpha = 1;\n\n    for(var i=0,j=this.children.length; i<j; i++)\n    {\n        this.children[i].updateTransform();\n    }\n\n    if(this.dirty)\n    {\n        this.dirty = false;\n        // update interactive!\n        this.interactionManager.dirty = true;\n    }\n\n    if(this.interactive)this.interactionManager.update();\n};\n\n/**\n * Sets the background color for the stage\n *\n * @method setBackgroundColor\n * @param backgroundColor {Number} the color of the background, easiest way to pass this in is in hex format\n *      like: 0xFFFFFF for white\n */\nPIXI.Stage.prototype.setBackgroundColor = function(backgroundColor)\n{\n    this.backgroundColor = backgroundColor || 0x000000;\n    this.backgroundColorSplit = PIXI.hex2rgb(this.backgroundColor);\n    var hex = this.backgroundColor.toString(16);\n    hex = '000000'.substr(0, 6 - hex.length) + hex;\n    this.backgroundColorString = '#' + hex;\n};\n\n/**\n * This will return the point containing global coordinates of the mouse.\n *\n * @method getMousePosition\n * @return {Point} A point containing the coordinates of the global InteractionData position.\n */\nPIXI.Stage.prototype.getMousePosition = function()\n{\n    return this.interactionManager.mouse.global;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n \n// http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n\n// requestAnimationFrame polyfill by Erik MÃ¶ller. fixes from Paul Irish and Tino Zijdel\n\n// MIT license\n\n/**\n * A polyfill for requestAnimationFrame\n * You can actually use both requestAnimationFrame and requestAnimFrame, \n * you will still benefit from the polyfill\n *\n * @method requestAnimationFrame\n */\n\n/**\n * A polyfill for cancelAnimationFrame\n *\n * @method cancelAnimationFrame\n */\n(function(window) {\n    var lastTime = 0;\n    var vendors = ['ms', 'moz', 'webkit', 'o'];\n    for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n        window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n        window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] ||\n            window[vendors[x] + 'CancelRequestAnimationFrame'];\n    }\n\n    if (!window.requestAnimationFrame) {\n        window.requestAnimationFrame = function(callback) {\n            var currTime = new Date().getTime();\n            var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n            var id = window.setTimeout(function() { callback(currTime + timeToCall); },\n              timeToCall);\n            lastTime = currTime + timeToCall;\n            return id;\n        };\n    }\n\n    if (!window.cancelAnimationFrame) {\n        window.cancelAnimationFrame = function(id) {\n            clearTimeout(id);\n        };\n    }\n\n    window.requestAnimFrame = window.requestAnimationFrame;\n})(this);\n\n/**\n * Converts a hex color number to an [R, G, B] array\n *\n * @method hex2rgb\n * @param hex {Number}\n */\nPIXI.hex2rgb = function(hex) {\n    return [(hex >> 16 & 0xFF) / 255, ( hex >> 8 & 0xFF) / 255, (hex & 0xFF)/ 255];\n};\n\n/**\n * Converts a color as an [R, G, B] array to a hex number\n *\n * @method rgb2hex\n * @param rgb {Array}\n */\nPIXI.rgb2hex = function(rgb) {\n    return ((rgb[0]*255 << 16) + (rgb[1]*255 << 8) + rgb[2]*255);\n};\n\n/**\n * A polyfill for Function.prototype.bind\n *\n * @method bind\n */\nif (typeof Function.prototype.bind !== 'function') {\n    Function.prototype.bind = (function () {\n        return function (thisArg) {\n            var target = this, i = arguments.length - 1, boundArgs = [];\n            if (i > 0)\n            {\n                boundArgs.length = i;\n                while (i--) boundArgs[i] = arguments[i + 1];\n            }\n\n            if (typeof target !== 'function') throw new TypeError();\n\n            function bound() {\n                var i = arguments.length, args = new Array(i);\n                while (i--) args[i] = arguments[i];\n                args = boundArgs.concat(args);\n                return target.apply(this instanceof bound ? this : thisArg, args);\n            }\n\n            bound.prototype = (function F(proto) {\n                if (proto) F.prototype = proto;\n                if (!(this instanceof F)) return new F();\n            })(target.prototype);\n\n            return bound;\n        };\n    })();\n}\n\n/**\n * A wrapper for ajax requests to be handled cross browser\n *\n * @class AjaxRequest\n * @constructor\n */\nPIXI.AjaxRequest = function()\n{\n    var activexmodes = ['Msxml2.XMLHTTP.6.0', 'Msxml2.XMLHTTP.3.0', 'Microsoft.XMLHTTP']; //activeX versions to check for in IE\n\n    if (window.ActiveXObject)\n    { //Test for support for ActiveXObject in IE first (as XMLHttpRequest in IE7 is broken)\n        for (var i=0; i<activexmodes.length; i++)\n        {\n            try{\n                return new window.ActiveXObject(activexmodes[i]);\n            }\n            catch(e) {\n                //suppress error\n            }\n        }\n    }\n    else if (window.XMLHttpRequest) // if Mozilla, Safari etc\n    {\n        return new window.XMLHttpRequest();\n    }\n    else\n    {\n        return false;\n    }\n};\n/*\nPIXI.packColorRGBA = function(r, g, b, a)//r, g, b, a)\n{\n  //  console.log(r, b, c, d)\n  return (Math.floor((r)*63) << 18) | (Math.floor((g)*63) << 12) | (Math.floor((b)*63) << 6);// | (Math.floor((a)*63))\n  //  i = i | (Math.floor((a)*63));\n   // return i;\n   // var r = (i / 262144.0 ) / 64;\n   // var g = (i / 4096.0)%64 / 64;\n  //  var b = (i / 64.0)%64 / 64;\n  //  var a = (i)%64 / 64;\n     \n  //  console.log(r, g, b, a);\n  //  return i;\n\n};\n*/\n/*\nPIXI.packColorRGB = function(r, g, b)//r, g, b, a)\n{\n    return (Math.floor((r)*255) << 16) | (Math.floor((g)*255) << 8) | (Math.floor((b)*255));\n};\n\nPIXI.unpackColorRGB = function(r, g, b)//r, g, b, a)\n{\n    return (Math.floor((r)*255) << 16) | (Math.floor((g)*255) << 8) | (Math.floor((b)*255));\n};\n*/\n\n/**\n * Checks whether the Canvas BlendModes are supported by the current browser\n *\n * @method canUseNewCanvasBlendModes\n * @return {Boolean} whether they are supported\n */\nPIXI.canUseNewCanvasBlendModes = function()\n{\n    if (typeof document === 'undefined') return false;\n    var canvas = document.createElement('canvas');\n    canvas.width = 1;\n    canvas.height = 1;\n    var context = canvas.getContext('2d');\n    context.fillStyle = '#000';\n    context.fillRect(0,0,1,1);\n    context.globalCompositeOperation = 'multiply';\n    context.fillStyle = '#fff';\n    context.fillRect(0,0,1,1);\n    return context.getImageData(0,0,1,1).data[0] === 0;\n};\n\n/**\n * Given a number, this function returns the closest number that is a power of two\n * this function is taken from Starling Framework as its pretty neat ;)\n *\n * @method getNextPowerOfTwo\n * @param number {Number}\n * @return {Number} the closest number that is a power of two\n */\nPIXI.getNextPowerOfTwo = function(number)\n{\n    if (number > 0 && (number & (number - 1)) === 0) // see: http://goo.gl/D9kPj\n        return number;\n    else\n    {\n        var result = 1;\n        while (result < number) result <<= 1;\n        return result;\n    }\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n * @author Chad Engler https://github.com/englercj @Rolnaaba\n */\n\n/**\n * Originally based on https://github.com/mrdoob/eventtarget.js/ from mr Doob.\n * Currently takes inspiration from the nodejs EventEmitter, EventEmitter3, and smokesignals\n */\n\n/**\n * Mixins event emitter functionality to a class\n *\n * @class EventTarget\n * @example\n *      function MyEmitter() {}\n *\n *      PIXI.EventTarget.mixin(MyEmitter.prototype);\n *\n *      var em = new MyEmitter();\n *      em.emit('eventName', 'some data', 'some more data', {}, null, ...);\n */\nPIXI.EventTarget = {\n    /**\n     * Backward compat from when this used to be a function\n     */\n    call: function callCompat(obj) {\n        if(obj) {\n            obj = obj.prototype || obj;\n            PIXI.EventTarget.mixin(obj);\n        }\n    },\n\n    /**\n     * Mixes in the properties of the EventTarget prototype onto another object\n     *\n     * @method mixin\n     * @param object {Object} The obj to mix into\n     */\n    mixin: function mixin(obj) {\n        /**\n         * Return a list of assigned event listeners.\n         *\n         * @method listeners\n         * @param eventName {String} The events that should be listed.\n         * @returns {Array} An array of listener functions\n         */\n        obj.listeners = function listeners(eventName) {\n            this._listeners = this._listeners || {};\n\n            return this._listeners[eventName] ? this._listeners[eventName].slice() : [];\n        };\n\n        /**\n         * Emit an event to all registered event listeners.\n         *\n         * @method emit\n         * @alias dispatchEvent\n         * @param eventName {String} The name of the event.\n         * @returns {Boolean} Indication if we've emitted an event.\n         */\n        obj.emit = obj.dispatchEvent = function emit(eventName, data) {\n            this._listeners = this._listeners || {};\n\n            //backwards compat with old method \".emit({ type: 'something' })\"\n            if(typeof eventName === 'object') {\n                data = eventName;\n                eventName = eventName.type;\n            }\n\n            //ensure we are using a real pixi event\n            if(!data || data.__isEventObject !== true) {\n                data = new PIXI.Event(this, eventName, data);\n            }\n\n            //iterate the listeners\n            if(this._listeners && this._listeners[eventName]) {\n                var listeners = this._listeners[eventName].slice(0),\n                    length = listeners.length,\n                    fn = listeners[0],\n                    i;\n\n                for(i = 0; i < length; fn = listeners[++i]) {\n                    //call the event listener\n                    fn.call(this, data);\n\n                    //if \"stopImmediatePropagation\" is called, stop calling sibling events\n                    if(data.stoppedImmediate) {\n                        return this;\n                    }\n                }\n\n                //if \"stopPropagation\" is called then don't bubble the event\n                if(data.stopped) {\n                    return this;\n                }\n            }\n\n            //bubble this event up the scene graph\n            if(this.parent && this.parent.emit) {\n                this.parent.emit.call(this.parent, eventName, data);\n            }\n\n            return this;\n        };\n\n        /**\n         * Register a new EventListener for the given event.\n         *\n         * @method on\n         * @alias addEventListener\n         * @param eventName {String} Name of the event.\n         * @param callback {Functon} fn Callback function.\n         */\n        obj.on = obj.addEventListener = function on(eventName, fn) {\n            this._listeners = this._listeners || {};\n\n            (this._listeners[eventName] = this._listeners[eventName] || [])\n                .push(fn);\n\n            return this;\n        };\n\n        /**\n         * Add an EventListener that's only called once.\n         *\n         * @method once\n         * @param eventName {String} Name of the event.\n         * @param callback {Function} Callback function.\n         */\n        obj.once = function once(eventName, fn) {\n            this._listeners = this._listeners || {};\n\n            var self = this;\n            function onceHandlerWrapper() {\n                fn.apply(self.off(eventName, onceHandlerWrapper), arguments);\n            }\n            onceHandlerWrapper._originalHandler = fn;\n\n            return this.on(eventName, onceHandlerWrapper);\n        };\n\n        /**\n         * Remove event listeners.\n         *\n         * @method off\n         * @alias removeEventListener\n         * @param eventName {String} The event we want to remove.\n         * @param callback {Function} The listener that we need to find.\n         */\n        obj.off = obj.removeEventListener = function off(eventName, fn) {\n            this._listeners = this._listeners || {};\n\n            if(!this._listeners[eventName])\n                return this;\n\n            var list = this._listeners[eventName],\n                i = fn ? list.length : 0;\n\n            while(i-- > 0) {\n                if(list[i] === fn || list[i]._originalHandler === fn) {\n                    list.splice(i, 1);\n                }\n            }\n\n            if(list.length === 0) {\n                delete this._listeners[eventName];\n            }\n\n            return this;\n        };\n\n        /**\n         * Remove all listeners or only the listeners for the specified event.\n         *\n         * @method removeAllListeners\n         * @param eventName {String} The event you want to remove all listeners for.\n         */\n        obj.removeAllListeners = function removeAllListeners(eventName) {\n            this._listeners = this._listeners || {};\n\n            if(!this._listeners[eventName])\n                return this;\n\n            delete this._listeners[eventName];\n\n            return this;\n        };\n    }\n};\n\n/**\n * Creates an homogenous object for tracking events so users can know what to expect.\n *\n * @class Event\n * @extends Object\n * @constructor\n * @param target {Object} The target object that the event is called on\n * @param name {String} The string name of the event that was triggered\n * @param data {Object} Arbitrary event data to pass along\n */\nPIXI.Event = function(target, name, data) {\n    //for duck typing in the \".on()\" function\n    this.__isEventObject = true;\n\n    /**\n     * Tracks the state of bubbling propagation. Do not\n     * set this directly, instead use `event.stopPropagation()`\n     *\n     * @property stopped\n     * @type Boolean\n     * @private\n     * @readOnly\n     */\n    this.stopped = false;\n\n    /**\n     * Tracks the state of sibling listener propagation. Do not\n     * set this directly, instead use `event.stopImmediatePropagation()`\n     *\n     * @property stoppedImmediate\n     * @type Boolean\n     * @private\n     * @readOnly\n     */\n    this.stoppedImmediate = false;\n\n    /**\n     * The original target the event triggered on.\n     *\n     * @property target\n     * @type Object\n     * @readOnly\n     */\n    this.target = target;\n\n    /**\n     * The string name of the event that this represents.\n     *\n     * @property type\n     * @type String\n     * @readOnly\n     */\n    this.type = name;\n\n    /**\n     * The data that was passed in with this event.\n     *\n     * @property data\n     * @type Object\n     * @readOnly\n     */\n    this.data = data;\n\n    //backwards compat with older version of events\n    this.content = data;\n\n    /**\n     * The timestamp when the event occurred.\n     *\n     * @property timeStamp\n     * @type Number\n     * @readOnly\n     */\n    this.timeStamp = Date.now();\n};\n\n/**\n * Stops the propagation of events up the scene graph (prevents bubbling).\n *\n * @method stopPropagation\n */\nPIXI.Event.prototype.stopPropagation = function stopPropagation() {\n    this.stopped = true;\n};\n\n/**\n * Stops the propagation of events to sibling listeners (no longer calls any listeners).\n *\n * @method stopImmediatePropagation\n */\nPIXI.Event.prototype.stopImmediatePropagation = function stopImmediatePropagation() {\n    this.stoppedImmediate = true;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * This helper function will automatically detect which renderer you should be using.\n * WebGL is the preferred renderer as it is a lot faster. If webGL is not supported by\n * the browser then this function will return a canvas renderer\n * @class autoDetectRenderer\n * @static\n * @param width=800 {Number} the width of the renderers view\n * @param height=600 {Number} the height of the renderers view\n * \n * @param [options] {Object} The optional renderer parameters\n * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional\n * @param [options.transparent=false] {Boolean} If the render view is transparent, default false\n * @param [options.antialias=false] {Boolean} sets antialias (only applicable in chrome at the moment)\n * @param [options.preserveDrawingBuffer=false] {Boolean} enables drawing buffer preservation, enable this if you need to call toDataUrl on the webgl context\n * @param [options.resolution=1] {Number} the resolution of the renderer retina would be 2\n * \n */\nPIXI.autoDetectRenderer = function(width, height, options)\n{\n    if(!width)width = 800;\n    if(!height)height = 600;\n\n    // BORROWED from Mr Doob (mrdoob.com)\n    var webgl = ( function () { try {\n                                    var canvas = document.createElement( 'canvas' );\n                                    return !! window.WebGLRenderingContext && ( canvas.getContext( 'webgl' ) || canvas.getContext( 'experimental-webgl' ) );\n                                } catch( e ) {\n                                    return false;\n                                }\n                            } )();\n\n    if( webgl )\n    {\n        return new PIXI.WebGLRenderer(width, height, options);\n    }\n\n    return  new PIXI.CanvasRenderer(width, height, options);\n};\n\n/**\n * This helper function will automatically detect which renderer you should be using.\n * This function is very similar to the autoDetectRenderer function except that is will return a canvas renderer for android.\n * Even thought both android chrome supports webGL the canvas implementation perform better at the time of writing. \n * This function will likely change and update as webGL performance improves on these devices.\n * \n * @class autoDetectRecommendedRenderer\n * @static\n * @param width=800 {Number} the width of the renderers view\n * @param height=600 {Number} the height of the renderers view\n * \n * @param [options] {Object} The optional renderer parameters\n * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional\n * @param [options.transparent=false] {Boolean} If the render view is transparent, default false\n * @param [options.antialias=false] {Boolean} sets antialias (only applicable in chrome at the moment)\n * @param [options.preserveDrawingBuffer=false] {Boolean} enables drawing buffer preservation, enable this if you need to call toDataUrl on the webgl context\n * @param [options.resolution=1] {Number} the resolution of the renderer retina would be 2\n * \n */\nPIXI.autoDetectRecommendedRenderer = function(width, height, options)\n{\n    if(!width)width = 800;\n    if(!height)height = 600;\n\n    // BORROWED from Mr Doob (mrdoob.com)\n    var webgl = ( function () { try {\n                                    var canvas = document.createElement( 'canvas' );\n                                    return !! window.WebGLRenderingContext && ( canvas.getContext( 'webgl' ) || canvas.getContext( 'experimental-webgl' ) );\n                                } catch( e ) {\n                                    return false;\n                                }\n                            } )();\n\n    var isAndroid = /Android/i.test(navigator.userAgent);\n\n    if( webgl && !isAndroid)\n    {\n        return new PIXI.WebGLRenderer(width, height, options);\n    }\n\n    return  new PIXI.CanvasRenderer(width, height, options);\n};\n\n/*\n    PolyK library\n    url: http://polyk.ivank.net\n    Released under MIT licence.\n\n    Copyright (c) 2012 Ivan Kuckir\n\n    Permission is hereby granted, free of charge, to any person\n    obtaining a copy of this software and associated documentation\n    files (the \"Software\"), to deal in the Software without\n    restriction, including without limitation the rights to use,\n    copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the\n    Software is furnished to do so, subject to the following\n    conditions:\n\n    The above copyright notice and this permission notice shall be\n    included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n    OTHER DEALINGS IN THE SOFTWARE.\n\n    This is an amazing lib!\n\n    Slightly modified by Mat Groves (matgroves.com);\n*/\n\n/**\n * Based on the Polyk library http://polyk.ivank.net released under MIT licence.\n * This is an amazing lib!\n * Slightly modified by Mat Groves (matgroves.com);\n * @class PolyK\n */\nPIXI.PolyK = {};\n\n/**\n * Triangulates shapes for webGL graphic fills.\n *\n * @method Triangulate\n */\nPIXI.PolyK.Triangulate = function(p)\n{\n    var sign = true;\n\n    var n = p.length >> 1;\n    if(n < 3) return [];\n\n    var tgs = [];\n    var avl = [];\n    for(var i = 0; i < n; i++) avl.push(i);\n\n    i = 0;\n    var al = n;\n    while(al > 3)\n    {\n        var i0 = avl[(i+0)%al];\n        var i1 = avl[(i+1)%al];\n        var i2 = avl[(i+2)%al];\n\n        var ax = p[2*i0],  ay = p[2*i0+1];\n        var bx = p[2*i1],  by = p[2*i1+1];\n        var cx = p[2*i2],  cy = p[2*i2+1];\n\n        var earFound = false;\n        if(PIXI.PolyK._convex(ax, ay, bx, by, cx, cy, sign))\n        {\n            earFound = true;\n            for(var j = 0; j < al; j++)\n            {\n                var vi = avl[j];\n                if(vi === i0 || vi === i1 || vi === i2) continue;\n\n                if(PIXI.PolyK._PointInTriangle(p[2*vi], p[2*vi+1], ax, ay, bx, by, cx, cy)) {\n                    earFound = false;\n                    break;\n                }\n            }\n        }\n\n        if(earFound)\n        {\n            tgs.push(i0, i1, i2);\n            avl.splice((i+1)%al, 1);\n            al--;\n            i = 0;\n        }\n        else if(i++ > 3*al)\n        {\n            // need to flip flip reverse it!\n            // reset!\n            if(sign)\n            {\n                tgs = [];\n                avl = [];\n                for(i = 0; i < n; i++) avl.push(i);\n\n                i = 0;\n                al = n;\n\n                sign = false;\n            }\n            else\n            {\n             //   window.console.log(\"PIXI Warning: shape too complex to fill\");\n                return null;\n            }\n        }\n    }\n\n    tgs.push(avl[0], avl[1], avl[2]);\n    return tgs;\n};\n\n/**\n * Checks whether a point is within a triangle\n *\n * @method _PointInTriangle\n * @param px {Number} x coordinate of the point to test\n * @param py {Number} y coordinate of the point to test\n * @param ax {Number} x coordinate of the a point of the triangle\n * @param ay {Number} y coordinate of the a point of the triangle\n * @param bx {Number} x coordinate of the b point of the triangle\n * @param by {Number} y coordinate of the b point of the triangle\n * @param cx {Number} x coordinate of the c point of the triangle\n * @param cy {Number} y coordinate of the c point of the triangle\n * @private\n * @return {Boolean}\n */\nPIXI.PolyK._PointInTriangle = function(px, py, ax, ay, bx, by, cx, cy)\n{\n    var v0x = cx-ax;\n    var v0y = cy-ay;\n    var v1x = bx-ax;\n    var v1y = by-ay;\n    var v2x = px-ax;\n    var v2y = py-ay;\n\n    var dot00 = v0x*v0x+v0y*v0y;\n    var dot01 = v0x*v1x+v0y*v1y;\n    var dot02 = v0x*v2x+v0y*v2y;\n    var dot11 = v1x*v1x+v1y*v1y;\n    var dot12 = v1x*v2x+v1y*v2y;\n\n    var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);\n    var u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    var v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n\n    // Check if point is in triangle\n    return (u >= 0) && (v >= 0) && (u + v < 1);\n};\n\n/**\n * Checks whether a shape is convex\n *\n * @method _convex\n * @private\n * @return {Boolean}\n */\nPIXI.PolyK._convex = function(ax, ay, bx, by, cx, cy, sign)\n{\n    return ((ay-by)*(cx-bx) + (bx-ax)*(cy-by) >= 0) === sign;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n* @method initDefaultShaders\n* @static\n* @private\n*/\nPIXI.initDefaultShaders = function()\n{\n};\n\n/**\n* @method CompileVertexShader\n* @static\n* @param gl {WebGLContext} the current WebGL drawing context\n* @param shaderSrc {Array}\n* @return {Any}\n*/\nPIXI.CompileVertexShader = function(gl, shaderSrc)\n{\n    return PIXI._CompileShader(gl, shaderSrc, gl.VERTEX_SHADER);\n};\n\n/**\n* @method CompileFragmentShader\n* @static\n* @param gl {WebGLContext} the current WebGL drawing context\n* @param shaderSrc {Array}\n* @return {Any}\n*/\nPIXI.CompileFragmentShader = function(gl, shaderSrc)\n{\n    return PIXI._CompileShader(gl, shaderSrc, gl.FRAGMENT_SHADER);\n};\n\n/**\n* @method _CompileShader\n* @static\n* @private\n* @param gl {WebGLContext} the current WebGL drawing context\n* @param shaderSrc {Array}\n* @param shaderType {Number}\n* @return {Any}\n*/\nPIXI._CompileShader = function(gl, shaderSrc, shaderType)\n{\n    var src = shaderSrc.join(\"\\n\");\n    var shader = gl.createShader(shaderType);\n    gl.shaderSource(shader, src);\n    gl.compileShader(shader);\n\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))\n    {\n        window.console.log(gl.getShaderInfoLog(shader));\n        return null;\n    }\n\n    return shader;\n};\n\n/**\n* @method compileProgram\n* @static\n* @param gl {WebGLContext} the current WebGL drawing context\n* @param vertexSrc {Array}\n* @param fragmentSrc {Array}\n* @return {Any}\n*/\nPIXI.compileProgram = function(gl, vertexSrc, fragmentSrc)\n{\n    var fragmentShader = PIXI.CompileFragmentShader(gl, fragmentSrc);\n    var vertexShader = PIXI.CompileVertexShader(gl, vertexSrc);\n\n    var shaderProgram = gl.createProgram();\n\n    gl.attachShader(shaderProgram, vertexShader);\n    gl.attachShader(shaderProgram, fragmentShader);\n    gl.linkProgram(shaderProgram);\n\n    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS))\n    {\n        window.console.log(\"Could not initialise shaders\");\n    }\n\n    return shaderProgram;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n * @author Richard Davey http://www.photonstorm.com @photonstorm\n */\n\n/**\n* @class PixiShader\n* @constructor\n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.PixiShader = function(gl)\n{\n    /**\n     * @property _UID\n     * @type Number\n     * @private\n     */\n    this._UID = PIXI._UID++;\n\n    /**\n     * @property gl\n     * @type WebGLContext\n     */\n    this.gl = gl;\n\n    /**\n     * The WebGL program.\n     * @property program\n     * @type {Any}\n     */\n    this.program = null;\n\n    /**\n     * The fragment shader.\n     * @property fragmentSrc\n     * @type Array\n     */\n    this.fragmentSrc = [\n        'precision lowp float;',\n        'varying vec2 vTextureCoord;',\n        'varying vec4 vColor;',\n        'uniform sampler2D uSampler;',\n        'void main(void) {',\n        '   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;',\n        '}'\n    ];\n\n    /**\n     * A local texture counter for multi-texture shaders.\n     * @property textureCount\n     * @type Number\n     */\n    this.textureCount = 0;\n\n    /**\n     * A local flag\n     * @property firstRun\n     * @type Boolean\n     * @private\n     */\n    this.firstRun = true;\n\n    /**\n     * A dirty flag\n     * @property dirty\n     * @type Boolean\n     */\n    this.dirty = true;\n\n    /**\n     * Uniform attributes cache.\n     * @property attributes\n     * @type Array\n     * @private\n     */\n    this.attributes = [];\n\n    this.init();\n};\n\nPIXI.PixiShader.prototype.constructor = PIXI.PixiShader;\n\n/**\n* Initialises the shader.\n*\n* @method init\n*/\nPIXI.PixiShader.prototype.init = function()\n{\n    var gl = this.gl;\n\n    var program = PIXI.compileProgram(gl, this.vertexSrc || PIXI.PixiShader.defaultVertexSrc, this.fragmentSrc);\n\n    gl.useProgram(program);\n\n    // get and store the uniforms for the shader\n    this.uSampler = gl.getUniformLocation(program, 'uSampler');\n    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');\n    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');\n    this.dimensions = gl.getUniformLocation(program, 'dimensions');\n\n    // get and store the attributes\n    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');\n    this.aTextureCoord = gl.getAttribLocation(program, 'aTextureCoord');\n    this.colorAttribute = gl.getAttribLocation(program, 'aColor');\n\n    // Begin worst hack eva //\n\n    // WHY??? ONLY on my chrome pixel the line above returns -1 when using filters?\n    // maybe its something to do with the current state of the gl context.\n    // I'm convinced this is a bug in the chrome browser as there is NO reason why this should be returning -1 especially as it only manifests on my chrome pixel\n    // If theres any webGL people that know why could happen please help :)\n    if(this.colorAttribute === -1)\n    {\n        this.colorAttribute = 2;\n    }\n\n    this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute];\n\n    // End worst hack eva //\n\n    // add those custom shaders!\n    for (var key in this.uniforms)\n    {\n        // get the uniform locations..\n        this.uniforms[key].uniformLocation = gl.getUniformLocation(program, key);\n    }\n\n    this.initUniforms();\n\n    this.program = program;\n};\n\n/**\n* Initialises the shader uniform values.\n*\n* Uniforms are specified in the GLSL_ES Specification: http://www.khronos.org/registry/webgl/specs/latest/1.0/\n* http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf\n*\n* @method initUniforms\n*/\nPIXI.PixiShader.prototype.initUniforms = function()\n{\n    this.textureCount = 1;\n    var gl = this.gl;\n    var uniform;\n\n    for (var key in this.uniforms)\n    {\n        uniform = this.uniforms[key];\n\n        var type = uniform.type;\n\n        if (type === 'sampler2D')\n        {\n            uniform._init = false;\n\n            if (uniform.value !== null)\n            {\n                this.initSampler2D(uniform);\n            }\n        }\n        else if (type === 'mat2' || type === 'mat3' || type === 'mat4')\n        {\n            //  These require special handling\n            uniform.glMatrix = true;\n            uniform.glValueLength = 1;\n\n            if (type === 'mat2')\n            {\n                uniform.glFunc = gl.uniformMatrix2fv;\n            }\n            else if (type === 'mat3')\n            {\n                uniform.glFunc = gl.uniformMatrix3fv;\n            }\n            else if (type === 'mat4')\n            {\n                uniform.glFunc = gl.uniformMatrix4fv;\n            }\n        }\n        else\n        {\n            //  GL function reference\n            uniform.glFunc = gl['uniform' + type];\n\n            if (type === '2f' || type === '2i')\n            {\n                uniform.glValueLength = 2;\n            }\n            else if (type === '3f' || type === '3i')\n            {\n                uniform.glValueLength = 3;\n            }\n            else if (type === '4f' || type === '4i')\n            {\n                uniform.glValueLength = 4;\n            }\n            else\n            {\n                uniform.glValueLength = 1;\n            }\n        }\n    }\n\n};\n\n/**\n* Initialises a Sampler2D uniform (which may only be available later on after initUniforms once the texture has loaded)\n*\n* @method initSampler2D\n*/\nPIXI.PixiShader.prototype.initSampler2D = function(uniform)\n{\n    if (!uniform.value || !uniform.value.baseTexture || !uniform.value.baseTexture.hasLoaded)\n    {\n        return;\n    }\n\n    var gl = this.gl;\n\n    gl.activeTexture(gl['TEXTURE' + this.textureCount]);\n    gl.bindTexture(gl.TEXTURE_2D, uniform.value.baseTexture._glTextures[gl.id]);\n\n    //  Extended texture data\n    if (uniform.textureData)\n    {\n        var data = uniform.textureData;\n\n        // GLTexture = mag linear, min linear_mipmap_linear, wrap repeat + gl.generateMipmap(gl.TEXTURE_2D);\n        // GLTextureLinear = mag/min linear, wrap clamp\n        // GLTextureNearestRepeat = mag/min NEAREST, wrap repeat\n        // GLTextureNearest = mag/min nearest, wrap clamp\n        // AudioTexture = whatever + luminance + width 512, height 2, border 0\n        // KeyTexture = whatever + luminance + width 256, height 2, border 0\n\n        //  magFilter can be: gl.LINEAR, gl.LINEAR_MIPMAP_LINEAR or gl.NEAREST\n        //  wrapS/T can be: gl.CLAMP_TO_EDGE or gl.REPEAT\n\n        var magFilter = (data.magFilter) ? data.magFilter : gl.LINEAR;\n        var minFilter = (data.minFilter) ? data.minFilter : gl.LINEAR;\n        var wrapS = (data.wrapS) ? data.wrapS : gl.CLAMP_TO_EDGE;\n        var wrapT = (data.wrapT) ? data.wrapT : gl.CLAMP_TO_EDGE;\n        var format = (data.luminance) ? gl.LUMINANCE : gl.RGBA;\n\n        if (data.repeat)\n        {\n            wrapS = gl.REPEAT;\n            wrapT = gl.REPEAT;\n        }\n\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, !!data.flipY);\n\n        if (data.width)\n        {\n            var width = (data.width) ? data.width : 512;\n            var height = (data.height) ? data.height : 2;\n            var border = (data.border) ? data.border : 0;\n\n            // void texImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, ArrayBufferView? pixels);\n            gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, border, format, gl.UNSIGNED_BYTE, null);\n        }\n        else\n        {\n            //  void texImage2D(GLenum target, GLint level, GLenum internalformat, GLenum format, GLenum type, ImageData? pixels);\n            gl.texImage2D(gl.TEXTURE_2D, 0, format, gl.RGBA, gl.UNSIGNED_BYTE, uniform.value.baseTexture.source);\n        }\n\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);\n    }\n\n    gl.uniform1i(uniform.uniformLocation, this.textureCount);\n\n    uniform._init = true;\n\n    this.textureCount++;\n\n};\n\n/**\n* Updates the shader uniform values.\n*\n* @method syncUniforms\n*/\nPIXI.PixiShader.prototype.syncUniforms = function()\n{\n    this.textureCount = 1;\n    var uniform;\n    var gl = this.gl;\n\n    //  This would probably be faster in an array and it would guarantee key order\n    for (var key in this.uniforms)\n    {\n        uniform = this.uniforms[key];\n\n        if (uniform.glValueLength === 1)\n        {\n            if (uniform.glMatrix === true)\n            {\n                uniform.glFunc.call(gl, uniform.uniformLocation, uniform.transpose, uniform.value);\n            }\n            else\n            {\n                uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value);\n            }\n        }\n        else if (uniform.glValueLength === 2)\n        {\n            uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y);\n        }\n        else if (uniform.glValueLength === 3)\n        {\n            uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y, uniform.value.z);\n        }\n        else if (uniform.glValueLength === 4)\n        {\n            uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y, uniform.value.z, uniform.value.w);\n        }\n        else if (uniform.type === 'sampler2D')\n        {\n            if (uniform._init)\n            {\n                gl.activeTexture(gl['TEXTURE' + this.textureCount]);\n\n                if(uniform.value.baseTexture._dirty[gl.id])\n                {\n                    PIXI.instances[gl.id].updateTexture(uniform.value.baseTexture);\n                }\n                else\n                {\n                    // bind the current texture\n                    gl.bindTexture(gl.TEXTURE_2D, uniform.value.baseTexture._glTextures[gl.id]);\n                }\n\n             //   gl.bindTexture(gl.TEXTURE_2D, uniform.value.baseTexture._glTextures[gl.id] || PIXI.createWebGLTexture( uniform.value.baseTexture, gl));\n                gl.uniform1i(uniform.uniformLocation, this.textureCount);\n                this.textureCount++;\n            }\n            else\n            {\n                this.initSampler2D(uniform);\n            }\n        }\n    }\n\n};\n\n/**\n* Destroys the shader.\n*\n* @method destroy\n*/\nPIXI.PixiShader.prototype.destroy = function()\n{\n    this.gl.deleteProgram( this.program );\n    this.uniforms = null;\n    this.gl = null;\n\n    this.attributes = null;\n};\n\n/**\n* The Default Vertex shader source.\n*\n* @property defaultVertexSrc\n* @type String\n*/\nPIXI.PixiShader.defaultVertexSrc = [\n    'attribute vec2 aVertexPosition;',\n    'attribute vec2 aTextureCoord;',\n    'attribute vec4 aColor;',\n\n    'uniform vec2 projectionVector;',\n    'uniform vec2 offsetVector;',\n\n    'varying vec2 vTextureCoord;',\n    'varying vec4 vColor;',\n\n    'const vec2 center = vec2(-1.0, 1.0);',\n\n    'void main(void) {',\n    '   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);',\n    '   vTextureCoord = aTextureCoord;',\n    '   vec3 color = mod(vec3(aColor.y/65536.0, aColor.y/256.0, aColor.y), 256.0) / 256.0;',\n    '   vColor = vec4(color * aColor.x, aColor.x);',\n    '}'\n];\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n* @class PixiFastShader\n* @constructor\n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.PixiFastShader = function(gl)\n{\n    /**\n     * @property _UID\n     * @type Number\n     * @private\n     */\n    this._UID = PIXI._UID++;\n    \n    /**\n     * @property gl\n     * @type WebGLContext\n     */\n    this.gl = gl;\n\n    /**\n     * The WebGL program.\n     * @property program\n     * @type {Any}\n     */\n    this.program = null;\n\n    /**\n     * The fragment shader.\n     * @property fragmentSrc\n     * @type Array\n     */\n    this.fragmentSrc = [\n        'precision lowp float;',\n        'varying vec2 vTextureCoord;',\n        'varying float vColor;',\n        'uniform sampler2D uSampler;',\n        'void main(void) {',\n        '   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;',\n        '}'\n    ];\n\n    /**\n     * The vertex shader.\n     * @property vertexSrc\n     * @type Array\n     */\n    this.vertexSrc = [\n        'attribute vec2 aVertexPosition;',\n        'attribute vec2 aPositionCoord;',\n        'attribute vec2 aScale;',\n        'attribute float aRotation;',\n        'attribute vec2 aTextureCoord;',\n        'attribute float aColor;',\n\n        'uniform vec2 projectionVector;',\n        'uniform vec2 offsetVector;',\n        'uniform mat3 uMatrix;',\n\n        'varying vec2 vTextureCoord;',\n        'varying float vColor;',\n\n        'const vec2 center = vec2(-1.0, 1.0);',\n\n        'void main(void) {',\n        '   vec2 v;',\n        '   vec2 sv = aVertexPosition * aScale;',\n        '   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);',\n        '   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);',\n        '   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;',\n        '   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);',\n        '   vTextureCoord = aTextureCoord;',\n      //  '   vec3 color = mod(vec3(aColor.y/65536.0, aColor.y/256.0, aColor.y), 256.0) / 256.0;',\n        '   vColor = aColor;',\n        '}'\n    ];\n\n    /**\n     * A local texture counter for multi-texture shaders.\n     * @property textureCount\n     * @type Number\n     */\n    this.textureCount = 0;\n    \n    this.init();\n};\n\nPIXI.PixiFastShader.prototype.constructor = PIXI.PixiFastShader;\n\n/**\n* Initialises the shader.\n* \n* @method init\n*/\nPIXI.PixiFastShader.prototype.init = function()\n{\n    var gl = this.gl;\n\n    var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);\n    \n    gl.useProgram(program);\n\n    // get and store the uniforms for the shader\n    this.uSampler = gl.getUniformLocation(program, 'uSampler');\n\n    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');\n    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');\n    this.dimensions = gl.getUniformLocation(program, 'dimensions');\n    this.uMatrix = gl.getUniformLocation(program, 'uMatrix');\n\n    // get and store the attributes\n    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');\n    this.aPositionCoord = gl.getAttribLocation(program, 'aPositionCoord');\n\n    this.aScale = gl.getAttribLocation(program, 'aScale');\n    this.aRotation = gl.getAttribLocation(program, 'aRotation');\n\n    this.aTextureCoord = gl.getAttribLocation(program, 'aTextureCoord');\n    this.colorAttribute = gl.getAttribLocation(program, 'aColor');\n   \n    // Begin worst hack eva //\n\n    // WHY??? ONLY on my chrome pixel the line above returns -1 when using filters?\n    // maybe its somthing to do with the current state of the gl context.\n    // Im convinced this is a bug in the chrome browser as there is NO reason why this should be returning -1 especially as it only manifests on my chrome pixel\n    // If theres any webGL people that know why could happen please help :)\n    if(this.colorAttribute === -1)\n    {\n        this.colorAttribute = 2;\n    }\n\n    this.attributes = [this.aVertexPosition, this.aPositionCoord,  this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute];\n    \n    // End worst hack eva //\n\n    this.program = program;\n};\n\n/**\n* Destroys the shader.\n* \n* @method destroy\n*/\nPIXI.PixiFastShader.prototype.destroy = function()\n{\n    this.gl.deleteProgram( this.program );\n    this.uniforms = null;\n    this.gl = null;\n\n    this.attributes = null;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n* @class StripShader\n* @constructor\n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.StripShader = function(gl)\n{\n    /**\n     * @property _UID\n     * @type Number\n     * @private\n     */\n    this._UID = PIXI._UID++;\n    \n    /**\n     * @property gl\n     * @type WebGLContext\n     */\n    this.gl = gl;\n\n    /**\n     * The WebGL program.\n     * @property program\n     * @type {Any}\n     */\n    this.program = null;\n\n    /**\n     * The fragment shader.\n     * @property fragmentSrc\n     * @type Array\n     */\n    this.fragmentSrc = [\n        'precision mediump float;',\n        'varying vec2 vTextureCoord;',\n     //   'varying float vColor;',\n        'uniform float alpha;',\n        'uniform sampler2D uSampler;',\n\n        'void main(void) {',\n        '   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * alpha;',\n      //  '   gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);',//gl_FragColor * alpha;',\n        '}'\n    ];\n\n    /**\n     * The vertex shader.\n     * @property vertexSrc\n     * @type Array\n     */\n    this.vertexSrc  = [\n        'attribute vec2 aVertexPosition;',\n        'attribute vec2 aTextureCoord;',\n        'uniform mat3 translationMatrix;',\n        'uniform vec2 projectionVector;',\n        'uniform vec2 offsetVector;',\n      //  'uniform float alpha;',\n       // 'uniform vec3 tint;',\n        'varying vec2 vTextureCoord;',\n      //  'varying vec4 vColor;',\n\n        'void main(void) {',\n        '   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);',\n        '   v -= offsetVector.xyx;',\n        '   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);',\n        '   vTextureCoord = aTextureCoord;',\n       // '   vColor = aColor * vec4(tint * alpha, alpha);',\n        '}'\n    ];\n\n    this.init();\n};\n\nPIXI.StripShader.prototype.constructor = PIXI.StripShader;\n\n/**\n* Initialises the shader.\n* \n* @method init\n*/\nPIXI.StripShader.prototype.init = function()\n{\n    var gl = this.gl;\n\n    var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);\n    gl.useProgram(program);\n\n    // get and store the uniforms for the shader\n    this.uSampler = gl.getUniformLocation(program, 'uSampler');\n    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');\n    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');\n    this.colorAttribute = gl.getAttribLocation(program, 'aColor');\n    //this.dimensions = gl.getUniformLocation(this.program, 'dimensions');\n\n    // get and store the attributes\n    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');\n    this.aTextureCoord = gl.getAttribLocation(program, 'aTextureCoord');\n\n    this.attributes = [this.aVertexPosition, this.aTextureCoord];\n\n    this.translationMatrix = gl.getUniformLocation(program, 'translationMatrix');\n    this.alpha = gl.getUniformLocation(program, 'alpha');\n\n    this.program = program;\n};\n\n/**\n* Destroys the shader.\n* \n* @method destroy\n*/\nPIXI.StripShader.prototype.destroy = function()\n{\n    this.gl.deleteProgram( this.program );\n    this.uniforms = null;\n    this.gl = null;\n\n    this.attribute = null;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n* @class PrimitiveShader\n* @constructor\n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.PrimitiveShader = function(gl)\n{\n    /**\n     * @property _UID\n     * @type Number\n     * @private\n     */\n    this._UID = PIXI._UID++;\n \n    /**\n     * @property gl\n     * @type WebGLContext\n     */\n    this.gl = gl;\n\n    /**\n     * The WebGL program.\n     * @property program\n     * @type {Any}\n     */\n    this.program = null;\n\n    /**\n     * The fragment shader.\n     * @property fragmentSrc\n     * @type Array\n     */\n    this.fragmentSrc = [\n        'precision mediump float;',\n        'varying vec4 vColor;',\n\n        'void main(void) {',\n        '   gl_FragColor = vColor;',\n        '}'\n    ];\n\n    /**\n     * The vertex shader.\n     * @property vertexSrc\n     * @type Array\n     */\n    this.vertexSrc  = [\n        'attribute vec2 aVertexPosition;',\n        'attribute vec4 aColor;',\n        'uniform mat3 translationMatrix;',\n        'uniform vec2 projectionVector;',\n        'uniform vec2 offsetVector;',\n        'uniform float alpha;',\n        'uniform vec3 tint;',\n        'varying vec4 vColor;',\n\n        'void main(void) {',\n        '   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);',\n        '   v -= offsetVector.xyx;',\n        '   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);',\n        '   vColor = aColor * vec4(tint * alpha, alpha);',\n        '}'\n    ];\n\n    this.init();\n};\n\nPIXI.PrimitiveShader.prototype.constructor = PIXI.PrimitiveShader;\n\n/**\n* Initialises the shader.\n* \n* @method init\n*/\nPIXI.PrimitiveShader.prototype.init = function()\n{\n    var gl = this.gl;\n\n    var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);\n    gl.useProgram(program);\n\n    // get and store the uniforms for the shader\n    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');\n    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');\n    this.tintColor = gl.getUniformLocation(program, 'tint');\n\n    // get and store the attributes\n    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');\n    this.colorAttribute = gl.getAttribLocation(program, 'aColor');\n\n    this.attributes = [this.aVertexPosition, this.colorAttribute];\n\n    this.translationMatrix = gl.getUniformLocation(program, 'translationMatrix');\n    this.alpha = gl.getUniformLocation(program, 'alpha');\n\n    this.program = program;\n};\n\n/**\n* Destroys the shader.\n* \n* @method destroy\n*/\nPIXI.PrimitiveShader.prototype.destroy = function()\n{\n    this.gl.deleteProgram( this.program );\n    this.uniforms = null;\n    this.gl = null;\n\n    this.attributes = null;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n* @class ComplexPrimitiveShader\n* @constructor\n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.ComplexPrimitiveShader = function(gl)\n{\n    /**\n     * @property _UID\n     * @type Number\n     * @private\n     */\n    this._UID = PIXI._UID++;\n\n    /**\n     * @property gl\n     * @type WebGLContext\n     */\n    this.gl = gl;\n\n    /**\n     * The WebGL program.\n     * @property program\n     * @type {Any}\n     */\n    this.program = null;\n\n    /**\n     * The fragment shader.\n     * @property fragmentSrc\n     * @type Array\n     */\n    this.fragmentSrc = [\n\n        'precision mediump float;',\n\n        'varying vec4 vColor;',\n\n        'void main(void) {',\n        '   gl_FragColor = vColor;',\n        '}'\n    ];\n\n    /**\n     * The vertex shader.\n     * @property vertexSrc\n     * @type Array\n     */\n    this.vertexSrc  = [\n        'attribute vec2 aVertexPosition;',\n        //'attribute vec4 aColor;',\n        'uniform mat3 translationMatrix;',\n        'uniform vec2 projectionVector;',\n        'uniform vec2 offsetVector;',\n        \n        'uniform vec3 tint;',\n        'uniform float alpha;',\n        'uniform vec3 color;',\n\n        'varying vec4 vColor;',\n\n        'void main(void) {',\n        '   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);',\n        '   v -= offsetVector.xyx;',\n        '   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);',\n        '   vColor = vec4(color * alpha * tint, alpha);',//\" * vec4(tint * alpha, alpha);',\n        '}'\n    ];\n\n    this.init();\n};\n\nPIXI.ComplexPrimitiveShader.prototype.constructor = PIXI.ComplexPrimitiveShader;\n\n/**\n* Initialises the shader.\n* \n* @method init\n*/\nPIXI.ComplexPrimitiveShader.prototype.init = function()\n{\n    var gl = this.gl;\n\n    var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);\n    gl.useProgram(program);\n\n    // get and store the uniforms for the shader\n    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');\n    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');\n    this.tintColor = gl.getUniformLocation(program, 'tint');\n    this.color = gl.getUniformLocation(program, 'color');\n\n    // get and store the attributes\n    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');\n   // this.colorAttribute = gl.getAttribLocation(program, 'aColor');\n\n    this.attributes = [this.aVertexPosition, this.colorAttribute];\n\n    this.translationMatrix = gl.getUniformLocation(program, 'translationMatrix');\n    this.alpha = gl.getUniformLocation(program, 'alpha');\n\n    this.program = program;\n};\n\n/**\n* Destroys the shader.\n* \n* @method destroy\n*/\nPIXI.ComplexPrimitiveShader.prototype.destroy = function()\n{\n    this.gl.deleteProgram( this.program );\n    this.uniforms = null;\n    this.gl = null;\n\n    this.attribute = null;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * A set of functions used by the webGL renderer to draw the primitive graphics data\n *\n * @class WebGLGraphics\n * @private\n * @static\n */\nPIXI.WebGLGraphics = function()\n{\n};\n\n/**\n * Renders the graphics object\n *\n * @static\n * @private\n * @method renderGraphics\n * @param graphics {Graphics}\n * @param renderSession {Object}\n */\nPIXI.WebGLGraphics.renderGraphics = function(graphics, renderSession)//projection, offset)\n{\n    var gl = renderSession.gl;\n    var projection = renderSession.projection,\n        offset = renderSession.offset,\n        shader = renderSession.shaderManager.primitiveShader,\n        webGLData;\n\n    if(graphics.dirty)\n    {\n        PIXI.WebGLGraphics.updateGraphics(graphics, gl);\n    }\n\n    var webGL = graphics._webGL[gl.id];\n\n    // This  could be speeded up for sure!\n\n    for (var i = 0; i < webGL.data.length; i++)\n    {\n        if(webGL.data[i].mode === 1)\n        {\n            webGLData = webGL.data[i];\n\n            renderSession.stencilManager.pushStencil(graphics, webGLData, renderSession);\n\n            // render quad..\n            gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, ( webGLData.indices.length - 4 ) * 2 );\n            \n            renderSession.stencilManager.popStencil(graphics, webGLData, renderSession);\n        }\n        else\n        {\n            webGLData = webGL.data[i];\n           \n\n            renderSession.shaderManager.setShader( shader );//activatePrimitiveShader();\n            shader = renderSession.shaderManager.primitiveShader;\n            gl.uniformMatrix3fv(shader.translationMatrix, false, graphics.worldTransform.toArray(true));\n\n            gl.uniform2f(shader.projectionVector, projection.x, -projection.y);\n            gl.uniform2f(shader.offsetVector, -offset.x, -offset.y);\n\n            gl.uniform3fv(shader.tintColor, PIXI.hex2rgb(graphics.tint));\n\n            gl.uniform1f(shader.alpha, graphics.worldAlpha);\n            \n\n            gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);\n\n            gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 4 * 6, 0);\n            gl.vertexAttribPointer(shader.colorAttribute, 4, gl.FLOAT, false,4 * 6, 2 * 4);\n\n            // set the index buffer!\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);\n            gl.drawElements(gl.TRIANGLE_STRIP,  webGLData.indices.length, gl.UNSIGNED_SHORT, 0 );\n        }\n    }\n};\n\n/**\n * Updates the graphics object\n *\n * @static\n * @private\n * @method updateGraphics\n * @param graphicsData {Graphics} The graphics object to update\n * @param gl {WebGLContext} the current WebGL drawing context\n */\nPIXI.WebGLGraphics.updateGraphics = function(graphics, gl)\n{\n    // get the contexts graphics object\n    var webGL = graphics._webGL[gl.id];\n    // if the graphics object does not exist in the webGL context time to create it!\n    if(!webGL)webGL = graphics._webGL[gl.id] = {lastIndex:0, data:[], gl:gl};\n\n    // flag the graphics as not dirty as we are about to update it...\n    graphics.dirty = false;\n\n    var i;\n\n    // if the user cleared the graphics object we will need to clear every object\n    if(graphics.clearDirty)\n    {\n        graphics.clearDirty = false;\n\n        // lop through and return all the webGLDatas to the object pool so than can be reused later on\n        for (i = 0; i < webGL.data.length; i++)\n        {\n            var graphicsData = webGL.data[i];\n            graphicsData.reset();\n            PIXI.WebGLGraphics.graphicsDataPool.push( graphicsData );\n        }\n\n        // clear the array and reset the index.. \n        webGL.data = [];\n        webGL.lastIndex = 0;\n    }\n    \n    var webGLData;\n    \n    // loop through the graphics datas and construct each one..\n    // if the object is a complex fill then the new stencil buffer technique will be used\n    // other wise graphics objects will be pushed into a batch..\n    for (i = webGL.lastIndex; i < graphics.graphicsData.length; i++)\n    {\n        var data = graphics.graphicsData[i];\n\n        if(data.type === PIXI.Graphics.POLY)\n        {\n            // need to add the points the the graphics object..\n            data.points = data.shape.points.slice();\n            if(data.shape.closed)\n            {\n                // close the poly if the valu is true!\n                if(data.points[0] !== data.points[data.points.length-2] && data.points[1] !== data.points[data.points.length-1])\n                {\n                    data.points.push(data.points[0], data.points[1]);\n                }\n            }\n\n            // MAKE SURE WE HAVE THE CORRECT TYPE..\n            if(data.fill)\n            {\n                if(data.points.length >= 6)\n                {\n                    if(data.points.length < 6 * 2)\n                    {\n                        webGLData = PIXI.WebGLGraphics.switchMode(webGL, 0);\n                        \n                        var canDrawUsingSimple = PIXI.WebGLGraphics.buildPoly(data, webGLData);\n                   //     console.log(canDrawUsingSimple);\n\n                        if(!canDrawUsingSimple)\n                        {\n                        //    console.log(\"<>>>\")\n                            webGLData = PIXI.WebGLGraphics.switchMode(webGL, 1);\n                            PIXI.WebGLGraphics.buildComplexPoly(data, webGLData);\n                        }\n                        \n                    }\n                    else\n                    {\n                        webGLData = PIXI.WebGLGraphics.switchMode(webGL, 1);\n                        PIXI.WebGLGraphics.buildComplexPoly(data, webGLData);\n                    }\n                }\n            }\n\n            if(data.lineWidth > 0)\n            {\n                webGLData = PIXI.WebGLGraphics.switchMode(webGL, 0);\n                PIXI.WebGLGraphics.buildLine(data, webGLData);\n\n            }\n        }\n        else\n        {\n            webGLData = PIXI.WebGLGraphics.switchMode(webGL, 0);\n            \n            if(data.type === PIXI.Graphics.RECT)\n            {\n                PIXI.WebGLGraphics.buildRectangle(data, webGLData);\n            }\n            else if(data.type === PIXI.Graphics.CIRC || data.type === PIXI.Graphics.ELIP)\n            {\n                PIXI.WebGLGraphics.buildCircle(data, webGLData);\n            }\n            else if(data.type === PIXI.Graphics.RREC)\n            {\n                PIXI.WebGLGraphics.buildRoundedRectangle(data, webGLData);\n            }\n        }\n\n        webGL.lastIndex++;\n    }\n\n    // upload all the dirty data...\n    for (i = 0; i < webGL.data.length; i++)\n    {\n        webGLData = webGL.data[i];\n        if(webGLData.dirty)webGLData.upload();\n    }\n};\n\n/**\n * @static\n * @private\n * @method switchMode\n * @param webGL {WebGLContext}\n * @param type {Number}\n */\nPIXI.WebGLGraphics.switchMode = function(webGL, type)\n{\n    var webGLData;\n\n    if(!webGL.data.length)\n    {\n        webGLData = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(webGL.gl);\n        webGLData.mode = type;\n        webGL.data.push(webGLData);\n    }\n    else\n    {\n        webGLData = webGL.data[webGL.data.length-1];\n\n        if(webGLData.mode !== type || type === 1)\n        {\n            webGLData = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(webGL.gl);\n            webGLData.mode = type;\n            webGL.data.push(webGLData);\n        }\n    }\n\n    webGLData.dirty = true;\n\n    return webGLData;\n};\n\n/**\n * Builds a rectangle to draw\n *\n * @static\n * @private\n * @method buildRectangle\n * @param graphicsData {Graphics} The graphics object containing all the necessary properties\n * @param webGLData {Object}\n */\nPIXI.WebGLGraphics.buildRectangle = function(graphicsData, webGLData)\n{\n    // --- //\n    // need to convert points to a nice regular data\n    //\n    var rectData = graphicsData.shape;\n    var x = rectData.x;\n    var y = rectData.y;\n    var width = rectData.width;\n    var height = rectData.height;\n\n    if(graphicsData.fill)\n    {\n        var color = PIXI.hex2rgb(graphicsData.fillColor);\n        var alpha = graphicsData.fillAlpha;\n\n        var r = color[0] * alpha;\n        var g = color[1] * alpha;\n        var b = color[2] * alpha;\n\n        var verts = webGLData.points;\n        var indices = webGLData.indices;\n\n        var vertPos = verts.length/6;\n\n        // start\n        verts.push(x, y);\n        verts.push(r, g, b, alpha);\n\n        verts.push(x + width, y);\n        verts.push(r, g, b, alpha);\n\n        verts.push(x , y + height);\n        verts.push(r, g, b, alpha);\n\n        verts.push(x + width, y + height);\n        verts.push(r, g, b, alpha);\n\n        // insert 2 dead triangles..\n        indices.push(vertPos, vertPos, vertPos+1, vertPos+2, vertPos+3, vertPos+3);\n    }\n\n    if(graphicsData.lineWidth)\n    {\n        var tempPoints = graphicsData.points;\n\n        graphicsData.points = [x, y,\n                  x + width, y,\n                  x + width, y + height,\n                  x, y + height,\n                  x, y];\n\n\n        PIXI.WebGLGraphics.buildLine(graphicsData, webGLData);\n\n        graphicsData.points = tempPoints;\n    }\n};\n\n/**\n * Builds a rounded rectangle to draw\n *\n * @static\n * @private\n * @method buildRoundedRectangle\n * @param graphicsData {Graphics} The graphics object containing all the necessary properties\n * @param webGLData {Object}\n */\nPIXI.WebGLGraphics.buildRoundedRectangle = function(graphicsData, webGLData)\n{\n    var rrectData = graphicsData.shape;\n    var x = rrectData.x;\n    var y = rrectData.y;\n    var width = rrectData.width;\n    var height = rrectData.height;\n\n    var radius = rrectData.radius;\n\n    var recPoints = [];\n    recPoints.push(x, y + radius);\n    recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x, y + height - radius, x, y + height, x + radius, y + height));\n    recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x + width - radius, y + height, x + width, y + height, x + width, y + height - radius));\n    recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x + width, y + radius, x + width, y, x + width - radius, y));\n    recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x + radius, y, x, y, x, y + radius));\n\n    if (graphicsData.fill) {\n        var color = PIXI.hex2rgb(graphicsData.fillColor);\n        var alpha = graphicsData.fillAlpha;\n\n        var r = color[0] * alpha;\n        var g = color[1] * alpha;\n        var b = color[2] * alpha;\n\n        var verts = webGLData.points;\n        var indices = webGLData.indices;\n\n        var vecPos = verts.length/6;\n\n        var triangles = PIXI.PolyK.Triangulate(recPoints);\n\n        var i = 0;\n        for (i = 0; i < triangles.length; i+=3)\n        {\n            indices.push(triangles[i] + vecPos);\n            indices.push(triangles[i] + vecPos);\n            indices.push(triangles[i+1] + vecPos);\n            indices.push(triangles[i+2] + vecPos);\n            indices.push(triangles[i+2] + vecPos);\n        }\n\n        for (i = 0; i < recPoints.length; i++)\n        {\n            verts.push(recPoints[i], recPoints[++i], r, g, b, alpha);\n        }\n    }\n\n    if (graphicsData.lineWidth) {\n        var tempPoints = graphicsData.points;\n\n        graphicsData.points = recPoints;\n\n        PIXI.WebGLGraphics.buildLine(graphicsData, webGLData);\n\n        graphicsData.points = tempPoints;\n    }\n};\n\n/**\n * Calculate the points for a quadratic bezier curve. (helper function..)\n * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n *\n * @static\n * @private\n * @method quadraticBezierCurve\n * @param fromX {Number} Origin point x\n * @param fromY {Number} Origin point x\n * @param cpX {Number} Control point x\n * @param cpY {Number} Control point y\n * @param toX {Number} Destination point x\n * @param toY {Number} Destination point y\n * @return {Array<Number>}\n */\nPIXI.WebGLGraphics.quadraticBezierCurve = function(fromX, fromY, cpX, cpY, toX, toY) {\n\n    var xa,\n        ya,\n        xb,\n        yb,\n        x,\n        y,\n        n = 20,\n        points = [];\n\n    function getPt(n1 , n2, perc) {\n        var diff = n2 - n1;\n\n        return n1 + ( diff * perc );\n    }\n\n    var j = 0;\n    for (var i = 0; i <= n; i++ )\n    {\n        j = i / n;\n\n        // The Green Line\n        xa = getPt( fromX , cpX , j );\n        ya = getPt( fromY , cpY , j );\n        xb = getPt( cpX , toX , j );\n        yb = getPt( cpY , toY , j );\n\n        // The Black Dot\n        x = getPt( xa , xb , j );\n        y = getPt( ya , yb , j );\n\n        points.push(x, y);\n    }\n    return points;\n};\n\n/**\n * Builds a circle to draw\n *\n * @static\n * @private\n * @method buildCircle\n * @param graphicsData {Graphics} The graphics object to draw\n * @param webGLData {Object}\n */\nPIXI.WebGLGraphics.buildCircle = function(graphicsData, webGLData)\n{\n    // need to convert points to a nice regular data\n    var circleData = graphicsData.shape;\n    var x = circleData.x;\n    var y = circleData.y;\n    var width;\n    var height;\n    \n    // TODO - bit hacky??\n    if(graphicsData.type === PIXI.Graphics.CIRC)\n    {\n        width = circleData.radius;\n        height = circleData.radius;\n    }\n    else\n    {\n        width = circleData.width;\n        height = circleData.height;\n    }\n\n    var totalSegs = 40;\n    var seg = (Math.PI * 2) / totalSegs ;\n\n    var i = 0;\n\n    if(graphicsData.fill)\n    {\n        var color = PIXI.hex2rgb(graphicsData.fillColor);\n        var alpha = graphicsData.fillAlpha;\n\n        var r = color[0] * alpha;\n        var g = color[1] * alpha;\n        var b = color[2] * alpha;\n\n        var verts = webGLData.points;\n        var indices = webGLData.indices;\n\n        var vecPos = verts.length/6;\n\n        indices.push(vecPos);\n\n        for (i = 0; i < totalSegs + 1 ; i++)\n        {\n            verts.push(x,y, r, g, b, alpha);\n\n            verts.push(x + Math.sin(seg * i) * width,\n                       y + Math.cos(seg * i) * height,\n                       r, g, b, alpha);\n\n            indices.push(vecPos++, vecPos++);\n        }\n\n        indices.push(vecPos-1);\n    }\n\n    if(graphicsData.lineWidth)\n    {\n        var tempPoints = graphicsData.points;\n\n        graphicsData.points = [];\n\n        for (i = 0; i < totalSegs + 1; i++)\n        {\n            graphicsData.points.push(x + Math.sin(seg * i) * width,\n                                     y + Math.cos(seg * i) * height);\n        }\n\n        PIXI.WebGLGraphics.buildLine(graphicsData, webGLData);\n\n        graphicsData.points = tempPoints;\n    }\n};\n\n/**\n * Builds a line to draw\n *\n * @static\n * @private\n * @method buildLine\n * @param graphicsData {Graphics} The graphics object containing all the necessary properties\n * @param webGLData {Object}\n */\nPIXI.WebGLGraphics.buildLine = function(graphicsData, webGLData)\n{\n    // TODO OPTIMISE!\n    var i = 0;\n    var points = graphicsData.points;\n    if(points.length === 0)return;\n\n    // if the line width is an odd number add 0.5 to align to a whole pixel\n    if(graphicsData.lineWidth%2)\n    {\n        for (i = 0; i < points.length; i++) {\n            points[i] += 0.5;\n        }\n    }\n\n    // get first and last point.. figure out the middle!\n    var firstPoint = new PIXI.Point( points[0], points[1] );\n    var lastPoint = new PIXI.Point( points[points.length - 2], points[points.length - 1] );\n\n    // if the first point is the last point - gonna have issues :)\n    if(firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y)\n    {\n        // need to clone as we are going to slightly modify the shape..\n        points = points.slice();\n\n        points.pop();\n        points.pop();\n\n        lastPoint = new PIXI.Point( points[points.length - 2], points[points.length - 1] );\n\n        var midPointX = lastPoint.x + (firstPoint.x - lastPoint.x) *0.5;\n        var midPointY = lastPoint.y + (firstPoint.y - lastPoint.y) *0.5;\n\n        points.unshift(midPointX, midPointY);\n        points.push(midPointX, midPointY);\n    }\n\n    var verts = webGLData.points;\n    var indices = webGLData.indices;\n    var length = points.length / 2;\n    var indexCount = points.length;\n    var indexStart = verts.length/6;\n\n    // DRAW the Line\n    var width = graphicsData.lineWidth / 2;\n\n    // sort color\n    var color = PIXI.hex2rgb(graphicsData.lineColor);\n    var alpha = graphicsData.lineAlpha;\n    var r = color[0] * alpha;\n    var g = color[1] * alpha;\n    var b = color[2] * alpha;\n\n    var px, py, p1x, p1y, p2x, p2y, p3x, p3y;\n    var perpx, perpy, perp2x, perp2y, perp3x, perp3y;\n    var a1, b1, c1, a2, b2, c2;\n    var denom, pdist, dist;\n\n    p1x = points[0];\n    p1y = points[1];\n\n    p2x = points[2];\n    p2y = points[3];\n\n    perpx = -(p1y - p2y);\n    perpy =  p1x - p2x;\n\n    dist = Math.sqrt(perpx*perpx + perpy*perpy);\n\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    // start\n    verts.push(p1x - perpx , p1y - perpy,\n                r, g, b, alpha);\n\n    verts.push(p1x + perpx , p1y + perpy,\n                r, g, b, alpha);\n\n    for (i = 1; i < length-1; i++)\n    {\n        p1x = points[(i-1)*2];\n        p1y = points[(i-1)*2 + 1];\n\n        p2x = points[(i)*2];\n        p2y = points[(i)*2 + 1];\n\n        p3x = points[(i+1)*2];\n        p3y = points[(i+1)*2 + 1];\n\n        perpx = -(p1y - p2y);\n        perpy = p1x - p2x;\n\n        dist = Math.sqrt(perpx*perpx + perpy*perpy);\n        perpx /= dist;\n        perpy /= dist;\n        perpx *= width;\n        perpy *= width;\n\n        perp2x = -(p2y - p3y);\n        perp2y = p2x - p3x;\n\n        dist = Math.sqrt(perp2x*perp2x + perp2y*perp2y);\n        perp2x /= dist;\n        perp2y /= dist;\n        perp2x *= width;\n        perp2y *= width;\n\n        a1 = (-perpy + p1y) - (-perpy + p2y);\n        b1 = (-perpx + p2x) - (-perpx + p1x);\n        c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);\n        a2 = (-perp2y + p3y) - (-perp2y + p2y);\n        b2 = (-perp2x + p2x) - (-perp2x + p3x);\n        c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);\n\n        denom = a1*b2 - a2*b1;\n\n        if(Math.abs(denom) < 0.1 )\n        {\n\n            denom+=10.1;\n            verts.push(p2x - perpx , p2y - perpy,\n                r, g, b, alpha);\n\n            verts.push(p2x + perpx , p2y + perpy,\n                r, g, b, alpha);\n\n            continue;\n        }\n\n        px = (b1*c2 - b2*c1)/denom;\n        py = (a2*c1 - a1*c2)/denom;\n\n\n        pdist = (px -p2x) * (px -p2x) + (py -p2y) + (py -p2y);\n\n\n        if(pdist > 140 * 140)\n        {\n            perp3x = perpx - perp2x;\n            perp3y = perpy - perp2y;\n\n            dist = Math.sqrt(perp3x*perp3x + perp3y*perp3y);\n            perp3x /= dist;\n            perp3y /= dist;\n            perp3x *= width;\n            perp3y *= width;\n\n            verts.push(p2x - perp3x, p2y -perp3y);\n            verts.push(r, g, b, alpha);\n\n            verts.push(p2x + perp3x, p2y +perp3y);\n            verts.push(r, g, b, alpha);\n\n            verts.push(p2x - perp3x, p2y -perp3y);\n            verts.push(r, g, b, alpha);\n\n            indexCount++;\n        }\n        else\n        {\n\n            verts.push(px , py);\n            verts.push(r, g, b, alpha);\n\n            verts.push(p2x - (px-p2x), p2y - (py - p2y));\n            verts.push(r, g, b, alpha);\n        }\n    }\n\n    p1x = points[(length-2)*2];\n    p1y = points[(length-2)*2 + 1];\n\n    p2x = points[(length-1)*2];\n    p2y = points[(length-1)*2 + 1];\n\n    perpx = -(p1y - p2y);\n    perpy = p1x - p2x;\n\n    dist = Math.sqrt(perpx*perpx + perpy*perpy);\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    verts.push(p2x - perpx , p2y - perpy);\n    verts.push(r, g, b, alpha);\n\n    verts.push(p2x + perpx , p2y + perpy);\n    verts.push(r, g, b, alpha);\n\n    indices.push(indexStart);\n\n    for (i = 0; i < indexCount; i++)\n    {\n        indices.push(indexStart++);\n    }\n\n    indices.push(indexStart-1);\n};\n\n/**\n * Builds a complex polygon to draw\n *\n * @static\n * @private\n * @method buildComplexPoly\n * @param graphicsData {Graphics} The graphics object containing all the necessary properties\n * @param webGLData {Object}\n */\nPIXI.WebGLGraphics.buildComplexPoly = function(graphicsData, webGLData)\n{\n    //TODO - no need to copy this as it gets turned into a FLoat32Array anyways..\n    var points = graphicsData.points.slice();\n    if(points.length < 6)return;\n\n    // get first and last point.. figure out the middle!\n    var indices = webGLData.indices;\n    webGLData.points = points;\n    webGLData.alpha = graphicsData.fillAlpha;\n    webGLData.color = PIXI.hex2rgb(graphicsData.fillColor);\n\n    /*\n        calclate the bounds..\n    */\n    var minX = Infinity;\n    var maxX = -Infinity;\n\n    var minY = Infinity;\n    var maxY = -Infinity;\n\n    var x,y;\n\n    // get size..\n    for (var i = 0; i < points.length; i+=2)\n    {\n        x = points[i];\n        y = points[i+1];\n\n        minX = x < minX ? x : minX;\n        maxX = x > maxX ? x : maxX;\n\n        minY = y < minY ? y : minY;\n        maxY = y > maxY ? y : maxY;\n    }\n\n    // add a quad to the end cos there is no point making another buffer!\n    points.push(minX, minY,\n                maxX, minY,\n                maxX, maxY,\n                minX, maxY);\n\n    // push a quad onto the end.. \n    \n    //TODO - this aint needed!\n    var length = points.length / 2;\n    for (i = 0; i < length; i++)\n    {\n        indices.push( i );\n    }\n\n};\n\n/**\n * Builds a polygon to draw\n *\n * @static\n * @private\n * @method buildPoly\n * @param graphicsData {Graphics} The graphics object containing all the necessary properties\n * @param webGLData {Object}\n */\nPIXI.WebGLGraphics.buildPoly = function(graphicsData, webGLData)\n{\n    var points = graphicsData.points;\n\n    if(points.length < 6)return;\n    // get first and last point.. figure out the middle!\n    var verts = webGLData.points;\n    var indices = webGLData.indices;\n\n    var length = points.length / 2;\n\n    // sort color\n    var color = PIXI.hex2rgb(graphicsData.fillColor);\n    var alpha = graphicsData.fillAlpha;\n    var r = color[0] * alpha;\n    var g = color[1] * alpha;\n    var b = color[2] * alpha;\n\n    var triangles = PIXI.PolyK.Triangulate(points);\n\n    if(!triangles)return false;\n\n    var vertPos = verts.length / 6;\n\n    var i = 0;\n\n    for (i = 0; i < triangles.length; i+=3)\n    {\n        indices.push(triangles[i] + vertPos);\n        indices.push(triangles[i] + vertPos);\n        indices.push(triangles[i+1] + vertPos);\n        indices.push(triangles[i+2] +vertPos);\n        indices.push(triangles[i+2] + vertPos);\n    }\n\n    for (i = 0; i < length; i++)\n    {\n        verts.push(points[i * 2], points[i * 2 + 1],\n                   r, g, b, alpha);\n    }\n\n    return true;\n};\n\nPIXI.WebGLGraphics.graphicsDataPool = [];\n\n/**\n * @class WebGLGraphicsData\n * @private\n * @static\n */\nPIXI.WebGLGraphicsData = function(gl)\n{\n    this.gl = gl;\n\n    //TODO does this need to be split before uploding??\n    this.color = [0,0,0]; // color split!\n    this.points = [];\n    this.indices = [];\n    this.lastIndex = 0;\n    this.buffer = gl.createBuffer();\n    this.indexBuffer = gl.createBuffer();\n    this.mode = 1;\n    this.alpha = 1;\n    this.dirty = true;\n};\n\n/**\n * @method reset\n */\nPIXI.WebGLGraphicsData.prototype.reset = function()\n{\n    this.points = [];\n    this.indices = [];\n    this.lastIndex = 0;\n};\n\n/**\n * @method upload\n */\nPIXI.WebGLGraphicsData.prototype.upload = function()\n{\n    var gl = this.gl;\n\n//    this.lastIndex = graphics.graphicsData.length;\n    this.glPoints = new PIXI.Float32Array(this.points);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, this.glPoints, gl.STATIC_DRAW);\n\n    this.glIndicies = new PIXI.Uint16Array(this.indices);\n\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.glIndicies, gl.STATIC_DRAW);\n\n    this.dirty = false;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\nPIXI.glContexts = []; // this is where we store the webGL contexts for easy access.\nPIXI.instances = [];\n\n/**\n * The WebGLRenderer draws the stage and all its content onto a webGL enabled canvas. This renderer\n * should be used for browsers that support webGL. This Render works by automatically managing webGLBatchs.\n * So no need for Sprite Batches or Sprite Clouds.\n * Don't forget to add the view to your DOM or you will not see anything :)\n *\n * @class WebGLRenderer\n * @constructor\n * @param [width=0] {Number} the width of the canvas view\n * @param [height=0] {Number} the height of the canvas view\n * @param [options] {Object} The optional renderer parameters\n * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional\n * @param [options.transparent=false] {Boolean} If the render view is transparent, default false\n * @param [options.autoResize=false] {Boolean} If the render view is automatically resized, default false\n * @param [options.antialias=false] {Boolean} sets antialias (only applicable in chrome at the moment)\n * @param [options.preserveDrawingBuffer=false] {Boolean} enables drawing buffer preservation, enable this if you need to call toDataUrl on the webgl context\n * @param [options.resolution=1] {Number} the resolution of the renderer retina would be 2\n */\nPIXI.WebGLRenderer = function(width, height, options)\n{\n    if(options)\n    {\n        for (var i in PIXI.defaultRenderOptions)\n        {\n            if (typeof options[i] === 'undefined') options[i] = PIXI.defaultRenderOptions[i];\n        }\n    }\n    else\n    {\n        options = PIXI.defaultRenderOptions;\n    }\n\n    if(!PIXI.defaultRenderer)\n    {\n        PIXI.sayHello('webGL');\n        PIXI.defaultRenderer = this;\n    }\n\n    /**\n     * @property type\n     * @type Number\n     */\n    this.type = PIXI.WEBGL_RENDERER;\n\n    /**\n     * The resolution of the renderer\n     *\n     * @property resolution\n     * @type Number\n     * @default 1\n     */\n    this.resolution = options.resolution;\n\n    // do a catch.. only 1 webGL renderer..\n\n    /**\n     * Whether the render view is transparent\n     *\n     * @property transparent\n     * @type Boolean\n     */\n    this.transparent = options.transparent;\n\n    /**\n     * Whether the render view should be resized automatically\n     *\n     * @property autoResize\n     * @type Boolean\n     */\n    this.autoResize = options.autoResize || false;\n\n    /**\n     * The value of the preserveDrawingBuffer flag affects whether or not the contents of the stencil buffer is retained after rendering.\n     *\n     * @property preserveDrawingBuffer\n     * @type Boolean\n     */\n    this.preserveDrawingBuffer = options.preserveDrawingBuffer;\n\n    /**\n     * This sets if the WebGLRenderer will clear the context texture or not before the new render pass. If true:\n     * If the Stage is NOT transparent, Pixi will clear to alpha (0, 0, 0, 0).\n     * If the Stage is transparent, Pixi will clear to the target Stage's background color.\n     * Disable this by setting this to false. For example: if your game has a canvas filling background image, you often don't need this set.\n     *\n     * @property clearBeforeRender\n     * @type Boolean\n     * @default\n     */\n    this.clearBeforeRender = options.clearBeforeRender;\n\n    /**\n     * The width of the canvas view\n     *\n     * @property width\n     * @type Number\n     * @default 800\n     */\n    this.width = width || 800;\n\n    /**\n     * The height of the canvas view\n     *\n     * @property height\n     * @type Number\n     * @default 600\n     */\n    this.height = height || 600;\n\n    /**\n     * The canvas element that everything is drawn to\n     *\n     * @property view\n     * @type HTMLCanvasElement\n     */\n    this.view = options.view || document.createElement( 'canvas' );\n\n    // deal with losing context..\n\n    /**\n     * @property contextLostBound\n     * @type Function\n     */\n    this.contextLostBound = this.handleContextLost.bind(this);\n\n    /**\n     * @property contextRestoredBound\n     * @type Function\n     */\n    this.contextRestoredBound = this.handleContextRestored.bind(this);\n\n    this.view.addEventListener('webglcontextlost', this.contextLostBound, false);\n    this.view.addEventListener('webglcontextrestored', this.contextRestoredBound, false);\n\n    /**\n     * @property _contextOptions\n     * @type Object\n     * @private\n     */\n    this._contextOptions = {\n        alpha: this.transparent,\n        antialias: options.antialias, // SPEED UP??\n        premultipliedAlpha:this.transparent && this.transparent !== 'notMultiplied',\n        stencil:true,\n        preserveDrawingBuffer: options.preserveDrawingBuffer\n    };\n\n    /**\n     * @property projection\n     * @type Point\n     */\n    this.projection = new PIXI.Point();\n\n    /**\n     * @property offset\n     * @type Point\n     */\n    this.offset = new PIXI.Point(0, 0);\n\n    // time to create the render managers! each one focuses on managing a state in webGL\n\n    /**\n     * Deals with managing the shader programs and their attribs\n     * @property shaderManager\n     * @type WebGLShaderManager\n     */\n    this.shaderManager = new PIXI.WebGLShaderManager();\n\n    /**\n     * Manages the rendering of sprites\n     * @property spriteBatch\n     * @type WebGLSpriteBatch\n     */\n    this.spriteBatch = new PIXI.WebGLSpriteBatch();\n\n    /**\n     * Manages the masks using the stencil buffer\n     * @property maskManager\n     * @type WebGLMaskManager\n     */\n    this.maskManager = new PIXI.WebGLMaskManager();\n\n    /**\n     * Manages the filters\n     * @property filterManager\n     * @type WebGLFilterManager\n     */\n    this.filterManager = new PIXI.WebGLFilterManager();\n\n    /**\n     * Manages the stencil buffer\n     * @property stencilManager\n     * @type WebGLStencilManager\n     */\n    this.stencilManager = new PIXI.WebGLStencilManager();\n\n    /**\n     * Manages the blendModes\n     * @property blendModeManager\n     * @type WebGLBlendModeManager\n     */\n    this.blendModeManager = new PIXI.WebGLBlendModeManager();\n\n    /**\n     * TODO remove\n     * @property renderSession\n     * @type Object\n     */\n    this.renderSession = {};\n    this.renderSession.gl = this.gl;\n    this.renderSession.drawCount = 0;\n    this.renderSession.shaderManager = this.shaderManager;\n    this.renderSession.maskManager = this.maskManager;\n    this.renderSession.filterManager = this.filterManager;\n    this.renderSession.blendModeManager = this.blendModeManager;\n    this.renderSession.spriteBatch = this.spriteBatch;\n    this.renderSession.stencilManager = this.stencilManager;\n    this.renderSession.renderer = this;\n    this.renderSession.resolution = this.resolution;\n\n    // time init the context..\n    this.initContext();\n\n    // map some webGL blend modes..\n    this.mapBlendModes();\n};\n\n// constructor\nPIXI.WebGLRenderer.prototype.constructor = PIXI.WebGLRenderer;\n\n/**\n* @method initContext\n*/\nPIXI.WebGLRenderer.prototype.initContext = function()\n{\n    var gl = this.view.getContext('webgl', this._contextOptions) || this.view.getContext('experimental-webgl', this._contextOptions);\n    this.gl = gl;\n\n    if (!gl) {\n        // fail, not able to get a context\n        throw new Error('This browser does not support webGL. Try using the canvas renderer');\n    }\n\n    this.glContextId = gl.id = PIXI.WebGLRenderer.glContextId ++;\n\n    PIXI.glContexts[this.glContextId] = gl;\n\n    PIXI.instances[this.glContextId] = this;\n\n    // set up the default pixi settings..\n    gl.disable(gl.DEPTH_TEST);\n    gl.disable(gl.CULL_FACE);\n    gl.enable(gl.BLEND);\n\n    // need to set the context for all the managers...\n    this.shaderManager.setContext(gl);\n    this.spriteBatch.setContext(gl);\n    this.maskManager.setContext(gl);\n    this.filterManager.setContext(gl);\n    this.blendModeManager.setContext(gl);\n    this.stencilManager.setContext(gl);\n\n    this.renderSession.gl = this.gl;\n\n    // now resize and we are good to go!\n    this.resize(this.width, this.height);\n};\n\n/**\n * Renders the stage to its webGL view\n *\n * @method render\n * @param stage {Stage} the Stage element to be rendered\n */\nPIXI.WebGLRenderer.prototype.render = function(stage)\n{\n    // no point rendering if our context has been blown up!\n    if(this.contextLost)return;\n\n    // if rendering a new stage clear the batches..\n    if(this.__stage !== stage)\n    {\n        if(stage.interactive)stage.interactionManager.removeEvents();\n\n        // TODO make this work\n        // dont think this is needed any more?\n        this.__stage = stage;\n    }\n\n    // update the scene graph\n    stage.updateTransform();\n\n    var gl = this.gl;\n\n    // interaction\n    if(stage._interactive)\n    {\n        //need to add some events!\n        if(!stage._interactiveEventsAdded)\n        {\n            stage._interactiveEventsAdded = true;\n            stage.interactionManager.setTarget(this);\n        }\n    }\n    else\n    {\n        if(stage._interactiveEventsAdded)\n        {\n            stage._interactiveEventsAdded = false;\n            stage.interactionManager.setTarget(this);\n        }\n    }\n\n    // -- Does this need to be set every frame? -- //\n    gl.viewport(0, 0, this.width, this.height);\n\n    // make sure we are bound to the main frame buffer\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n    if (this.clearBeforeRender)\n        {\n        if(this.transparent)\n        {\n            gl.clearColor(0, 0, 0, 0);\n        }\n        else\n        {\n            gl.clearColor(stage.backgroundColorSplit[0],stage.backgroundColorSplit[1],stage.backgroundColorSplit[2], 1);\n        }\n\n        gl.clear (gl.COLOR_BUFFER_BIT);\n    }\n\n    this.renderDisplayObject( stage, this.projection );\n};\n\n/**\n * Renders a Display Object.\n *\n * @method renderDisplayObject\n * @param displayObject {DisplayObject} The DisplayObject to render\n * @param projection {Point} The projection\n * @param buffer {Array} a standard WebGL buffer\n */\nPIXI.WebGLRenderer.prototype.renderDisplayObject = function(displayObject, projection, buffer)\n{\n    this.renderSession.blendModeManager.setBlendMode(PIXI.blendModes.NORMAL);\n\n    // reset the render session data..\n    this.renderSession.drawCount = 0;\n\n    // set the default projection\n    this.renderSession.projection = projection;\n\n    //set the default offset\n    this.renderSession.offset = this.offset;\n\n    // start the sprite batch\n    this.spriteBatch.begin(this.renderSession);\n\n    // start the filter manager\n    this.filterManager.begin(this.renderSession, buffer);\n\n    // render the scene!\n    displayObject._renderWebGL(this.renderSession);\n\n    // finish the sprite batch\n    this.spriteBatch.end();\n};\n\n/**\n * Resizes the webGL view to the specified width and height.\n *\n * @method resize\n * @param width {Number} the new width of the webGL view\n * @param height {Number} the new height of the webGL view\n */\nPIXI.WebGLRenderer.prototype.resize = function(width, height)\n{\n    this.width = width * this.resolution;\n    this.height = height * this.resolution;\n\n    this.view.width = this.width;\n    this.view.height = this.height;\n\n    if (this.autoResize) {\n        this.view.style.width = this.width / this.resolution + 'px';\n        this.view.style.height = this.height / this.resolution + 'px';\n    }\n\n    this.gl.viewport(0, 0, this.width, this.height);\n\n    this.projection.x =  this.width / 2 / this.resolution;\n    this.projection.y =  -this.height / 2 / this.resolution;\n};\n\n/**\n * Updates and Creates a WebGL texture for the renderers context.\n *\n * @method updateTexture\n * @param texture {Texture} the texture to update\n */\nPIXI.WebGLRenderer.prototype.updateTexture = function(texture)\n{\n    if(!texture.hasLoaded )return;\n\n    var gl = this.gl;\n\n    if(!texture._glTextures[gl.id])texture._glTextures[gl.id] = gl.createTexture();\n\n    gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);\n\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultipliedAlpha);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.source);\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);\n\n    // reguler...\n    if(!texture._powerOf2)\n    {\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    }\n    else\n    {\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\n    }\n\n    texture._dirty[gl.id] = false;\n\n    return  texture._glTextures[gl.id];\n};\n\n/**\n * Handles a lost webgl context\n *\n * @method handleContextLost\n * @param event {Event}\n * @private\n */\nPIXI.WebGLRenderer.prototype.handleContextLost = function(event)\n{\n    event.preventDefault();\n    this.contextLost = true;\n};\n\n/**\n * Handles a restored webgl context\n *\n * @method handleContextRestored\n * @param event {Event}\n * @private\n */\nPIXI.WebGLRenderer.prototype.handleContextRestored = function()\n{\n    this.initContext();\n\n    // empty all the ol gl textures as they are useless now\n    for(var key in PIXI.TextureCache)\n    {\n        var texture = PIXI.TextureCache[key].baseTexture;\n        texture._glTextures = [];\n    }\n\n    this.contextLost = false;\n};\n\n/**\n * Removes everything from the renderer (event listeners, spritebatch, etc...)\n *\n * @method destroy\n */\nPIXI.WebGLRenderer.prototype.destroy = function()\n{\n    // remove listeners\n    this.view.removeEventListener('webglcontextlost', this.contextLostBound);\n    this.view.removeEventListener('webglcontextrestored', this.contextRestoredBound);\n\n    PIXI.glContexts[this.glContextId] = null;\n\n    this.projection = null;\n    this.offset = null;\n\n    // time to create the render managers! each one focuses on managine a state in webGL\n    this.shaderManager.destroy();\n    this.spriteBatch.destroy();\n    this.maskManager.destroy();\n    this.filterManager.destroy();\n\n    this.shaderManager = null;\n    this.spriteBatch = null;\n    this.maskManager = null;\n    this.filterManager = null;\n\n    this.gl = null;\n    this.renderSession = null;\n};\n\n/**\n * Maps Pixi blend modes to WebGL blend modes.\n *\n * @method mapBlendModes\n */\nPIXI.WebGLRenderer.prototype.mapBlendModes = function()\n{\n    var gl = this.gl;\n\n    if(!PIXI.blendModesWebGL)\n    {\n        PIXI.blendModesWebGL = [];\n\n        PIXI.blendModesWebGL[PIXI.blendModes.NORMAL]        = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.ADD]           = [gl.SRC_ALPHA, gl.DST_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.MULTIPLY]      = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.SCREEN]        = [gl.SRC_ALPHA, gl.ONE];\n        PIXI.blendModesWebGL[PIXI.blendModes.OVERLAY]       = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.DARKEN]        = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.LIGHTEN]       = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.COLOR_DODGE]   = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.COLOR_BURN]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.HARD_LIGHT]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.SOFT_LIGHT]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.DIFFERENCE]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.EXCLUSION]     = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.HUE]           = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.SATURATION]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.COLOR]         = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.LUMINOSITY]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n    }\n};\n\nPIXI.WebGLRenderer.glContextId = 0;\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n* @class WebGLBlendModeManager\n* @constructor\n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.WebGLBlendModeManager = function()\n{\n    /**\n     * @property currentBlendMode\n     * @type Number\n     */\n    this.currentBlendMode = 99999;\n};\n\nPIXI.WebGLBlendModeManager.prototype.constructor = PIXI.WebGLBlendModeManager;\n\n/**\n * Sets the WebGL Context.\n *\n * @method setContext\n * @param gl {WebGLContext} the current WebGL drawing context\n */\nPIXI.WebGLBlendModeManager.prototype.setContext = function(gl)\n{\n    this.gl = gl;\n};\n\n/**\n* Sets-up the given blendMode from WebGL's point of view.\n* \n* @method setBlendMode \n* @param blendMode {Number} the blendMode, should be a Pixi const, such as PIXI.BlendModes.ADD\n*/\nPIXI.WebGLBlendModeManager.prototype.setBlendMode = function(blendMode)\n{\n    if(this.currentBlendMode === blendMode)return false;\n\n    this.currentBlendMode = blendMode;\n    \n    var blendModeWebGL = PIXI.blendModesWebGL[this.currentBlendMode];\n    this.gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]);\n    \n    return true;\n};\n\n/**\n* Destroys this object.\n* \n* @method destroy\n*/\nPIXI.WebGLBlendModeManager.prototype.destroy = function()\n{\n    this.gl = null;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n* @class WebGLMaskManager\n* @constructor\n* @private\n*/\nPIXI.WebGLMaskManager = function()\n{\n};\n\nPIXI.WebGLMaskManager.prototype.constructor = PIXI.WebGLMaskManager;\n\n/**\n* Sets the drawing context to the one given in parameter.\n* \n* @method setContext \n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.WebGLMaskManager.prototype.setContext = function(gl)\n{\n    this.gl = gl;\n};\n\n/**\n* Applies the Mask and adds it to the current filter stack.\n* \n* @method pushMask\n* @param maskData {Array}\n* @param renderSession {Object}\n*/\nPIXI.WebGLMaskManager.prototype.pushMask = function(maskData, renderSession)\n{\n    var gl = renderSession.gl;\n\n    if(maskData.dirty)\n    {\n        PIXI.WebGLGraphics.updateGraphics(maskData, gl);\n    }\n\n    if(!maskData._webGL[gl.id].data.length)return;\n\n    renderSession.stencilManager.pushStencil(maskData, maskData._webGL[gl.id].data[0], renderSession);\n};\n\n/**\n* Removes the last filter from the filter stack and doesn't return it.\n* \n* @method popMask\n* @param maskData {Array}\n* @param renderSession {Object} an object containing all the useful parameters\n*/\nPIXI.WebGLMaskManager.prototype.popMask = function(maskData, renderSession)\n{\n    var gl = this.gl;\n    renderSession.stencilManager.popStencil(maskData, maskData._webGL[gl.id].data[0], renderSession);\n};\n\n/**\n* Destroys the mask stack.\n* \n* @method destroy\n*/\nPIXI.WebGLMaskManager.prototype.destroy = function()\n{\n    this.gl = null;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n* @class WebGLStencilManager\n* @constructor\n* @private\n*/\nPIXI.WebGLStencilManager = function()\n{\n    this.stencilStack = [];\n    this.reverse = true;\n    this.count = 0;\n};\n\n/**\n* Sets the drawing context to the one given in parameter.\n* \n* @method setContext \n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.WebGLStencilManager.prototype.setContext = function(gl)\n{\n    this.gl = gl;\n};\n\n/**\n* Applies the Mask and adds it to the current filter stack.\n* \n* @method pushMask\n* @param graphics {Graphics}\n* @param webGLData {Array}\n* @param renderSession {Object}\n*/\nPIXI.WebGLStencilManager.prototype.pushStencil = function(graphics, webGLData, renderSession)\n{\n    var gl = this.gl;\n    this.bindGraphics(graphics, webGLData, renderSession);\n\n    if(this.stencilStack.length === 0)\n    {\n        gl.enable(gl.STENCIL_TEST);\n        gl.clear(gl.STENCIL_BUFFER_BIT);\n        this.reverse = true;\n        this.count = 0;\n    }\n\n    this.stencilStack.push(webGLData);\n\n    var level = this.count;\n\n    gl.colorMask(false, false, false, false);\n\n    gl.stencilFunc(gl.ALWAYS,0,0xFF);\n    gl.stencilOp(gl.KEEP,gl.KEEP,gl.INVERT);\n\n    // draw the triangle strip!\n\n    if(webGLData.mode === 1)\n    {\n        gl.drawElements(gl.TRIANGLE_FAN,  webGLData.indices.length - 4, gl.UNSIGNED_SHORT, 0 );\n       \n        if(this.reverse)\n        {\n            gl.stencilFunc(gl.EQUAL, 0xFF - level, 0xFF);\n            gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);\n        }\n        else\n        {\n            gl.stencilFunc(gl.EQUAL,level, 0xFF);\n            gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);\n        }\n\n        // draw a quad to increment..\n        gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, ( webGLData.indices.length - 4 ) * 2 );\n               \n        if(this.reverse)\n        {\n            gl.stencilFunc(gl.EQUAL,0xFF-(level+1), 0xFF);\n        }\n        else\n        {\n            gl.stencilFunc(gl.EQUAL,level+1, 0xFF);\n        }\n\n        this.reverse = !this.reverse;\n    }\n    else\n    {\n        if(!this.reverse)\n        {\n            gl.stencilFunc(gl.EQUAL, 0xFF - level, 0xFF);\n            gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);\n        }\n        else\n        {\n            gl.stencilFunc(gl.EQUAL,level, 0xFF);\n            gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);\n        }\n\n        gl.drawElements(gl.TRIANGLE_STRIP,  webGLData.indices.length, gl.UNSIGNED_SHORT, 0 );\n\n        if(!this.reverse)\n        {\n            gl.stencilFunc(gl.EQUAL,0xFF-(level+1), 0xFF);\n        }\n        else\n        {\n            gl.stencilFunc(gl.EQUAL,level+1, 0xFF);\n        }\n    }\n\n    gl.colorMask(true, true, true, true);\n    gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP);\n\n    this.count++;\n};\n\n/**\n * TODO this does not belong here!\n * \n * @method bindGraphics\n * @param graphics {Graphics}\n * @param webGLData {Array}\n * @param renderSession {Object}\n */\nPIXI.WebGLStencilManager.prototype.bindGraphics = function(graphics, webGLData, renderSession)\n{\n    //if(this._currentGraphics === graphics)return;\n    this._currentGraphics = graphics;\n\n    var gl = this.gl;\n\n     // bind the graphics object..\n    var projection = renderSession.projection,\n        offset = renderSession.offset,\n        shader;// = renderSession.shaderManager.primitiveShader;\n\n    if(webGLData.mode === 1)\n    {\n        shader = renderSession.shaderManager.complexPrimitiveShader;\n\n        renderSession.shaderManager.setShader( shader );\n\n        gl.uniformMatrix3fv(shader.translationMatrix, false, graphics.worldTransform.toArray(true));\n\n        gl.uniform2f(shader.projectionVector, projection.x, -projection.y);\n        gl.uniform2f(shader.offsetVector, -offset.x, -offset.y);\n\n        gl.uniform3fv(shader.tintColor, PIXI.hex2rgb(graphics.tint));\n        gl.uniform3fv(shader.color, webGLData.color);\n\n        gl.uniform1f(shader.alpha, graphics.worldAlpha * webGLData.alpha);\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);\n\n        gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 4 * 2, 0);\n\n\n        // now do the rest..\n        // set the index buffer!\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);\n    }\n    else\n    {\n        //renderSession.shaderManager.activatePrimitiveShader();\n        shader = renderSession.shaderManager.primitiveShader;\n        renderSession.shaderManager.setShader( shader );\n\n        gl.uniformMatrix3fv(shader.translationMatrix, false, graphics.worldTransform.toArray(true));\n\n        gl.uniform2f(shader.projectionVector, projection.x, -projection.y);\n        gl.uniform2f(shader.offsetVector, -offset.x, -offset.y);\n\n        gl.uniform3fv(shader.tintColor, PIXI.hex2rgb(graphics.tint));\n\n        gl.uniform1f(shader.alpha, graphics.worldAlpha);\n        \n        gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);\n\n        gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 4 * 6, 0);\n        gl.vertexAttribPointer(shader.colorAttribute, 4, gl.FLOAT, false,4 * 6, 2 * 4);\n\n        // set the index buffer!\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);\n    }\n};\n\n/**\n * @method popStencil\n * @param graphics {Graphics}\n * @param webGLData {Array}\n * @param renderSession {Object}\n */\nPIXI.WebGLStencilManager.prototype.popStencil = function(graphics, webGLData, renderSession)\n{\n	var gl = this.gl;\n    this.stencilStack.pop();\n   \n    this.count--;\n\n    if(this.stencilStack.length === 0)\n    {\n        // the stack is empty!\n        gl.disable(gl.STENCIL_TEST);\n\n    }\n    else\n    {\n\n        var level = this.count;\n\n        this.bindGraphics(graphics, webGLData, renderSession);\n\n        gl.colorMask(false, false, false, false);\n    \n        if(webGLData.mode === 1)\n        {\n            this.reverse = !this.reverse;\n\n            if(this.reverse)\n            {\n                gl.stencilFunc(gl.EQUAL, 0xFF - (level+1), 0xFF);\n                gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);\n            }\n            else\n            {\n                gl.stencilFunc(gl.EQUAL,level+1, 0xFF);\n                gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);\n            }\n\n            // draw a quad to increment..\n            gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, ( webGLData.indices.length - 4 ) * 2 );\n            \n            gl.stencilFunc(gl.ALWAYS,0,0xFF);\n            gl.stencilOp(gl.KEEP,gl.KEEP,gl.INVERT);\n\n            // draw the triangle strip!\n            gl.drawElements(gl.TRIANGLE_FAN,  webGLData.indices.length - 4, gl.UNSIGNED_SHORT, 0 );\n           \n            if(!this.reverse)\n            {\n                gl.stencilFunc(gl.EQUAL,0xFF-(level), 0xFF);\n            }\n            else\n            {\n                gl.stencilFunc(gl.EQUAL,level, 0xFF);\n            }\n\n        }\n        else\n        {\n          //  console.log(\"<<>>\")\n            if(!this.reverse)\n            {\n                gl.stencilFunc(gl.EQUAL, 0xFF - (level+1), 0xFF);\n                gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);\n            }\n            else\n            {\n                gl.stencilFunc(gl.EQUAL,level+1, 0xFF);\n                gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);\n            }\n\n            gl.drawElements(gl.TRIANGLE_STRIP,  webGLData.indices.length, gl.UNSIGNED_SHORT, 0 );\n\n            if(!this.reverse)\n            {\n                gl.stencilFunc(gl.EQUAL,0xFF-(level), 0xFF);\n            }\n            else\n            {\n                gl.stencilFunc(gl.EQUAL,level, 0xFF);\n            }\n        }\n\n        gl.colorMask(true, true, true, true);\n        gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP);\n\n\n    }\n};\n\n/**\n* Destroys the mask stack.\n* \n* @method destroy\n*/\nPIXI.WebGLStencilManager.prototype.destroy = function()\n{\n    this.stencilStack = null;\n    this.gl = null;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n* @class WebGLShaderManager\n* @constructor\n* @private\n*/\nPIXI.WebGLShaderManager = function()\n{\n    /**\n     * @property maxAttibs\n     * @type Number\n     */\n    this.maxAttibs = 10;\n\n    /**\n     * @property attribState\n     * @type Array\n     */\n    this.attribState = [];\n\n    /**\n     * @property tempAttribState\n     * @type Array\n     */\n    this.tempAttribState = [];\n\n    for (var i = 0; i < this.maxAttibs; i++)\n    {\n        this.attribState[i] = false;\n    }\n\n    /**\n     * @property stack\n     * @type Array\n     */\n    this.stack = [];\n\n};\n\nPIXI.WebGLShaderManager.prototype.constructor = PIXI.WebGLShaderManager;\n\n/**\n* Initialises the context and the properties.\n* \n* @method setContext \n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.WebGLShaderManager.prototype.setContext = function(gl)\n{\n    this.gl = gl;\n    \n    // the next one is used for rendering primitives\n    this.primitiveShader = new PIXI.PrimitiveShader(gl);\n\n    // the next one is used for rendering triangle strips\n    this.complexPrimitiveShader = new PIXI.ComplexPrimitiveShader(gl);\n\n    // this shader is used for the default sprite rendering\n    this.defaultShader = new PIXI.PixiShader(gl);\n\n    // this shader is used for the fast sprite rendering\n    this.fastShader = new PIXI.PixiFastShader(gl);\n\n    // the next one is used for rendering triangle strips\n    this.stripShader = new PIXI.StripShader(gl);\n    this.setShader(this.defaultShader);\n};\n\n/**\n* Takes the attributes given in parameters.\n* \n* @method setAttribs\n* @param attribs {Array} attribs \n*/\nPIXI.WebGLShaderManager.prototype.setAttribs = function(attribs)\n{\n    // reset temp state\n    var i;\n\n    for (i = 0; i < this.tempAttribState.length; i++)\n    {\n        this.tempAttribState[i] = false;\n    }\n\n    // set the new attribs\n    for (i = 0; i < attribs.length; i++)\n    {\n        var attribId = attribs[i];\n        this.tempAttribState[attribId] = true;\n    }\n\n    var gl = this.gl;\n\n    for (i = 0; i < this.attribState.length; i++)\n    {\n        if(this.attribState[i] !== this.tempAttribState[i])\n        {\n            this.attribState[i] = this.tempAttribState[i];\n\n            if(this.tempAttribState[i])\n            {\n                gl.enableVertexAttribArray(i);\n            }\n            else\n            {\n                gl.disableVertexAttribArray(i);\n            }\n        }\n    }\n};\n\n/**\n* Sets the current shader.\n* \n* @method setShader\n* @param shader {Any}\n*/\nPIXI.WebGLShaderManager.prototype.setShader = function(shader)\n{\n    if(this._currentId === shader._UID)return false;\n    \n    this._currentId = shader._UID;\n\n    this.currentShader = shader;\n\n    this.gl.useProgram(shader.program);\n    this.setAttribs(shader.attributes);\n\n    return true;\n};\n\n/**\n* Destroys this object.\n* \n* @method destroy\n*/\nPIXI.WebGLShaderManager.prototype.destroy = function()\n{\n    this.attribState = null;\n\n    this.tempAttribState = null;\n\n    this.primitiveShader.destroy();\n\n    this.complexPrimitiveShader.destroy();\n\n    this.defaultShader.destroy();\n\n    this.fastShader.destroy();\n\n    this.stripShader.destroy();\n\n    this.gl = null;\n};\n\n/**\n * @author Mat Groves\n * \n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original pixi version!\n *\n * Heavily inspired by LibGDX's WebGLSpriteBatch:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/WebGLSpriteBatch.java\n */\n\n /**\n *\n * @class WebGLSpriteBatch\n * @private\n * @constructor\n */\nPIXI.WebGLSpriteBatch = function()\n{\n    /**\n     * @property vertSize\n     * @type Number\n     */\n    this.vertSize = 6;\n\n    /**\n     * The number of images in the SpriteBatch before it flushes\n     * @property size\n     * @type Number\n     */\n    this.size = 2000;//Math.pow(2, 16) /  this.vertSize;\n\n    //the total number of floats in our batch\n    var numVerts = this.size * 4 *  this.vertSize;\n    //the total number of indices in our batch\n    var numIndices = this.size * 6;\n\n    /**\n    * Holds the vertices\n    *\n    * @property vertices\n    * @type Float32Array\n    */\n    this.vertices = new PIXI.Float32Array(numVerts);\n\n    /**\n     * Holds the indices\n     *\n     * @property indices\n     * @type Uint16Array\n     */\n    this.indices = new PIXI.Uint16Array(numIndices);\n    \n    /**\n     * @property lastIndexCount\n     * @type Number\n     */\n    this.lastIndexCount = 0;\n\n    for (var i=0, j=0; i < numIndices; i += 6, j += 4)\n    {\n        this.indices[i + 0] = j + 0;\n        this.indices[i + 1] = j + 1;\n        this.indices[i + 2] = j + 2;\n        this.indices[i + 3] = j + 0;\n        this.indices[i + 4] = j + 2;\n        this.indices[i + 5] = j + 3;\n    }\n\n    /**\n     * @property drawing\n     * @type Boolean\n     */\n    this.drawing = false;\n\n    /**\n     * @property currentBatchSize\n     * @type Number\n     */\n    this.currentBatchSize = 0;\n\n    /**\n     * @property currentBaseTexture\n     * @type BaseTexture\n     */\n    this.currentBaseTexture = null;\n\n    /**\n     * @property dirty\n     * @type Boolean\n     */\n    this.dirty = true;\n\n    /**\n     * @property textures\n     * @type Array\n     */\n    this.textures = [];\n\n    /**\n     * @property blendModes\n     * @type Array\n     */\n    this.blendModes = [];\n\n    /**\n     * @property shaders\n     * @type Array\n     */\n    this.shaders = [];\n\n    /**\n     * @property sprites\n     * @type Array\n     */\n    this.sprites = [];\n\n    /**\n     * @property defaultShader\n     * @type AbstractFilter\n     */\n    this.defaultShader = new PIXI.AbstractFilter([\n        'precision lowp float;',\n        'varying vec2 vTextureCoord;',\n        'varying vec4 vColor;',\n        'uniform sampler2D uSampler;',\n        'void main(void) {',\n        '   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;',\n        '}'\n    ]);\n};\n\n/**\n* @method setContext\n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.WebGLSpriteBatch.prototype.setContext = function(gl)\n{\n    this.gl = gl;\n\n    // create a couple of buffers\n    this.vertexBuffer = gl.createBuffer();\n    this.indexBuffer = gl.createBuffer();\n\n    // 65535 is max index, so 65535 / 6 = 10922.\n\n    //upload the index data\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n\n    this.currentBlendMode = 99999;\n\n    var shader = new PIXI.PixiShader(gl);\n\n    shader.fragmentSrc = this.defaultShader.fragmentSrc;\n    shader.uniforms = {};\n    shader.init();\n\n    this.defaultShader.shaders[gl.id] = shader;\n};\n\n/**\n* @method begin\n* @param renderSession {Object} The RenderSession object\n*/\nPIXI.WebGLSpriteBatch.prototype.begin = function(renderSession)\n{\n    this.renderSession = renderSession;\n    this.shader = this.renderSession.shaderManager.defaultShader;\n\n    this.start();\n};\n\n/**\n* @method end\n*/\nPIXI.WebGLSpriteBatch.prototype.end = function()\n{\n    this.flush();\n};\n\n/**\n* @method render\n* @param sprite {Sprite} the sprite to render when using this spritebatch\n*/\nPIXI.WebGLSpriteBatch.prototype.render = function(sprite)\n{\n    var texture = sprite.texture;\n    \n   //TODO set blend modes.. \n    // check texture..\n    if(this.currentBatchSize >= this.size)\n    {\n        this.flush();\n        this.currentBaseTexture = texture.baseTexture;\n    }\n\n    // get the uvs for the texture\n    var uvs = texture._uvs;\n    // if the uvs have not updated then no point rendering just yet!\n    if(!uvs)return;\n\n    // get the sprites current alpha\n    var alpha = sprite.worldAlpha;\n    var tint = sprite.tint;\n\n    var verticies = this.vertices;\n\n    // TODO trim??\n    var aX = sprite.anchor.x;\n    var aY = sprite.anchor.y;\n\n    var w0, w1, h0, h1;\n        \n    if (texture.trim)\n    {\n        // if the sprite is trimmed then we need to add the extra space before transforming the sprite coords..\n        var trim = texture.trim;\n\n        w1 = trim.x - aX * trim.width;\n        w0 = w1 + texture.crop.width;\n\n        h1 = trim.y - aY * trim.height;\n        h0 = h1 + texture.crop.height;\n\n    }\n    else\n    {\n        w0 = (texture.frame.width ) * (1-aX);\n        w1 = (texture.frame.width ) * -aX;\n\n        h0 = texture.frame.height * (1-aY);\n        h1 = texture.frame.height * -aY;\n    }\n\n    var index = this.currentBatchSize * 4 * this.vertSize;\n    \n    var resolution = texture.baseTexture.resolution;\n\n    var worldTransform = sprite.worldTransform;\n\n    var a = worldTransform.a / resolution;\n    var b = worldTransform.b / resolution;\n    var c = worldTransform.c / resolution;\n    var d = worldTransform.d / resolution;\n    var tx = worldTransform.tx;\n    var ty = worldTransform.ty;\n\n\n    // xy\n    verticies[index++] = a * w1 + c * h1 + tx;\n    verticies[index++] = d * h1 + b * w1 + ty;\n    // uv\n    verticies[index++] = uvs.x0;\n    verticies[index++] = uvs.y0;\n    // color\n    verticies[index++] = alpha;\n    verticies[index++] = tint;\n\n    // xy\n    verticies[index++] = a * w0 + c * h1 + tx;\n    verticies[index++] = d * h1 + b * w0 + ty;\n    // uv\n    verticies[index++] = uvs.x1;\n    verticies[index++] = uvs.y1;\n    // color\n    verticies[index++] = alpha;\n    verticies[index++] = tint;\n\n    // xy\n    verticies[index++] = a * w0 + c * h0 + tx;\n    verticies[index++] = d * h0 + b * w0 + ty;\n    // uv\n    verticies[index++] = uvs.x2;\n    verticies[index++] = uvs.y2;\n    // color\n    verticies[index++] = alpha;\n    verticies[index++] = tint;\n\n    // xy\n    verticies[index++] = a * w1 + c * h0 + tx;\n    verticies[index++] = d * h0 + b * w1 + ty;\n    // uv\n    verticies[index++] = uvs.x3;\n    verticies[index++] = uvs.y3;\n    // color\n    verticies[index++] = alpha;\n    verticies[index++] = tint;\n    \n    // increment the batchsize\n    this.sprites[this.currentBatchSize++] = sprite;\n\n};\n\n/**\n* Renders a TilingSprite using the spriteBatch.\n* \n* @method renderTilingSprite\n* @param sprite {TilingSprite} the tilingSprite to render\n*/\nPIXI.WebGLSpriteBatch.prototype.renderTilingSprite = function(tilingSprite)\n{\n    var texture = tilingSprite.tilingTexture;\n\n    // check texture..\n    if(this.currentBatchSize >= this.size)\n    {\n        //return;\n        this.flush();\n        this.currentBaseTexture = texture.baseTexture;\n    }\n\n     // set the textures uvs temporarily\n    // TODO create a separate texture so that we can tile part of a texture\n\n    if(!tilingSprite._uvs)tilingSprite._uvs = new PIXI.TextureUvs();\n\n    var uvs = tilingSprite._uvs;\n\n    tilingSprite.tilePosition.x %= texture.baseTexture.width * tilingSprite.tileScaleOffset.x;\n    tilingSprite.tilePosition.y %= texture.baseTexture.height * tilingSprite.tileScaleOffset.y;\n\n    var offsetX =  tilingSprite.tilePosition.x/(texture.baseTexture.width*tilingSprite.tileScaleOffset.x);\n    var offsetY =  tilingSprite.tilePosition.y/(texture.baseTexture.height*tilingSprite.tileScaleOffset.y);\n\n    var scaleX =  (tilingSprite.width / texture.baseTexture.width)  / (tilingSprite.tileScale.x * tilingSprite.tileScaleOffset.x);\n    var scaleY =  (tilingSprite.height / texture.baseTexture.height) / (tilingSprite.tileScale.y * tilingSprite.tileScaleOffset.y);\n\n    uvs.x0 = 0 - offsetX;\n    uvs.y0 = 0 - offsetY;\n\n    uvs.x1 = (1 * scaleX) - offsetX;\n    uvs.y1 = 0 - offsetY;\n\n    uvs.x2 = (1 * scaleX) - offsetX;\n    uvs.y2 = (1 * scaleY) - offsetY;\n\n    uvs.x3 = 0 - offsetX;\n    uvs.y3 = (1 *scaleY) - offsetY;\n\n    // get the tilingSprites current alpha\n    var alpha = tilingSprite.worldAlpha;\n    var tint = tilingSprite.tint;\n\n    var  verticies = this.vertices;\n\n    var width = tilingSprite.width;\n    var height = tilingSprite.height;\n\n    // TODO trim??\n    var aX = tilingSprite.anchor.x;\n    var aY = tilingSprite.anchor.y;\n    var w0 = width * (1-aX);\n    var w1 = width * -aX;\n\n    var h0 = height * (1-aY);\n    var h1 = height * -aY;\n\n    var index = this.currentBatchSize * 4 * this.vertSize;\n\n    var resolution = texture.baseTexture.resolution;\n\n    var worldTransform = tilingSprite.worldTransform;\n\n    var a = worldTransform.a / resolution;//[0];\n    var b = worldTransform.b / resolution;//[3];\n    var c = worldTransform.c / resolution;//[1];\n    var d = worldTransform.d / resolution;//[4];\n    var tx = worldTransform.tx;//[2];\n    var ty = worldTransform.ty;///[5];\n\n    // xy\n    verticies[index++] = a * w1 + c * h1 + tx;\n    verticies[index++] = d * h1 + b * w1 + ty;\n    // uv\n    verticies[index++] = uvs.x0;\n    verticies[index++] = uvs.y0;\n    // color\n    verticies[index++] = alpha;\n    verticies[index++] = tint;\n\n    // xy\n    verticies[index++] = (a * w0 + c * h1 + tx);\n    verticies[index++] = d * h1 + b * w0 + ty;\n    // uv\n    verticies[index++] = uvs.x1;\n    verticies[index++] = uvs.y1;\n    // color\n    verticies[index++] = alpha;\n    verticies[index++] = tint;\n    \n    // xy\n    verticies[index++] = a * w0 + c * h0 + tx;\n    verticies[index++] = d * h0 + b * w0 + ty;\n    // uv\n    verticies[index++] = uvs.x2;\n    verticies[index++] = uvs.y2;\n    // color\n    verticies[index++] = alpha;\n    verticies[index++] = tint;\n\n    // xy\n    verticies[index++] = a * w1 + c * h0 + tx;\n    verticies[index++] = d * h0 + b * w1 + ty;\n    // uv\n    verticies[index++] = uvs.x3;\n    verticies[index++] = uvs.y3;\n    // color\n    verticies[index++] = alpha;\n    verticies[index++] = tint;\n\n    // increment the batchsize\n    this.sprites[this.currentBatchSize++] = tilingSprite;\n};\n\n/**\n* Renders the content and empties the current batch.\n*\n* @method flush\n*/\nPIXI.WebGLSpriteBatch.prototype.flush = function()\n{\n    // If the batch is length 0 then return as there is nothing to draw\n    if (this.currentBatchSize===0)return;\n\n    var gl = this.gl;\n    var shader;\n\n    if(this.dirty)\n    {\n        this.dirty = false;\n        // bind the main texture\n        gl.activeTexture(gl.TEXTURE0);\n\n        // bind the buffers\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n\n        shader =  this.defaultShader.shaders[gl.id];\n\n        // this is the same for each shader?\n        var stride =  this.vertSize * 4;\n        gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, stride, 0);\n        gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, false, stride, 2 * 4);\n        gl.vertexAttribPointer(shader.colorAttribute, 2, gl.FLOAT, false, stride, 4 * 4);\n    }\n\n    // upload the verts to the buffer  \n    if(this.currentBatchSize > ( this.size * 0.5 ) )\n    {\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);\n    }\n    else\n    {\n        var view = this.vertices.subarray(0, this.currentBatchSize * 4 * this.vertSize);\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);\n    }\n\n    var nextTexture, nextBlendMode, nextShader;\n    var batchSize = 0;\n    var start = 0;\n\n    var currentBaseTexture = null;\n    var currentBlendMode = this.renderSession.blendModeManager.currentBlendMode;\n    var currentShader = null;\n\n    var blendSwap = false;\n    var shaderSwap = false;\n    var sprite;\n\n    for (var i = 0, j = this.currentBatchSize; i < j; i++) {\n        \n        sprite = this.sprites[i];\n\n        nextTexture = sprite.texture.baseTexture;\n        nextBlendMode = sprite.blendMode;\n        nextShader = sprite.shader || this.defaultShader;\n\n        blendSwap = currentBlendMode !== nextBlendMode;\n        shaderSwap = currentShader !== nextShader; // should I use _UIDS???\n\n        if(currentBaseTexture !== nextTexture || blendSwap || shaderSwap)\n        {\n            this.renderBatch(currentBaseTexture, batchSize, start);\n\n            start = i;\n            batchSize = 0;\n            currentBaseTexture = nextTexture;\n\n            if( blendSwap )\n            {\n                currentBlendMode = nextBlendMode;\n                this.renderSession.blendModeManager.setBlendMode( currentBlendMode );\n            }\n\n            if( shaderSwap )\n            {\n                currentShader = nextShader;\n                \n                shader = currentShader.shaders[gl.id];\n\n                if(!shader)\n                {\n                    shader = new PIXI.PixiShader(gl);\n\n                    shader.fragmentSrc =currentShader.fragmentSrc;\n                    shader.uniforms =currentShader.uniforms;\n                    shader.init();\n\n                    currentShader.shaders[gl.id] = shader;\n                }\n\n                // set shader function???\n                this.renderSession.shaderManager.setShader(shader);\n\n                if(shader.dirty)shader.syncUniforms();\n                \n                // both thease only need to be set if they are changing..\n                // set the projection\n                var projection = this.renderSession.projection;\n                gl.uniform2f(shader.projectionVector, projection.x, projection.y);\n\n                // TODO - this is temprorary!\n                var offsetVector = this.renderSession.offset;\n                gl.uniform2f(shader.offsetVector, offsetVector.x, offsetVector.y);\n\n                // set the pointers\n            }\n        }\n\n        batchSize++;\n    }\n\n    this.renderBatch(currentBaseTexture, batchSize, start);\n\n    // then reset the batch!\n    this.currentBatchSize = 0;\n};\n\n/**\n* @method renderBatch\n* @param texture {Texture}\n* @param size {Number}\n* @param startIndex {Number}\n*/\nPIXI.WebGLSpriteBatch.prototype.renderBatch = function(texture, size, startIndex)\n{\n    if(size === 0)return;\n\n    var gl = this.gl;\n\n    // check if a texture is dirty..\n    if(texture._dirty[gl.id])\n    {\n        this.renderSession.renderer.updateTexture(texture);\n    }\n    else\n    {\n        // bind the current texture\n        gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);\n    }\n\n    // now draw those suckas!\n    gl.drawElements(gl.TRIANGLES, size * 6, gl.UNSIGNED_SHORT, startIndex * 6 * 2);\n    \n    // increment the draw count\n    this.renderSession.drawCount++;\n};\n\n/**\n* @method stop\n*/\nPIXI.WebGLSpriteBatch.prototype.stop = function()\n{\n    this.flush();\n    this.dirty = true;\n};\n\n/**\n* @method start\n*/\nPIXI.WebGLSpriteBatch.prototype.start = function()\n{\n    this.dirty = true;\n};\n\n/**\n* Destroys the SpriteBatch.\n* \n* @method destroy\n*/\nPIXI.WebGLSpriteBatch.prototype.destroy = function()\n{\n    this.vertices = null;\n    this.indices = null;\n    \n    this.gl.deleteBuffer( this.vertexBuffer );\n    this.gl.deleteBuffer( this.indexBuffer );\n    \n    this.currentBaseTexture = null;\n    \n    this.gl = null;\n};\n\n/**\n * @author Mat Groves\n * \n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original pixi version!\n *\n * Heavily inspired by LibGDX's WebGLSpriteBatch:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/WebGLSpriteBatch.java\n */\n\n/**\n* @class WebGLFastSpriteBatch\n* @constructor\n*/\nPIXI.WebGLFastSpriteBatch = function(gl)\n{\n    /**\n     * @property vertSize\n     * @type Number\n     */\n    this.vertSize = 10;\n\n    /**\n     * @property maxSize\n     * @type Number\n     */\n    this.maxSize = 6000;//Math.pow(2, 16) /  this.vertSize;\n\n    /**\n     * @property size\n     * @type Number\n     */\n    this.size = this.maxSize;\n\n    //the total number of floats in our batch\n    var numVerts = this.size * 4 *  this.vertSize;\n\n    //the total number of indices in our batch\n    var numIndices = this.maxSize * 6;\n\n    /**\n     * Vertex data\n     * @property vertices\n     * @type Float32Array\n     */\n    this.vertices = new PIXI.Float32Array(numVerts);\n\n    /**\n     * Index data\n     * @property indices\n     * @type Uint16Array\n     */\n    this.indices = new PIXI.Uint16Array(numIndices);\n    \n    /**\n     * @property vertexBuffer\n     * @type Object\n     */\n    this.vertexBuffer = null;\n\n    /**\n     * @property indexBuffer\n     * @type Object\n     */\n    this.indexBuffer = null;\n\n    /**\n     * @property lastIndexCount\n     * @type Number\n     */\n    this.lastIndexCount = 0;\n\n    for (var i=0, j=0; i < numIndices; i += 6, j += 4)\n    {\n        this.indices[i + 0] = j + 0;\n        this.indices[i + 1] = j + 1;\n        this.indices[i + 2] = j + 2;\n        this.indices[i + 3] = j + 0;\n        this.indices[i + 4] = j + 2;\n        this.indices[i + 5] = j + 3;\n    }\n\n    /**\n     * @property drawing\n     * @type Boolean\n     */\n    this.drawing = false;\n\n    /**\n     * @property currentBatchSize\n     * @type Number\n     */\n    this.currentBatchSize = 0;\n\n    /**\n     * @property currentBaseTexture\n     * @type BaseTexture\n     */\n    this.currentBaseTexture = null;\n   \n    /**\n     * @property currentBlendMode\n     * @type Number\n     */\n    this.currentBlendMode = 0;\n\n    /**\n     * @property renderSession\n     * @type Object\n     */\n    this.renderSession = null;\n    \n    /**\n     * @property shader\n     * @type Object\n     */\n    this.shader = null;\n\n    /**\n     * @property matrix\n     * @type Matrix\n     */\n    this.matrix = null;\n\n    this.setContext(gl);\n};\n\nPIXI.WebGLFastSpriteBatch.prototype.constructor = PIXI.WebGLFastSpriteBatch;\n\n/**\n * Sets the WebGL Context.\n *\n * @method setContext\n * @param gl {WebGLContext} the current WebGL drawing context\n */\nPIXI.WebGLFastSpriteBatch.prototype.setContext = function(gl)\n{\n    this.gl = gl;\n\n    // create a couple of buffers\n    this.vertexBuffer = gl.createBuffer();\n    this.indexBuffer = gl.createBuffer();\n\n    // 65535 is max index, so 65535 / 6 = 10922.\n\n    //upload the index data\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n};\n\n/**\n * @method begin\n * @param spriteBatch {WebGLSpriteBatch}\n * @param renderSession {Object}\n */\nPIXI.WebGLFastSpriteBatch.prototype.begin = function(spriteBatch, renderSession)\n{\n    this.renderSession = renderSession;\n    this.shader = this.renderSession.shaderManager.fastShader;\n\n    this.matrix = spriteBatch.worldTransform.toArray(true);\n\n    this.start();\n};\n\n/**\n * @method end\n */\nPIXI.WebGLFastSpriteBatch.prototype.end = function()\n{\n    this.flush();\n};\n\n/**\n * @method render\n * @param spriteBatch {WebGLSpriteBatch}\n */\nPIXI.WebGLFastSpriteBatch.prototype.render = function(spriteBatch)\n{\n    var children = spriteBatch.children;\n    var sprite = children[0];\n\n    // if the uvs have not updated then no point rendering just yet!\n    \n    // check texture.\n    if(!sprite.texture._uvs)return;\n   \n    this.currentBaseTexture = sprite.texture.baseTexture;\n    \n    // check blend mode\n    if(sprite.blendMode !== this.renderSession.blendModeManager.currentBlendMode)\n    {\n        this.flush();\n        this.renderSession.blendModeManager.setBlendMode(sprite.blendMode);\n    }\n    \n    for(var i=0,j= children.length; i<j; i++)\n    {\n        this.renderSprite(children[i]);\n    }\n\n    this.flush();\n};\n\n/**\n * @method renderSprite\n * @param sprite {Sprite}\n */\nPIXI.WebGLFastSpriteBatch.prototype.renderSprite = function(sprite)\n{\n    //sprite = children[i];\n    if(!sprite.visible)return;\n    \n    // TODO trim??\n    if(sprite.texture.baseTexture !== this.currentBaseTexture)\n    {\n        this.flush();\n        this.currentBaseTexture = sprite.texture.baseTexture;\n        \n        if(!sprite.texture._uvs)return;\n    }\n\n    var uvs, verticies = this.vertices, width, height, w0, w1, h0, h1, index;\n\n    uvs = sprite.texture._uvs;\n\n    width = sprite.texture.frame.width;\n    height = sprite.texture.frame.height;\n\n    if (sprite.texture.trim)\n    {\n        // if the sprite is trimmed then we need to add the extra space before transforming the sprite coords..\n        var trim = sprite.texture.trim;\n\n        w1 = trim.x - sprite.anchor.x * trim.width;\n        w0 = w1 + sprite.texture.crop.width;\n\n        h1 = trim.y - sprite.anchor.y * trim.height;\n        h0 = h1 + sprite.texture.crop.height;\n    }\n    else\n    {\n        w0 = (sprite.texture.frame.width ) * (1-sprite.anchor.x);\n        w1 = (sprite.texture.frame.width ) * -sprite.anchor.x;\n\n        h0 = sprite.texture.frame.height * (1-sprite.anchor.y);\n        h1 = sprite.texture.frame.height * -sprite.anchor.y;\n    }\n\n    index = this.currentBatchSize * 4 * this.vertSize;\n\n    // xy\n    verticies[index++] = w1;\n    verticies[index++] = h1;\n\n    verticies[index++] = sprite.position.x;\n    verticies[index++] = sprite.position.y;\n\n    //scale\n    verticies[index++] = sprite.scale.x;\n    verticies[index++] = sprite.scale.y;\n\n    //rotation\n    verticies[index++] = sprite.rotation;\n\n    // uv\n    verticies[index++] = uvs.x0;\n    verticies[index++] = uvs.y1;\n    // color\n    verticies[index++] = sprite.alpha;\n \n\n    // xy\n    verticies[index++] = w0;\n    verticies[index++] = h1;\n\n    verticies[index++] = sprite.position.x;\n    verticies[index++] = sprite.position.y;\n\n    //scale\n    verticies[index++] = sprite.scale.x;\n    verticies[index++] = sprite.scale.y;\n\n     //rotation\n    verticies[index++] = sprite.rotation;\n\n    // uv\n    verticies[index++] = uvs.x1;\n    verticies[index++] = uvs.y1;\n    // color\n    verticies[index++] = sprite.alpha;\n  \n\n    // xy\n    verticies[index++] = w0;\n    verticies[index++] = h0;\n\n    verticies[index++] = sprite.position.x;\n    verticies[index++] = sprite.position.y;\n\n    //scale\n    verticies[index++] = sprite.scale.x;\n    verticies[index++] = sprite.scale.y;\n\n     //rotation\n    verticies[index++] = sprite.rotation;\n\n    // uv\n    verticies[index++] = uvs.x2;\n    verticies[index++] = uvs.y2;\n    // color\n    verticies[index++] = sprite.alpha;\n \n\n\n\n    // xy\n    verticies[index++] = w1;\n    verticies[index++] = h0;\n\n    verticies[index++] = sprite.position.x;\n    verticies[index++] = sprite.position.y;\n\n    //scale\n    verticies[index++] = sprite.scale.x;\n    verticies[index++] = sprite.scale.y;\n\n     //rotation\n    verticies[index++] = sprite.rotation;\n\n    // uv\n    verticies[index++] = uvs.x3;\n    verticies[index++] = uvs.y3;\n    // color\n    verticies[index++] = sprite.alpha;\n\n    // increment the batchs\n    this.currentBatchSize++;\n\n    if(this.currentBatchSize >= this.size)\n    {\n        this.flush();\n    }\n};\n\n/**\n * @method flush\n */\nPIXI.WebGLFastSpriteBatch.prototype.flush = function()\n{\n    // If the batch is length 0 then return as there is nothing to draw\n    if (this.currentBatchSize===0)return;\n\n    var gl = this.gl;\n    \n    // bind the current texture\n\n    if(!this.currentBaseTexture._glTextures[gl.id])this.renderSession.renderer.updateTexture(this.currentBaseTexture, gl);\n\n    gl.bindTexture(gl.TEXTURE_2D, this.currentBaseTexture._glTextures[gl.id]);\n\n    // upload the verts to the buffer\n   \n    if(this.currentBatchSize > ( this.size * 0.5 ) )\n    {\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);\n    }\n    else\n    {\n        var view = this.vertices.subarray(0, this.currentBatchSize * 4 * this.vertSize);\n\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);\n    }\n    \n    // now draw those suckas!\n    gl.drawElements(gl.TRIANGLES, this.currentBatchSize * 6, gl.UNSIGNED_SHORT, 0);\n   \n    // then reset the batch!\n    this.currentBatchSize = 0;\n\n    // increment the draw count\n    this.renderSession.drawCount++;\n};\n\n\n/**\n * @method stop\n */\nPIXI.WebGLFastSpriteBatch.prototype.stop = function()\n{\n    this.flush();\n};\n\n/**\n * @method start\n */\nPIXI.WebGLFastSpriteBatch.prototype.start = function()\n{\n    var gl = this.gl;\n\n    // bind the main texture\n    gl.activeTexture(gl.TEXTURE0);\n\n    // bind the buffers\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n\n    // set the projection\n    var projection = this.renderSession.projection;\n    gl.uniform2f(this.shader.projectionVector, projection.x, projection.y);\n\n    // set the matrix\n    gl.uniformMatrix3fv(this.shader.uMatrix, false, this.matrix);\n\n    // set the pointers\n    var stride =  this.vertSize * 4;\n\n    gl.vertexAttribPointer(this.shader.aVertexPosition, 2, gl.FLOAT, false, stride, 0);\n    gl.vertexAttribPointer(this.shader.aPositionCoord, 2, gl.FLOAT, false, stride, 2 * 4);\n    gl.vertexAttribPointer(this.shader.aScale, 2, gl.FLOAT, false, stride, 4 * 4);\n    gl.vertexAttribPointer(this.shader.aRotation, 1, gl.FLOAT, false, stride, 6 * 4);\n    gl.vertexAttribPointer(this.shader.aTextureCoord, 2, gl.FLOAT, false, stride, 7 * 4);\n    gl.vertexAttribPointer(this.shader.colorAttribute, 1, gl.FLOAT, false, stride, 9 * 4);\n    \n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n* @class WebGLFilterManager\n* @constructor\n*/\nPIXI.WebGLFilterManager = function()\n{\n    /**\n     * @property filterStack\n     * @type Array\n     */\n    this.filterStack = [];\n    \n    /**\n     * @property offsetX\n     * @type Number\n     */\n    this.offsetX = 0;\n\n    /**\n     * @property offsetY\n     * @type Number\n     */\n    this.offsetY = 0;\n};\n\nPIXI.WebGLFilterManager.prototype.constructor = PIXI.WebGLFilterManager;\n\n/**\n* Initialises the context and the properties.\n* \n* @method setContext \n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.WebGLFilterManager.prototype.setContext = function(gl)\n{\n    this.gl = gl;\n    this.texturePool = [];\n\n    this.initShaderBuffers();\n};\n\n/**\n* @method begin\n* @param renderSession {RenderSession} \n* @param buffer {ArrayBuffer} \n*/\nPIXI.WebGLFilterManager.prototype.begin = function(renderSession, buffer)\n{\n    this.renderSession = renderSession;\n    this.defaultShader = renderSession.shaderManager.defaultShader;\n\n    var projection = this.renderSession.projection;\n    this.width = projection.x * 2;\n    this.height = -projection.y * 2;\n    this.buffer = buffer;\n};\n\n/**\n* Applies the filter and adds it to the current filter stack.\n* \n* @method pushFilter\n* @param filterBlock {Object} the filter that will be pushed to the current filter stack\n*/\nPIXI.WebGLFilterManager.prototype.pushFilter = function(filterBlock)\n{\n    var gl = this.gl;\n\n    var projection = this.renderSession.projection;\n    var offset = this.renderSession.offset;\n\n    filterBlock._filterArea = filterBlock.target.filterArea || filterBlock.target.getBounds();\n\n    // filter program\n    // OPTIMISATION - the first filter is free if its a simple color change?\n    this.filterStack.push(filterBlock);\n\n    var filter = filterBlock.filterPasses[0];\n\n    this.offsetX += filterBlock._filterArea.x;\n    this.offsetY += filterBlock._filterArea.y;\n\n    var texture = this.texturePool.pop();\n    if(!texture)\n    {\n        texture = new PIXI.FilterTexture(this.gl, this.width, this.height);\n    }\n    else\n    {\n        texture.resize(this.width, this.height);\n    }\n\n    gl.bindTexture(gl.TEXTURE_2D,  texture.texture);\n\n    var filterArea = filterBlock._filterArea;// filterBlock.target.getBounds();///filterBlock.target.filterArea;\n\n    var padding = filter.padding;\n    filterArea.x -= padding;\n    filterArea.y -= padding;\n    filterArea.width += padding * 2;\n    filterArea.height += padding * 2;\n\n    // cap filter to screen size..\n    if(filterArea.x < 0)filterArea.x = 0;\n    if(filterArea.width > this.width)filterArea.width = this.width;\n    if(filterArea.y < 0)filterArea.y = 0;\n    if(filterArea.height > this.height)filterArea.height = this.height;\n\n    //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,  filterArea.width, filterArea.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, texture.frameBuffer);\n\n    // set view port\n    gl.viewport(0, 0, filterArea.width, filterArea.height);\n\n    projection.x = filterArea.width/2;\n    projection.y = -filterArea.height/2;\n\n    offset.x = -filterArea.x;\n    offset.y = -filterArea.y;\n\n    // update projection\n    // now restore the regular shader..\n    // this.renderSession.shaderManager.setShader(this.defaultShader);\n    //gl.uniform2f(this.defaultShader.projectionVector, filterArea.width/2, -filterArea.height/2);\n    //gl.uniform2f(this.defaultShader.offsetVector, -filterArea.x, -filterArea.y);\n\n    gl.colorMask(true, true, true, true);\n    gl.clearColor(0,0,0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    filterBlock._glFilterTexture = texture;\n\n};\n\n/**\n* Removes the last filter from the filter stack and doesn't return it.\n* \n* @method popFilter\n*/\nPIXI.WebGLFilterManager.prototype.popFilter = function()\n{\n    var gl = this.gl;\n    var filterBlock = this.filterStack.pop();\n    var filterArea = filterBlock._filterArea;\n    var texture = filterBlock._glFilterTexture;\n    var projection = this.renderSession.projection;\n    var offset = this.renderSession.offset;\n\n    if(filterBlock.filterPasses.length > 1)\n    {\n        gl.viewport(0, 0, filterArea.width, filterArea.height);\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n\n        this.vertexArray[0] = 0;\n        this.vertexArray[1] = filterArea.height;\n\n        this.vertexArray[2] = filterArea.width;\n        this.vertexArray[3] = filterArea.height;\n\n        this.vertexArray[4] = 0;\n        this.vertexArray[5] = 0;\n\n        this.vertexArray[6] = filterArea.width;\n        this.vertexArray[7] = 0;\n\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertexArray);\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);\n        // now set the uvs..\n        this.uvArray[2] = filterArea.width/this.width;\n        this.uvArray[5] = filterArea.height/this.height;\n        this.uvArray[6] = filterArea.width/this.width;\n        this.uvArray[7] = filterArea.height/this.height;\n\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.uvArray);\n\n        var inputTexture = texture;\n        var outputTexture = this.texturePool.pop();\n        if(!outputTexture)outputTexture = new PIXI.FilterTexture(this.gl, this.width, this.height);\n        outputTexture.resize(this.width, this.height);\n\n        // need to clear this FBO as it may have some left over elements from a previous filter.\n        gl.bindFramebuffer(gl.FRAMEBUFFER, outputTexture.frameBuffer );\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        gl.disable(gl.BLEND);\n\n        for (var i = 0; i < filterBlock.filterPasses.length-1; i++)\n        {\n            var filterPass = filterBlock.filterPasses[i];\n\n            gl.bindFramebuffer(gl.FRAMEBUFFER, outputTexture.frameBuffer );\n\n            // set texture\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, inputTexture.texture);\n\n            // draw texture..\n            //filterPass.applyFilterPass(filterArea.width, filterArea.height);\n            this.applyFilterPass(filterPass, filterArea, filterArea.width, filterArea.height);\n\n            // swap the textures..\n            var temp = inputTexture;\n            inputTexture = outputTexture;\n            outputTexture = temp;\n        }\n\n        gl.enable(gl.BLEND);\n\n        texture = inputTexture;\n        this.texturePool.push(outputTexture);\n    }\n\n    var filter = filterBlock.filterPasses[filterBlock.filterPasses.length-1];\n\n    this.offsetX -= filterArea.x;\n    this.offsetY -= filterArea.y;\n\n    var sizeX = this.width;\n    var sizeY = this.height;\n\n    var offsetX = 0;\n    var offsetY = 0;\n\n    var buffer = this.buffer;\n\n    // time to render the filters texture to the previous scene\n    if(this.filterStack.length === 0)\n    {\n        gl.colorMask(true, true, true, true);//this.transparent);\n    }\n    else\n    {\n        var currentFilter = this.filterStack[this.filterStack.length-1];\n        filterArea = currentFilter._filterArea;\n\n        sizeX = filterArea.width;\n        sizeY = filterArea.height;\n\n        offsetX = filterArea.x;\n        offsetY = filterArea.y;\n\n        buffer =  currentFilter._glFilterTexture.frameBuffer;\n    }\n\n    // TODO need to remove these global elements..\n    projection.x = sizeX/2;\n    projection.y = -sizeY/2;\n\n    offset.x = offsetX;\n    offset.y = offsetY;\n\n    filterArea = filterBlock._filterArea;\n\n    var x = filterArea.x-offsetX;\n    var y = filterArea.y-offsetY;\n\n    // update the buffers..\n    // make sure to flip the y!\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n\n    this.vertexArray[0] = x;\n    this.vertexArray[1] = y + filterArea.height;\n\n    this.vertexArray[2] = x + filterArea.width;\n    this.vertexArray[3] = y + filterArea.height;\n\n    this.vertexArray[4] = x;\n    this.vertexArray[5] = y;\n\n    this.vertexArray[6] = x + filterArea.width;\n    this.vertexArray[7] = y;\n\n    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertexArray);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);\n\n    this.uvArray[2] = filterArea.width/this.width;\n    this.uvArray[5] = filterArea.height/this.height;\n    this.uvArray[6] = filterArea.width/this.width;\n    this.uvArray[7] = filterArea.height/this.height;\n\n    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.uvArray);\n\n    gl.viewport(0, 0, sizeX, sizeY);\n\n    // bind the buffer\n    gl.bindFramebuffer(gl.FRAMEBUFFER, buffer );\n\n    // set the blend mode! \n    //gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA)\n\n    // set texture\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, texture.texture);\n\n    // apply!\n    this.applyFilterPass(filter, filterArea, sizeX, sizeY);\n\n    // now restore the regular shader.. should happen automatically now..\n    // this.renderSession.shaderManager.setShader(this.defaultShader);\n    // gl.uniform2f(this.defaultShader.projectionVector, sizeX/2, -sizeY/2);\n    // gl.uniform2f(this.defaultShader.offsetVector, -offsetX, -offsetY);\n\n    // return the texture to the pool\n    this.texturePool.push(texture);\n    filterBlock._glFilterTexture = null;\n};\n\n\n/**\n* Applies the filter to the specified area.\n* \n* @method applyFilterPass\n* @param filter {AbstractFilter} the filter that needs to be applied\n* @param filterArea {Texture} TODO - might need an update\n* @param width {Number} the horizontal range of the filter\n* @param height {Number} the vertical range of the filter\n*/\nPIXI.WebGLFilterManager.prototype.applyFilterPass = function(filter, filterArea, width, height)\n{\n    // use program\n    var gl = this.gl;\n    var shader = filter.shaders[gl.id];\n\n    if(!shader)\n    {\n        shader = new PIXI.PixiShader(gl);\n\n        shader.fragmentSrc = filter.fragmentSrc;\n        shader.uniforms = filter.uniforms;\n        shader.init();\n\n        filter.shaders[gl.id] = shader;\n    }\n\n    // set the shader\n    this.renderSession.shaderManager.setShader(shader);\n\n//    gl.useProgram(shader.program);\n\n    gl.uniform2f(shader.projectionVector, width/2, -height/2);\n    gl.uniform2f(shader.offsetVector, 0,0);\n\n    if(filter.uniforms.dimensions)\n    {\n        filter.uniforms.dimensions.value[0] = this.width;//width;\n        filter.uniforms.dimensions.value[1] = this.height;//height;\n        filter.uniforms.dimensions.value[2] = this.vertexArray[0];\n        filter.uniforms.dimensions.value[3] = this.vertexArray[5];//filterArea.height;\n    }\n\n    shader.syncUniforms();\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n    gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 0, 0);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);\n    gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, false, 0, 0);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);\n    gl.vertexAttribPointer(shader.colorAttribute, 2, gl.FLOAT, false, 0, 0);\n\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n\n    // draw the filter...\n    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n    this.renderSession.drawCount++;\n};\n\n/**\n* Initialises the shader buffers.\n* \n* @method initShaderBuffers\n*/\nPIXI.WebGLFilterManager.prototype.initShaderBuffers = function()\n{\n    var gl = this.gl;\n\n    // create some buffers\n    this.vertexBuffer = gl.createBuffer();\n    this.uvBuffer = gl.createBuffer();\n    this.colorBuffer = gl.createBuffer();\n    this.indexBuffer = gl.createBuffer();\n\n    // bind and upload the vertexs..\n    // keep a reference to the vertexFloatData..\n    this.vertexArray = new PIXI.Float32Array([0.0, 0.0,\n                                         1.0, 0.0,\n                                         0.0, 1.0,\n                                         1.0, 1.0]);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, this.vertexArray, gl.STATIC_DRAW);\n\n    // bind and upload the uv buffer\n    this.uvArray = new PIXI.Float32Array([0.0, 0.0,\n                                     1.0, 0.0,\n                                     0.0, 1.0,\n                                     1.0, 1.0]);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, this.uvArray, gl.STATIC_DRAW);\n\n    this.colorArray = new PIXI.Float32Array([1.0, 0xFFFFFF,\n                                        1.0, 0xFFFFFF,\n                                        1.0, 0xFFFFFF,\n                                        1.0, 0xFFFFFF]);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, this.colorArray, gl.STATIC_DRAW);\n\n    // bind and upload the index\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 1, 3, 2]), gl.STATIC_DRAW);\n\n};\n\n/**\n* Destroys the filter and removes it from the filter stack.\n* \n* @method destroy\n*/\nPIXI.WebGLFilterManager.prototype.destroy = function()\n{\n    var gl = this.gl;\n\n    this.filterStack = null;\n    \n    this.offsetX = 0;\n    this.offsetY = 0;\n\n    // destroy textures\n    for (var i = 0; i < this.texturePool.length; i++) {\n        this.texturePool[i].destroy();\n    }\n    \n    this.texturePool = null;\n\n    //destroy buffers..\n    gl.deleteBuffer(this.vertexBuffer);\n    gl.deleteBuffer(this.uvBuffer);\n    gl.deleteBuffer(this.colorBuffer);\n    gl.deleteBuffer(this.indexBuffer);\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n* @class FilterTexture\n* @constructor\n* @param gl {WebGLContext} the current WebGL drawing context\n* @param width {Number} the horizontal range of the filter\n* @param height {Number} the vertical range of the filter\n* @param scaleMode {Number} Should be one of the PIXI.scaleMode consts\n*/\nPIXI.FilterTexture = function(gl, width, height, scaleMode)\n{\n    /**\n     * @property gl\n     * @type WebGLContext\n     */\n    this.gl = gl;\n\n    // next time to create a frame buffer and texture\n\n    /**\n     * @property frameBuffer\n     * @type Any\n     */\n    this.frameBuffer = gl.createFramebuffer();\n\n    /**\n     * @property texture\n     * @type Any\n     */\n    this.texture = gl.createTexture();\n\n    /**\n     * @property scaleMode\n     * @type Number\n     */\n    scaleMode = scaleMode || PIXI.scaleModes.DEFAULT;\n\n    gl.bindTexture(gl.TEXTURE_2D,  this.texture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer );\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer );\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);\n\n    // required for masking a mask??\n    this.renderBuffer = gl.createRenderbuffer();\n    gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBuffer);\n    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this.renderBuffer);\n  \n    this.resize(width, height);\n};\n\nPIXI.FilterTexture.prototype.constructor = PIXI.FilterTexture;\n\n/**\n* Clears the filter texture.\n* \n* @method clear\n*/\nPIXI.FilterTexture.prototype.clear = function()\n{\n    var gl = this.gl;\n    \n    gl.clearColor(0,0,0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n};\n\n/**\n * Resizes the texture to the specified width and height\n *\n * @method resize\n * @param width {Number} the new width of the texture\n * @param height {Number} the new height of the texture\n */\nPIXI.FilterTexture.prototype.resize = function(width, height)\n{\n    if(this.width === width && this.height === height) return;\n\n    this.width = width;\n    this.height = height;\n\n    var gl = this.gl;\n\n    gl.bindTexture(gl.TEXTURE_2D,  this.texture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,  width , height , 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    // update the stencil buffer width and height\n    gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBuffer);\n    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width , height );\n};\n\n/**\n* Destroys the filter texture.\n* \n* @method destroy\n*/\nPIXI.FilterTexture.prototype.destroy = function()\n{\n    var gl = this.gl;\n    gl.deleteFramebuffer( this.frameBuffer );\n    gl.deleteTexture( this.texture );\n\n    this.frameBuffer = null;\n    this.texture = null;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * Creates a Canvas element of the given size.\n *\n * @class CanvasBuffer\n * @constructor\n * @param width {Number} the width for the newly created canvas\n * @param height {Number} the height for the newly created canvas\n */\nPIXI.CanvasBuffer = function(width, height)\n{\n    /**\n     * The width of the Canvas in pixels.\n     *\n     * @property width\n     * @type Number\n     */\n    this.width = width;\n\n    /**\n     * The height of the Canvas in pixels.\n     *\n     * @property height\n     * @type Number\n     */\n    this.height = height;\n\n    /**\n     * The Canvas object that belongs to this CanvasBuffer.\n     *\n     * @property canvas\n     * @type HTMLCanvasElement\n     */\n    this.canvas = document.createElement(\"canvas\");\n\n    /**\n     * A CanvasRenderingContext2D object representing a two-dimensional rendering context.\n     *\n     * @property context\n     * @type CanvasRenderingContext2D\n     */\n    this.context = this.canvas.getContext(\"2d\");\n\n    this.canvas.width = width;\n    this.canvas.height = height;\n};\n\nPIXI.CanvasBuffer.prototype.constructor = PIXI.CanvasBuffer;\n\n/**\n * Clears the canvas that was created by the CanvasBuffer class.\n *\n * @method clear\n * @private\n */\nPIXI.CanvasBuffer.prototype.clear = function()\n{\n    this.context.setTransform(1, 0, 0, 1, 0, 0);\n    this.context.clearRect(0,0, this.width, this.height);\n};\n\n/**\n * Resizes the canvas to the specified width and height.\n *\n * @method resize\n * @param width {Number} the new width of the canvas\n * @param height {Number} the new height of the canvas\n */\nPIXI.CanvasBuffer.prototype.resize = function(width, height)\n{\n    this.width = this.canvas.width = width;\n    this.height = this.canvas.height = height;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * A set of functions used to handle masking.\n *\n * @class CanvasMaskManager\n * @constructor\n */\nPIXI.CanvasMaskManager = function()\n{\n};\n\nPIXI.CanvasMaskManager.prototype.constructor = PIXI.CanvasMaskManager;\n\n/**\n * This method adds it to the current stack of masks.\n *\n * @method pushMask\n * @param maskData {Object} the maskData that will be pushed\n * @param renderSession {Object} The renderSession whose context will be used for this mask manager.\n */\nPIXI.CanvasMaskManager.prototype.pushMask = function(maskData, renderSession)\n{\n	var context = renderSession.context;\n\n    context.save();\n    \n    var cacheAlpha = maskData.alpha;\n    var transform = maskData.worldTransform;\n\n    var resolution = renderSession.resolution;\n\n    context.setTransform(transform.a * resolution,\n                         transform.b * resolution,\n                         transform.c * resolution,\n                         transform.d * resolution,\n                         transform.tx * resolution,\n                         transform.ty * resolution);\n\n    PIXI.CanvasGraphics.renderGraphicsMask(maskData, context);\n\n    context.clip();\n\n    maskData.worldAlpha = cacheAlpha;\n};\n\n/**\n * Restores the current drawing context to the state it was before the mask was applied.\n *\n * @method popMask\n * @param renderSession {Object} The renderSession whose context will be used for this mask manager.\n */\nPIXI.CanvasMaskManager.prototype.popMask = function(renderSession)\n{\n    renderSession.context.restore();\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * @class CanvasTinter\n * @constructor\n * @static\n */\nPIXI.CanvasTinter = function()\n{\n};\n\n/**\n * Basically this method just needs a sprite and a color and tints the sprite with the given color.\n * \n * @method getTintedTexture \n * @param sprite {Sprite} the sprite to tint\n * @param color {Number} the color to use to tint the sprite with\n * @return {HTMLCanvasElement} The tinted canvas\n */\nPIXI.CanvasTinter.getTintedTexture = function(sprite, color)\n{\n    var texture = sprite.texture;\n\n    color = PIXI.CanvasTinter.roundColor(color);\n\n    var stringColor = \"#\" + (\"00000\" + ( color | 0).toString(16)).substr(-6);\n   \n    texture.tintCache = texture.tintCache || {};\n\n    if(texture.tintCache[stringColor]) return texture.tintCache[stringColor];\n\n     // clone texture..\n    var canvas = PIXI.CanvasTinter.canvas || document.createElement(\"canvas\");\n    \n    //PIXI.CanvasTinter.tintWithPerPixel(texture, stringColor, canvas);\n    PIXI.CanvasTinter.tintMethod(texture, color, canvas);\n\n    if(PIXI.CanvasTinter.convertTintToImage)\n    {\n        // is this better?\n        var tintImage = new Image();\n        tintImage.src = canvas.toDataURL();\n\n        texture.tintCache[stringColor] = tintImage;\n    }\n    else\n    {\n        texture.tintCache[stringColor] = canvas;\n        // if we are not converting the texture to an image then we need to lose the reference to the canvas\n        PIXI.CanvasTinter.canvas = null;\n    }\n\n    return canvas;\n};\n\n/**\n * Tint a texture using the \"multiply\" operation.\n * \n * @method tintWithMultiply\n * @param texture {Texture} the texture to tint\n * @param color {Number} the color to use to tint the sprite with\n * @param canvas {HTMLCanvasElement} the current canvas\n */\nPIXI.CanvasTinter.tintWithMultiply = function(texture, color, canvas)\n{\n    var context = canvas.getContext( \"2d\" );\n\n    var crop = texture.crop;\n\n    canvas.width = crop.width;\n    canvas.height = crop.height;\n\n    context.fillStyle = \"#\" + (\"00000\" + ( color | 0).toString(16)).substr(-6);\n    \n    context.fillRect(0, 0, crop.width, crop.height);\n    \n    context.globalCompositeOperation = \"multiply\";\n\n    context.drawImage(texture.baseTexture.source,\n                           crop.x,\n                           crop.y,\n                           crop.width,\n                           crop.height,\n                           0,\n                           0,\n                           crop.width,\n                           crop.height);\n\n    context.globalCompositeOperation = \"destination-atop\";\n\n    context.drawImage(texture.baseTexture.source,\n                           crop.x,\n                           crop.y,\n                           crop.width,\n                           crop.height,\n                           0,\n                           0,\n                           crop.width,\n                           crop.height);\n};\n\n/**\n * Tint a texture using the \"overlay\" operation.\n * \n * @method tintWithOverlay\n * @param texture {Texture} the texture to tint\n * @param color {Number} the color to use to tint the sprite with\n * @param canvas {HTMLCanvasElement} the current canvas\n */\nPIXI.CanvasTinter.tintWithOverlay = function(texture, color, canvas)\n{\n    var context = canvas.getContext( \"2d\" );\n\n    var crop = texture.crop;\n\n    canvas.width = crop.width;\n    canvas.height = crop.height;\n    \n    context.globalCompositeOperation = \"copy\";\n    context.fillStyle = \"#\" + (\"00000\" + ( color | 0).toString(16)).substr(-6);\n    context.fillRect(0, 0, crop.width, crop.height);\n\n    context.globalCompositeOperation = \"destination-atop\";\n    context.drawImage(texture.baseTexture.source,\n                           crop.x,\n                           crop.y,\n                           crop.width,\n                           crop.height,\n                           0,\n                           0,\n                           crop.width,\n                           crop.height);\n    \n    //context.globalCompositeOperation = \"copy\";\n};\n\n/**\n * Tint a texture pixel per pixel.\n * \n * @method tintPerPixel\n * @param texture {Texture} the texture to tint\n * @param color {Number} the color to use to tint the sprite with\n * @param canvas {HTMLCanvasElement} the current canvas\n */\nPIXI.CanvasTinter.tintWithPerPixel = function(texture, color, canvas)\n{\n    var context = canvas.getContext( \"2d\" );\n\n    var crop = texture.crop;\n\n    canvas.width = crop.width;\n    canvas.height = crop.height;\n  \n    context.globalCompositeOperation = \"copy\";\n    context.drawImage(texture.baseTexture.source,\n                           crop.x,\n                           crop.y,\n                           crop.width,\n                           crop.height,\n                           0,\n                           0,\n                           crop.width,\n                           crop.height);\n\n    var rgbValues = PIXI.hex2rgb(color);\n    var r = rgbValues[0], g = rgbValues[1], b = rgbValues[2];\n\n    var pixelData = context.getImageData(0, 0, crop.width, crop.height);\n\n    var pixels = pixelData.data;\n\n    for (var i = 0; i < pixels.length; i += 4)\n    {\n        pixels[i+0] *= r;\n        pixels[i+1] *= g;\n        pixels[i+2] *= b;\n    }\n\n    context.putImageData(pixelData, 0, 0);\n};\n\n/**\n * Rounds the specified color according to the PIXI.CanvasTinter.cacheStepsPerColorChannel.\n * \n * @method roundColor\n * @param color {number} the color to round, should be a hex color\n */\nPIXI.CanvasTinter.roundColor = function(color)\n{\n    var step = PIXI.CanvasTinter.cacheStepsPerColorChannel;\n\n    var rgbValues = PIXI.hex2rgb(color);\n\n    rgbValues[0] = Math.min(255, (rgbValues[0] / step) * step);\n    rgbValues[1] = Math.min(255, (rgbValues[1] / step) * step);\n    rgbValues[2] = Math.min(255, (rgbValues[2] / step) * step);\n\n    return PIXI.rgb2hex(rgbValues);\n};\n\n/**\n * Number of steps which will be used as a cap when rounding colors.\n *\n * @property cacheStepsPerColorChannel\n * @type Number\n */\nPIXI.CanvasTinter.cacheStepsPerColorChannel = 8;\n\n/**\n * Tint cache boolean flag.\n *\n * @property convertTintToImage\n * @type Boolean\n */\nPIXI.CanvasTinter.convertTintToImage = false;\n\n/**\n * Whether or not the Canvas BlendModes are supported, consequently the ability to tint using the multiply method.\n *\n * @property canUseMultiply\n * @type Boolean\n */\nPIXI.CanvasTinter.canUseMultiply = PIXI.canUseNewCanvasBlendModes();\n\n/**\n * The tinting method that will be used.\n * \n * @method tintMethod\n */\nPIXI.CanvasTinter.tintMethod = PIXI.CanvasTinter.canUseMultiply ? PIXI.CanvasTinter.tintWithMultiply :  PIXI.CanvasTinter.tintWithPerPixel;\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * The CanvasRenderer draws the Stage and all its content onto a 2d canvas. This renderer should be used for browsers that do not support webGL.\n * Don't forget to add the CanvasRenderer.view to your DOM or you will not see anything :)\n *\n * @class CanvasRenderer\n * @constructor\n * @param [width=800] {Number} the width of the canvas view\n * @param [height=600] {Number} the height of the canvas view\n * @param [options] {Object} The optional renderer parameters\n * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional\n * @param [options.transparent=false] {Boolean} If the render view is transparent, default false\n * @param [options.autoResize=false] {Boolean} If the render view is automatically resized, default false\n * @param [options.resolution=1] {Number} the resolution of the renderer retina would be 2\n * @param [options.clearBeforeRender=true] {Boolean} This sets if the CanvasRenderer will clear the canvas or not before the new render pass.\n */\nPIXI.CanvasRenderer = function(width, height, options)\n{\n    if(options)\n    {\n        for (var i in PIXI.defaultRenderOptions)\n        {\n            if (typeof options[i] === \"undefined\") options[i] = PIXI.defaultRenderOptions[i];\n        }\n    }\n    else\n    {\n        options = PIXI.defaultRenderOptions;\n    }\n\n    if(!PIXI.defaultRenderer)\n    {\n        PIXI.sayHello(\"Canvas\");\n        PIXI.defaultRenderer = this;\n    }\n\n    /**\n     * The renderer type.\n     *\n     * @property type\n     * @type Number\n     */\n    this.type = PIXI.CANVAS_RENDERER;\n\n    /**\n     * The resolution of the canvas.\n     *\n     * @property resolution\n     * @type Number\n     */\n    this.resolution = options.resolution;\n\n    /**\n     * This sets if the CanvasRenderer will clear the canvas or not before the new render pass.\n     * If the Stage is NOT transparent Pixi will use a canvas sized fillRect operation every frame to set the canvas background color.\n     * If the Stage is transparent Pixi will use clearRect to clear the canvas every frame.\n     * Disable this by setting this to false. For example if your game has a canvas filling background image you often don't need this set.\n     *\n     * @property clearBeforeRender\n     * @type Boolean\n     * @default\n     */\n    this.clearBeforeRender = options.clearBeforeRender;\n\n    /**\n     * Whether the render view is transparent\n     *\n     * @property transparent\n     * @type Boolean\n     */\n    this.transparent = options.transparent;\n\n    /**\n     * Whether the render view should be resized automatically\n     *\n     * @property autoResize\n     * @type Boolean\n     */\n    this.autoResize = options.autoResize || false;\n\n\n    /**\n     * The width of the canvas view\n     *\n     * @property width\n     * @type Number\n     * @default 800\n     */\n    this.width = width || 800;\n\n    /**\n     * The height of the canvas view\n     *\n     * @property height\n     * @type Number\n     * @default 600\n     */\n    this.height = height || 600;\n\n    this.width *= this.resolution;\n    this.height *= this.resolution;\n\n    /**\n     * The canvas element that everything is drawn to.\n     *\n     * @property view\n     * @type HTMLCanvasElement\n     */\n    this.view = options.view || document.createElement( \"canvas\" );\n\n    /**\n     * The canvas 2d context that everything is drawn with\n     * @property context\n     * @type CanvasRenderingContext2D\n     */\n    this.context = this.view.getContext( \"2d\", { alpha: this.transparent } );\n\n    /**\n     * Boolean flag controlling canvas refresh.\n     *\n     * @property refresh\n     * @type Boolean\n     */\n    this.refresh = true;\n\n    this.view.width = this.width * this.resolution;\n    this.view.height = this.height * this.resolution;\n\n    /**\n     * Internal var.\n     *\n     * @property count\n     * @type Number\n     */\n    this.count = 0;\n\n    /**\n     * Instance of a PIXI.CanvasMaskManager, handles masking when using the canvas renderer\n     * @property CanvasMaskManager\n     * @type CanvasMaskManager\n     */\n    this.maskManager = new PIXI.CanvasMaskManager();\n\n    /**\n     * The render session is just a bunch of parameter used for rendering\n     * @property renderSession\n     * @type Object\n     */\n    this.renderSession = {\n        context: this.context,\n        maskManager: this.maskManager,\n        scaleMode: null,\n        smoothProperty: null,\n        /**\n         * If true Pixi will Math.floor() x/y values when rendering, stopping pixel interpolation.\n         * Handy for crisp pixel art and speed on legacy devices.\n         *\n         */\n        roundPixels: false\n    };\n\n    this.mapBlendModes();\n    \n    this.resize(width, height);\n\n    if(\"imageSmoothingEnabled\" in this.context)\n        this.renderSession.smoothProperty = \"imageSmoothingEnabled\";\n    else if(\"webkitImageSmoothingEnabled\" in this.context)\n        this.renderSession.smoothProperty = \"webkitImageSmoothingEnabled\";\n    else if(\"mozImageSmoothingEnabled\" in this.context)\n        this.renderSession.smoothProperty = \"mozImageSmoothingEnabled\";\n    else if(\"oImageSmoothingEnabled\" in this.context)\n        this.renderSession.smoothProperty = \"oImageSmoothingEnabled\";\n    else if (\"msImageSmoothingEnabled\" in this.context)\n        this.renderSession.smoothProperty = \"msImageSmoothingEnabled\";\n};\n\n// constructor\nPIXI.CanvasRenderer.prototype.constructor = PIXI.CanvasRenderer;\n\n/**\n * Renders the Stage to this canvas view\n *\n * @method render\n * @param stage {Stage} the Stage element to be rendered\n */\nPIXI.CanvasRenderer.prototype.render = function(stage)\n{\n    stage.updateTransform();\n\n    this.context.setTransform(1,0,0,1,0,0);\n\n    this.context.globalAlpha = 1;\n\n    this.renderSession.currentBlendMode = PIXI.blendModes.NORMAL;\n    this.context.globalCompositeOperation = PIXI.blendModesCanvas[PIXI.blendModes.NORMAL];\n\n    if (navigator.isCocoonJS && this.view.screencanvas) {\n        this.context.fillStyle = \"black\";\n        this.context.clear();\n    }\n    \n    if (this.clearBeforeRender)\n    {\n        if (this.transparent)\n        {\n            this.context.clearRect(0, 0, this.width, this.height);\n        }\n        else\n        {\n            this.context.fillStyle = stage.backgroundColorString;\n            this.context.fillRect(0, 0, this.width , this.height);\n        }\n    }\n    \n    this.renderDisplayObject(stage);\n\n    // run interaction!\n    if(stage.interactive)\n    {\n        //need to add some events!\n        if(!stage._interactiveEventsAdded)\n        {\n            stage._interactiveEventsAdded = true;\n            stage.interactionManager.setTarget(this);\n        }\n    }\n};\n\n/**\n * Removes everything from the renderer and optionally removes the Canvas DOM element.\n *\n * @method destroy\n * @param [removeView=true] {boolean} Removes the Canvas element from the DOM.\n */\nPIXI.CanvasRenderer.prototype.destroy = function(removeView)\n{\n    if (typeof removeView === \"undefined\") { removeView = true; }\n\n    if (removeView && this.view.parent)\n    {\n        this.view.parent.removeChild(this.view);\n    }\n\n    this.view = null;\n    this.context = null;\n    this.maskManager = null;\n    this.renderSession = null;\n\n};\n\n/**\n * Resizes the canvas view to the specified width and height\n *\n * @method resize\n * @param width {Number} the new width of the canvas view\n * @param height {Number} the new height of the canvas view\n */\nPIXI.CanvasRenderer.prototype.resize = function(width, height)\n{\n    this.width = width * this.resolution;\n    this.height = height * this.resolution;\n\n    this.view.width = this.width;\n    this.view.height = this.height;\n\n    if (this.autoResize) {\n        this.view.style.width = this.width / this.resolution + \"px\";\n        this.view.style.height = this.height / this.resolution + \"px\";\n    }\n};\n\n/**\n * Renders a display object\n *\n * @method renderDisplayObject\n * @param displayObject {DisplayObject} The displayObject to render\n * @param context {CanvasRenderingContext2D} the context 2d method of the canvas\n * @private\n */\nPIXI.CanvasRenderer.prototype.renderDisplayObject = function(displayObject, context)\n{\n    this.renderSession.context = context || this.context;\n    this.renderSession.resolution = this.resolution;\n    displayObject._renderCanvas(this.renderSession);\n};\n\n/**\n * Maps Pixi blend modes to canvas blend modes.\n *\n * @method mapBlendModes\n * @private\n */\nPIXI.CanvasRenderer.prototype.mapBlendModes = function()\n{\n    if(!PIXI.blendModesCanvas)\n    {\n        PIXI.blendModesCanvas = [];\n\n        if(PIXI.canUseNewCanvasBlendModes())\n        {\n            PIXI.blendModesCanvas[PIXI.blendModes.NORMAL]   = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.ADD]      = \"lighter\"; //IS THIS OK???\n            PIXI.blendModesCanvas[PIXI.blendModes.MULTIPLY] = \"multiply\";\n            PIXI.blendModesCanvas[PIXI.blendModes.SCREEN]   = \"screen\";\n            PIXI.blendModesCanvas[PIXI.blendModes.OVERLAY]  = \"overlay\";\n            PIXI.blendModesCanvas[PIXI.blendModes.DARKEN]   = \"darken\";\n            PIXI.blendModesCanvas[PIXI.blendModes.LIGHTEN]  = \"lighten\";\n            PIXI.blendModesCanvas[PIXI.blendModes.COLOR_DODGE] = \"color-dodge\";\n            PIXI.blendModesCanvas[PIXI.blendModes.COLOR_BURN] = \"color-burn\";\n            PIXI.blendModesCanvas[PIXI.blendModes.HARD_LIGHT] = \"hard-light\";\n            PIXI.blendModesCanvas[PIXI.blendModes.SOFT_LIGHT] = \"soft-light\";\n            PIXI.blendModesCanvas[PIXI.blendModes.DIFFERENCE] = \"difference\";\n            PIXI.blendModesCanvas[PIXI.blendModes.EXCLUSION] = \"exclusion\";\n            PIXI.blendModesCanvas[PIXI.blendModes.HUE]       = \"hue\";\n            PIXI.blendModesCanvas[PIXI.blendModes.SATURATION] = \"saturation\";\n            PIXI.blendModesCanvas[PIXI.blendModes.COLOR]      = \"color\";\n            PIXI.blendModesCanvas[PIXI.blendModes.LUMINOSITY] = \"luminosity\";\n        }\n        else\n        {\n            // this means that the browser does not support the cool new blend modes in canvas \"cough\" ie \"cough\"\n            PIXI.blendModesCanvas[PIXI.blendModes.NORMAL]   = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.ADD]      = \"lighter\"; //IS THIS OK???\n            PIXI.blendModesCanvas[PIXI.blendModes.MULTIPLY] = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.SCREEN]   = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.OVERLAY]  = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.DARKEN]   = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.LIGHTEN]  = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.COLOR_DODGE] = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.COLOR_BURN] = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.HARD_LIGHT] = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.SOFT_LIGHT] = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.DIFFERENCE] = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.EXCLUSION] = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.HUE]       = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.SATURATION] = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.COLOR]      = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.LUMINOSITY] = \"source-over\";\n        }\n    }\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n\n/**\n * A set of functions used by the canvas renderer to draw the primitive graphics data.\n *\n * @class CanvasGraphics\n * @static\n */\nPIXI.CanvasGraphics = function()\n{\n};\n\n/*\n * Renders a PIXI.Graphics object to a canvas.\n *\n * @method renderGraphics\n * @static\n * @param graphics {Graphics} the actual graphics object to render\n * @param context {CanvasRenderingContext2D} the 2d drawing method of the canvas\n */\nPIXI.CanvasGraphics.renderGraphics = function(graphics, context)\n{\n    var worldAlpha = graphics.worldAlpha;\n    var color = '';\n\n    for (var i = 0; i < graphics.graphicsData.length; i++)\n    {\n        var data = graphics.graphicsData[i];\n        var shape = data.shape;\n\n        context.strokeStyle = color = '#' + ('00000' + ( data.lineColor | 0).toString(16)).substr(-6);\n\n        context.lineWidth = data.lineWidth;\n\n        if(data.type === PIXI.Graphics.POLY)\n        {\n            context.beginPath();\n\n            var points = shape.points;\n\n            context.moveTo(points[0], points[1]);\n\n            for (var j=1; j < points.length/2; j++)\n            {\n                context.lineTo(points[j * 2], points[j * 2 + 1]);\n            }\n\n            if(shape.closed)\n            {\n                context.lineTo(points[0], points[1]);\n            }\n\n            // if the first and last point are the same close the path - much neater :)\n            if(points[0] === points[points.length-2] && points[1] === points[points.length-1])\n            {\n                context.closePath();\n            }\n\n            if(data.fill)\n            {\n                context.globalAlpha = data.fillAlpha * worldAlpha;\n                context.fillStyle = color = '#' + ('00000' + ( data.fillColor | 0).toString(16)).substr(-6);\n                context.fill();\n            }\n            if(data.lineWidth)\n            {\n                context.globalAlpha = data.lineAlpha * worldAlpha;\n                context.stroke();\n            }\n        }\n        else if(data.type === PIXI.Graphics.RECT)\n        {\n\n            if(data.fillColor || data.fillColor === 0)\n            {\n                context.globalAlpha = data.fillAlpha * worldAlpha;\n                context.fillStyle = color = '#' + ('00000' + ( data.fillColor | 0).toString(16)).substr(-6);\n                context.fillRect(shape.x, shape.y, shape.width, shape.height);\n\n            }\n            if(data.lineWidth)\n            {\n                context.globalAlpha = data.lineAlpha * worldAlpha;\n                context.strokeRect(shape.x, shape.y, shape.width, shape.height);\n            }\n        }\n        else if(data.type === PIXI.Graphics.CIRC)\n        {\n            // TODO - need to be Undefined!\n            context.beginPath();\n            context.arc(shape.x, shape.y, shape.radius,0,2*Math.PI);\n            context.closePath();\n\n            if(data.fill)\n            {\n                context.globalAlpha = data.fillAlpha * worldAlpha;\n                context.fillStyle = color = '#' + ('00000' + ( data.fillColor | 0).toString(16)).substr(-6);\n                context.fill();\n            }\n            if(data.lineWidth)\n            {\n                context.globalAlpha = data.lineAlpha * worldAlpha;\n                context.stroke();\n            }\n        }\n        else if(data.type === PIXI.Graphics.ELIP)\n        {\n            // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas\n\n            var w = shape.width * 2;\n            var h = shape.height * 2;\n\n            var x = shape.x - w/2;\n            var y = shape.y - h/2;\n\n            context.beginPath();\n\n            var kappa = 0.5522848,\n                ox = (w / 2) * kappa, // control point offset horizontal\n                oy = (h / 2) * kappa, // control point offset vertical\n                xe = x + w,           // x-end\n                ye = y + h,           // y-end\n                xm = x + w / 2,       // x-middle\n                ym = y + h / 2;       // y-middle\n\n            context.moveTo(x, ym);\n            context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n            context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n            context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n            context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n\n            context.closePath();\n\n            if(data.fill)\n            {\n                context.globalAlpha = data.fillAlpha * worldAlpha;\n                context.fillStyle = color = '#' + ('00000' + ( data.fillColor | 0).toString(16)).substr(-6);\n                context.fill();\n            }\n            if(data.lineWidth)\n            {\n                context.globalAlpha = data.lineAlpha * worldAlpha;\n                context.stroke();\n            }\n        }\n        else if (data.type === PIXI.Graphics.RREC)\n        {\n            var rx = shape.x;\n            var ry = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            var radius = shape.radius;\n\n            var maxRadius = Math.min(width, height) / 2 | 0;\n            radius = radius > maxRadius ? maxRadius : radius;\n\n            context.beginPath();\n            context.moveTo(rx, ry + radius);\n            context.lineTo(rx, ry + height - radius);\n            context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);\n            context.lineTo(rx + width - radius, ry + height);\n            context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);\n            context.lineTo(rx + width, ry + radius);\n            context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);\n            context.lineTo(rx + radius, ry);\n            context.quadraticCurveTo(rx, ry, rx, ry + radius);\n            context.closePath();\n\n            if(data.fillColor || data.fillColor === 0)\n            {\n                context.globalAlpha = data.fillAlpha * worldAlpha;\n                context.fillStyle = color = '#' + ('00000' + ( data.fillColor | 0).toString(16)).substr(-6);\n                context.fill();\n\n            }\n            if(data.lineWidth)\n            {\n                context.globalAlpha = data.lineAlpha * worldAlpha;\n                context.stroke();\n            }\n        }\n    }\n};\n\n/*\n * Renders a graphics mask\n *\n * @static\n * @private\n * @method renderGraphicsMask\n * @param graphics {Graphics} the graphics which will be used as a mask\n * @param context {CanvasRenderingContext2D} the context 2d method of the canvas\n */\nPIXI.CanvasGraphics.renderGraphicsMask = function(graphics, context)\n{\n    var len = graphics.graphicsData.length;\n\n    if(len === 0) return;\n\n    if(len > 1)\n    {\n        len = 1;\n        window.console.log('Pixi.js warning: masks in canvas can only mask using the first path in the graphics object');\n    }\n\n    for (var i = 0; i < 1; i++)\n    {\n        var data = graphics.graphicsData[i];\n        var shape = data.shape;\n\n        if(data.type === PIXI.Graphics.POLY)\n        {\n            context.beginPath();\n        \n            var points = shape.points;\n        \n            context.moveTo(points[0], points[1]);\n\n            for (var j=1; j < points.length/2; j++)\n            {\n                context.lineTo(points[j * 2], points[j * 2 + 1]);\n            }\n\n            // if the first and last point are the same close the path - much neater :)\n            if(points[0] === points[points.length-2] && points[1] === points[points.length-1])\n            {\n                context.closePath();\n            }\n\n        }\n        else if(data.type === PIXI.Graphics.RECT)\n        {\n            context.beginPath();\n            context.rect(shape.x, shape.y, shape.width, shape.height);\n            context.closePath();\n        }\n        else if(data.type === PIXI.Graphics.CIRC)\n        {\n            // TODO - need to be Undefined!\n            context.beginPath();\n            context.arc(shape.x, shape.y, shape.radius,0,2*Math.PI);\n            context.closePath();\n        }\n        else if(data.type === PIXI.Graphics.ELIP)\n        {\n\n            // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas\n\n            var w = shape.width * 2;\n            var h = shape.height * 2;\n\n            var x = shape.x - w/2;\n            var y = shape.y - h/2;\n\n            context.beginPath();\n\n            var kappa = 0.5522848,\n                ox = (w / 2) * kappa, // control point offset horizontal\n                oy = (h / 2) * kappa, // control point offset vertical\n                xe = x + w,           // x-end\n                ye = y + h,           // y-end\n                xm = x + w / 2,       // x-middle\n                ym = y + h / 2;       // y-middle\n\n            context.moveTo(x, ym);\n            context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n            context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n            context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n            context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n            context.closePath();\n        }\n        else if (data.type === PIXI.Graphics.RREC)\n        {\n        \n            var pts = shape.points;\n            var rx = pts[0];\n            var ry = pts[1];\n            var width = pts[2];\n            var height = pts[3];\n            var radius = pts[4];\n\n            var maxRadius = Math.min(width, height) / 2 | 0;\n            radius = radius > maxRadius ? maxRadius : radius;\n\n            context.beginPath();\n            context.moveTo(rx, ry + radius);\n            context.lineTo(rx, ry + height - radius);\n            context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);\n            context.lineTo(rx + width - radius, ry + height);\n            context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);\n            context.lineTo(rx + width, ry + radius);\n            context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);\n            context.lineTo(rx + radius, ry);\n            context.quadraticCurveTo(rx, ry, rx, ry + radius);\n            context.closePath();\n        }\n    }\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * The Graphics class contains methods used to draw primitive shapes such as lines, circles and rectangles to the display, and color and fill them.\n * \n * @class Graphics\n * @extends DisplayObjectContainer\n * @constructor\n */\nPIXI.Graphics = function()\n{\n    PIXI.DisplayObjectContainer.call( this );\n\n    this.renderable = true;\n\n    /**\n     * The alpha value used when filling the Graphics object.\n     *\n     * @property fillAlpha\n     * @type Number\n     */\n    this.fillAlpha = 1;\n\n    /**\n     * The width (thickness) of any lines drawn.\n     *\n     * @property lineWidth\n     * @type Number\n     */\n    this.lineWidth = 0;\n\n    /**\n     * The color of any lines drawn.\n     *\n     * @property lineColor\n     * @type String\n     * @default 0\n     */\n    this.lineColor = 0;\n\n    /**\n     * Graphics data\n     *\n     * @property graphicsData\n     * @type Array\n     * @private\n     */\n    this.graphicsData = [];\n\n    /**\n     * The tint applied to the graphic shape. This is a hex value. Apply a value of 0xFFFFFF to reset the tint.\n     *\n     * @property tint\n     * @type Number\n     * @default 0xFFFFFF\n     */\n    this.tint = 0xFFFFFF;\n    \n    /**\n     * The blend mode to be applied to the graphic shape. Apply a value of PIXI.blendModes.NORMAL to reset the blend mode.\n     *\n     * @property blendMode\n     * @type Number\n     * @default PIXI.blendModes.NORMAL;\n     */\n    this.blendMode = PIXI.blendModes.NORMAL;\n    \n    /**\n     * Current path\n     *\n     * @property currentPath\n     * @type Object\n     * @private\n     */\n    this.currentPath = null;\n    \n    /**\n     * Array containing some WebGL-related properties used by the WebGL renderer.\n     *\n     * @property _webGL\n     * @type Array\n     * @private\n     */\n    this._webGL = [];\n\n    /**\n     * Whether this shape is being used as a mask.\n     *\n     * @property isMask\n     * @type Boolean\n     */\n    this.isMask = false;\n\n    /**\n     * The bounds' padding used for bounds calculation.\n     *\n     * @property boundsPadding\n     * @type Number\n     */\n    this.boundsPadding = 0;\n\n    this._localBounds = new PIXI.Rectangle(0,0,1,1);\n\n    /**\n     * Used to detect if the graphics object has changed. If this is set to true then the graphics object will be recalculated.\n     * \n     * @property dirty\n     * @type Boolean\n     * @private\n     */\n    this.dirty = true;\n\n    /**\n     * Used to detect if the webgl graphics object has changed. If this is set to true then the graphics object will be recalculated.\n     * \n     * @property webGLDirty\n     * @type Boolean\n     * @private\n     */\n    this.webGLDirty = false;\n\n    /**\n     * Used to detect if the cached sprite object needs to be updated.\n     * \n     * @property cachedSpriteDirty\n     * @type Boolean\n     * @private\n     */\n    this.cachedSpriteDirty = false;\n\n};\n\n// constructor\nPIXI.Graphics.prototype = Object.create( PIXI.DisplayObjectContainer.prototype );\nPIXI.Graphics.prototype.constructor = PIXI.Graphics;\n\n/**\n * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.\n * This is useful if your graphics element does not change often, as it will speed up the rendering of the object in exchange for taking up texture memory.\n * It is also useful if you need the graphics object to be anti-aliased, because it will be rendered using canvas.\n * This is not recommended if you are constantly redrawing the graphics element.\n *\n * @property cacheAsBitmap\n * @type Boolean\n * @default false\n * @private\n */\nObject.defineProperty(PIXI.Graphics.prototype, \"cacheAsBitmap\", {\n    get: function() {\n        return  this._cacheAsBitmap;\n    },\n    set: function(value) {\n        this._cacheAsBitmap = value;\n\n        if(this._cacheAsBitmap)\n        {\n\n            this._generateCachedSprite();\n        }\n        else\n        {\n            this.destroyCachedSprite();\n            this.dirty = true;\n        }\n\n    }\n});\n\n/**\n * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo() method or the drawCircle() method.\n *\n * @method lineStyle\n * @param lineWidth {Number} width of the line to draw, will update the objects stored style\n * @param color {Number} color of the line to draw, will update the objects stored style\n * @param alpha {Number} alpha of the line to draw, will update the objects stored style\n * @return {Graphics}\n */\nPIXI.Graphics.prototype.lineStyle = function(lineWidth, color, alpha)\n{\n    this.lineWidth = lineWidth || 0;\n    this.lineColor = color || 0;\n    this.lineAlpha = (arguments.length < 3) ? 1 : alpha;\n\n    if(this.currentPath)\n    {\n        if(this.currentPath.shape.points.length)\n        {\n            // halfway through a line? start a new one!\n            this.drawShape( new PIXI.Polygon( this.currentPath.shape.points.slice(-2) ));\n            return this;\n        }\n\n        // otherwise its empty so lets just set the line properties\n        this.currentPath.lineWidth = this.lineWidth;\n        this.currentPath.lineColor = this.lineColor;\n        this.currentPath.lineAlpha = this.lineAlpha;\n        \n    }\n\n    return this;\n};\n\n/**\n * Moves the current drawing position to x, y.\n *\n * @method moveTo\n * @param x {Number} the X coordinate to move to\n * @param y {Number} the Y coordinate to move to\n * @return {Graphics}\n  */\nPIXI.Graphics.prototype.moveTo = function(x, y)\n{\n    this.drawShape(new PIXI.Polygon([x,y]));\n\n    return this;\n};\n\n/**\n * Draws a line using the current line style from the current drawing position to (x, y);\n * The current drawing position is then set to (x, y).\n *\n * @method lineTo\n * @param x {Number} the X coordinate to draw to\n * @param y {Number} the Y coordinate to draw to\n * @return {Graphics}\n */\nPIXI.Graphics.prototype.lineTo = function(x, y)\n{\n    this.currentPath.shape.points.push(x, y);\n    this.dirty = true;\n\n    return this;\n};\n\n/**\n * Calculate the points for a quadratic bezier curve and then draws it.\n * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n *\n * @method quadraticCurveTo\n * @param cpX {Number} Control point x\n * @param cpY {Number} Control point y\n * @param toX {Number} Destination point x\n * @param toY {Number} Destination point y\n * @return {Graphics}\n */\nPIXI.Graphics.prototype.quadraticCurveTo = function(cpX, cpY, toX, toY)\n{\n    if( this.currentPath )\n    {\n        if(this.currentPath.shape.points.length === 0)this.currentPath.shape.points = [0,0];\n    }\n    else\n    {\n        this.moveTo(0,0);\n    }\n\n    var xa,\n    ya,\n    n = 20,\n    points = this.currentPath.shape.points;\n    if(points.length === 0)this.moveTo(0, 0);\n    \n\n    var fromX = points[points.length-2];\n    var fromY = points[points.length-1];\n\n    var j = 0;\n    for (var i = 1; i <= n; i++ )\n    {\n        j = i / n;\n\n        xa = fromX + ( (cpX - fromX) * j );\n        ya = fromY + ( (cpY - fromY) * j );\n\n        points.push( xa + ( ((cpX + ( (toX - cpX) * j )) - xa) * j ),\n                     ya + ( ((cpY + ( (toY - cpY) * j )) - ya) * j ) );\n    }\n\n\n    this.dirty = true;\n\n    return this;\n};\n\n/**\n * Calculate the points for a bezier curve and then draws it.\n *\n * @method bezierCurveTo\n * @param cpX {Number} Control point x\n * @param cpY {Number} Control point y\n * @param cpX2 {Number} Second Control point x\n * @param cpY2 {Number} Second Control point y\n * @param toX {Number} Destination point x\n * @param toY {Number} Destination point y\n * @return {Graphics}\n */\nPIXI.Graphics.prototype.bezierCurveTo = function(cpX, cpY, cpX2, cpY2, toX, toY)\n{\n    if( this.currentPath )\n    {\n        if(this.currentPath.shape.points.length === 0)this.currentPath.shape.points = [0,0];\n    }\n    else\n    {\n        this.moveTo(0,0);\n    }\n\n    var n = 20,\n    dt,\n    dt2,\n    dt3,\n    t2,\n    t3,\n    points = this.currentPath.shape.points;\n\n    var fromX = points[points.length-2];\n    var fromY = points[points.length-1];\n    \n    var j = 0;\n\n    for (var i=1; i<=n; i++)\n    {\n        j = i / n;\n\n        dt = (1 - j);\n        dt2 = dt * dt;\n        dt3 = dt2 * dt;\n\n        t2 = j * j;\n        t3 = t2 * j;\n        \n        points.push( dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX,\n                     dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);\n    }\n    \n    this.dirty = true;\n\n    return this;\n};\n\n/*\n * The arcTo() method creates an arc/curve between two tangents on the canvas.\n * \n * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n *\n * @method arcTo\n * @param x1 {Number} The x-coordinate of the beginning of the arc\n * @param y1 {Number} The y-coordinate of the beginning of the arc\n * @param x2 {Number} The x-coordinate of the end of the arc\n * @param y2 {Number} The y-coordinate of the end of the arc\n * @param radius {Number} The radius of the arc\n * @return {Graphics}\n */\nPIXI.Graphics.prototype.arcTo = function(x1, y1, x2, y2, radius)\n{\n    if( this.currentPath )\n    {\n        if(this.currentPath.shape.points.length === 0)\n        {\n            this.currentPath.shape.points.push(x1, y1);\n        }\n    }\n    else\n    {\n        this.moveTo(x1, y1);\n    }\n\n    var points = this.currentPath.shape.points;\n    var fromX = points[points.length-2];\n    var fromY = points[points.length-1];\n    var a1 = fromY - y1;\n    var b1 = fromX - x1;\n    var a2 = y2   - y1;\n    var b2 = x2   - x1;\n    var mm = Math.abs(a1 * b2 - b1 * a2);\n\n\n    if (mm < 1.0e-8 || radius === 0)\n    {\n        if( points[points.length-2] !== x1 || points[points.length-1] !== y1)\n        {\n            //console.log(\">>\")\n            points.push(x1, y1);\n        }\n    }\n    else\n    {\n        var dd = a1 * a1 + b1 * b1;\n        var cc = a2 * a2 + b2 * b2;\n        var tt = a1 * a2 + b1 * b2;\n        var k1 = radius * Math.sqrt(dd) / mm;\n        var k2 = radius * Math.sqrt(cc) / mm;\n        var j1 = k1 * tt / dd;\n        var j2 = k2 * tt / cc;\n        var cx = k1 * b2 + k2 * b1;\n        var cy = k1 * a2 + k2 * a1;\n        var px = b1 * (k2 + j1);\n        var py = a1 * (k2 + j1);\n        var qx = b2 * (k1 + j2);\n        var qy = a2 * (k1 + j2);\n        var startAngle = Math.atan2(py - cy, px - cx);\n        var endAngle   = Math.atan2(qy - cy, qx - cx);\n\n        this.arc(cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1);\n    }\n\n    this.dirty = true;\n\n    return this;\n};\n\n/**\n * The arc method creates an arc/curve (used to create circles, or parts of circles).\n *\n * @method arc\n * @param cx {Number} The x-coordinate of the center of the circle\n * @param cy {Number} The y-coordinate of the center of the circle\n * @param radius {Number} The radius of the circle\n * @param startAngle {Number} The starting angle, in radians (0 is at the 3 o'clock position of the arc's circle)\n * @param endAngle {Number} The ending angle, in radians\n * @param anticlockwise {Boolean} Optional. Specifies whether the drawing should be counterclockwise or clockwise. False is default, and indicates clockwise, while true indicates counter-clockwise.\n * @return {Graphics}\n */\nPIXI.Graphics.prototype.arc = function(cx, cy, radius, startAngle, endAngle, anticlockwise)\n{\n    var startX = cx + Math.cos(startAngle) * radius;\n    var startY = cy + Math.sin(startAngle) * radius;\n   \n    var points = this.currentPath.shape.points;\n\n    if(points.length === 0)\n    {\n        this.moveTo(startX, startY);\n        points = this.currentPath.shape.points;\n    }\n    else if( points[points.length-2] !== startX || points[points.length-1] !== startY)\n    {\n        points.push(startX, startY);\n    }\n  \n    if (startAngle === endAngle)return this;\n\n    if( !anticlockwise && endAngle <= startAngle )\n    {\n        endAngle += Math.PI * 2;\n    }\n    else if( anticlockwise && startAngle <= endAngle )\n    {\n        startAngle += Math.PI * 2;\n    }\n\n    var sweep = anticlockwise ? (startAngle - endAngle) *-1 : (endAngle - startAngle);\n    var segs =  ( Math.abs(sweep)/ (Math.PI * 2) ) * 40;\n\n    if( sweep === 0 ) return this;\n\n    var theta = sweep/(segs*2);\n    var theta2 = theta*2;\n\n    var cTheta = Math.cos(theta);\n    var sTheta = Math.sin(theta);\n    \n    var segMinus = segs - 1;\n\n    var remainder = ( segMinus % 1 ) / segMinus;\n\n    for(var i=0; i<=segMinus; i++)\n    {\n        var real =  i + remainder * i;\n\n    \n        var angle = ((theta) + startAngle + (theta2 * real));\n\n        var c = Math.cos(angle);\n        var s = -Math.sin(angle);\n\n        points.push(( (cTheta *  c) + (sTheta * s) ) * radius + cx,\n                    ( (cTheta * -s) + (sTheta * c) ) * radius + cy);\n    }\n\n    this.dirty = true;\n\n    return this;\n};\n\n/**\n * Specifies a simple one-color fill that subsequent calls to other Graphics methods\n * (such as lineTo() or drawCircle()) use when drawing.\n *\n * @method beginFill\n * @param color {Number} the color of the fill\n * @param alpha {Number} the alpha of the fill\n * @return {Graphics}\n */\nPIXI.Graphics.prototype.beginFill = function(color, alpha)\n{\n    this.filling = true;\n    this.fillColor = color || 0;\n    this.fillAlpha = (alpha === undefined) ? 1 : alpha;\n\n    if(this.currentPath)\n    {\n        if(this.currentPath.shape.points.length <= 2)\n        {\n            this.currentPath.fill = this.filling;\n            this.currentPath.fillColor = this.fillColor;\n            this.currentPath.fillAlpha = this.fillAlpha;\n        }\n    }\n    return this;\n};\n\n/**\n * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.\n *\n * @method endFill\n * @return {Graphics}\n */\nPIXI.Graphics.prototype.endFill = function()\n{\n    this.filling = false;\n    this.fillColor = null;\n    this.fillAlpha = 1;\n\n    return this;\n};\n\n/**\n * @method drawRect\n *\n * @param x {Number} The X coord of the top-left of the rectangle\n * @param y {Number} The Y coord of the top-left of the rectangle\n * @param width {Number} The width of the rectangle\n * @param height {Number} The height of the rectangle\n * @return {Graphics}\n */\nPIXI.Graphics.prototype.drawRect = function( x, y, width, height )\n{\n    this.drawShape(new PIXI.Rectangle(x,y, width, height));\n\n    return this;\n};\n\n/**\n * @method drawRoundedRect\n *\n * @param x {Number} The X coord of the top-left of the rectangle\n * @param y {Number} The Y coord of the top-left of the rectangle\n * @param width {Number} The width of the rectangle\n * @param height {Number} The height of the rectangle\n * @param radius {Number} Radius of the rectangle corners\n */\nPIXI.Graphics.prototype.drawRoundedRect = function( x, y, width, height, radius )\n{\n    this.drawShape(new PIXI.RoundedRectangle(x, y, width, height, radius));\n\n    return this;\n};\n\n/**\n * Draws a circle.\n *\n * @method drawCircle\n * @param x {Number} The X coordinate of the center of the circle\n * @param y {Number} The Y coordinate of the center of the circle\n * @param radius {Number} The radius of the circle\n * @return {Graphics}\n */\nPIXI.Graphics.prototype.drawCircle = function(x, y, radius)\n{\n    this.drawShape(new PIXI.Circle(x,y, radius));\n\n    return this;\n};\n\n/**\n * Draws an ellipse.\n *\n * @method drawEllipse\n * @param x {Number} The X coordinate of the center of the ellipse\n * @param y {Number} The Y coordinate of the center of the ellipse\n * @param width {Number} The half width of the ellipse\n * @param height {Number} The half height of the ellipse\n * @return {Graphics}\n */\nPIXI.Graphics.prototype.drawEllipse = function(x, y, width, height)\n{\n    this.drawShape(new PIXI.Ellipse(x, y, width, height));\n\n    return this;\n};\n\n/**\n * Draws a polygon using the given path.\n *\n * @method drawPolygon\n * @param path {Array} The path data used to construct the polygon.\n * @return {Graphics}\n */\nPIXI.Graphics.prototype.drawPolygon = function(path)\n{\n    if(!(path instanceof Array))path = Array.prototype.slice.call(arguments);\n    this.drawShape(new PIXI.Polygon(path));\n    return this;\n};\n\n/**\n * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n *\n * @method clear\n * @return {Graphics}\n */\nPIXI.Graphics.prototype.clear = function()\n{\n    this.lineWidth = 0;\n    this.filling = false;\n\n    this.dirty = true;\n    this.clearDirty = true;\n    this.graphicsData = [];\n\n    return this;\n};\n\n/**\n * Useful function that returns a texture of the graphics object that can then be used to create sprites\n * This can be quite useful if your geometry is complicated and needs to be reused multiple times.\n *\n * @method generateTexture\n * @param resolution {Number} The resolution of the texture being generated\n * @param scaleMode {Number} Should be one of the PIXI.scaleMode consts\n * @return {Texture} a texture of the graphics object\n */\nPIXI.Graphics.prototype.generateTexture = function(resolution, scaleMode)\n{\n    resolution = resolution || 1;\n\n    var bounds = this.getBounds();\n   \n    var canvasBuffer = new PIXI.CanvasBuffer(bounds.width * resolution, bounds.height * resolution);\n    \n    var texture = PIXI.Texture.fromCanvas(canvasBuffer.canvas, scaleMode);\n    texture.baseTexture.resolution = resolution;\n\n    canvasBuffer.context.scale(resolution, resolution);\n\n    canvasBuffer.context.translate(-bounds.x,-bounds.y);\n    \n    PIXI.CanvasGraphics.renderGraphics(this, canvasBuffer.context);\n\n    return texture;\n};\n\n/**\n* Renders the object using the WebGL renderer\n*\n* @method _renderWebGL\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.Graphics.prototype._renderWebGL = function(renderSession)\n{\n    // if the sprite is not visible or the alpha is 0 then no need to render this element\n    if(this.visible === false || this.alpha === 0 || this.isMask === true)return;\n\n    if(this._cacheAsBitmap)\n    {\n\n        if(this.dirty || this.cachedSpriteDirty)\n        {\n\n            this._generateCachedSprite();\n   \n            // we will also need to update the texture on the gpu too!\n            this.updateCachedSpriteTexture();\n\n            this.cachedSpriteDirty = false;\n            this.dirty = false;\n        }\n\n        this._cachedSprite.worldAlpha = this.worldAlpha;\n        PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, renderSession);\n\n        return;\n    }\n    else\n    {\n        renderSession.spriteBatch.stop();\n        renderSession.blendModeManager.setBlendMode(this.blendMode);\n\n        if(this._mask)renderSession.maskManager.pushMask(this._mask, renderSession);\n        if(this._filters)renderSession.filterManager.pushFilter(this._filterBlock);\n      \n        // check blend mode\n        if(this.blendMode !== renderSession.spriteBatch.currentBlendMode)\n        {\n            renderSession.spriteBatch.currentBlendMode = this.blendMode;\n            var blendModeWebGL = PIXI.blendModesWebGL[renderSession.spriteBatch.currentBlendMode];\n            renderSession.spriteBatch.gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]);\n        }\n        \n        // check if the webgl graphic needs to be updated\n        if(this.webGLDirty)\n        {\n            this.dirty = true;\n            this.webGLDirty = false;\n        }\n        \n        PIXI.WebGLGraphics.renderGraphics(this, renderSession);\n        \n        // only render if it has children!\n        if(this.children.length)\n        {\n            renderSession.spriteBatch.start();\n\n             // simple render children!\n            for(var i=0, j=this.children.length; i<j; i++)\n            {\n                this.children[i]._renderWebGL(renderSession);\n            }\n\n            renderSession.spriteBatch.stop();\n        }\n\n        if(this._filters)renderSession.filterManager.popFilter();\n        if(this._mask)renderSession.maskManager.popMask(this.mask, renderSession);\n          \n        renderSession.drawCount++;\n\n        renderSession.spriteBatch.start();\n    }\n};\n\n/**\n* Renders the object using the Canvas renderer\n*\n* @method _renderCanvas\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.Graphics.prototype._renderCanvas = function(renderSession)\n{\n    // if the sprite is not visible or the alpha is 0 then no need to render this element\n    if(this.visible === false || this.alpha === 0 || this.isMask === true)return;\n    \n    if(this._cacheAsBitmap)\n    {\n        if(this.dirty || this.cachedSpriteDirty)\n        {\n            this._generateCachedSprite();\n   \n            // we will also need to update the texture\n            this.updateCachedSpriteTexture();\n\n            this.cachedSpriteDirty = false;\n            this.dirty = false;\n        }\n\n        this._cachedSprite.alpha = this.alpha;\n        PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, renderSession);\n\n        return;\n    }\n    else\n    {\n        var context = renderSession.context;\n        var transform = this.worldTransform;\n        \n        if(this.blendMode !== renderSession.currentBlendMode)\n        {\n            renderSession.currentBlendMode = this.blendMode;\n            context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode];\n        }\n\n        if(this._mask)\n        {\n            renderSession.maskManager.pushMask(this._mask, renderSession);\n        }\n\n        var resolution = renderSession.resolution;\n        context.setTransform(transform.a * resolution,\n                             transform.b * resolution,\n                             transform.c * resolution,\n                             transform.d * resolution,\n                             transform.tx * resolution,\n                             transform.ty * resolution);\n\n        PIXI.CanvasGraphics.renderGraphics(this, context);\n\n         // simple render children!\n        for(var i=0, j=this.children.length; i<j; i++)\n        {\n            this.children[i]._renderCanvas(renderSession);\n        }\n\n        if(this._mask)\n        {\n            renderSession.maskManager.popMask(renderSession);\n        }\n    }\n};\n\n/**\n * Retrieves the bounds of the graphic shape as a rectangle object\n *\n * @method getBounds\n * @return {Rectangle} the rectangular bounding area\n */\nPIXI.Graphics.prototype.getBounds = function( matrix )\n{\n    // return an empty object if the item is a mask!\n    if(this.isMask)return PIXI.EmptyRectangle;\n\n    if(this.dirty)\n    {\n        this.updateLocalBounds();\n        this.webGLDirty = true;\n        this.cachedSpriteDirty = true;\n        this.dirty = false;\n    }\n\n    var bounds = this._localBounds;\n\n    var w0 = bounds.x;\n    var w1 = bounds.width + bounds.x;\n\n    var h0 = bounds.y;\n    var h1 = bounds.height + bounds.y;\n\n    var worldTransform = matrix || this.worldTransform;\n\n    var a = worldTransform.a;\n    var b = worldTransform.b;\n    var c = worldTransform.c;\n    var d = worldTransform.d;\n    var tx = worldTransform.tx;\n    var ty = worldTransform.ty;\n\n    var x1 = a * w1 + c * h1 + tx;\n    var y1 = d * h1 + b * w1 + ty;\n\n    var x2 = a * w0 + c * h1 + tx;\n    var y2 = d * h1 + b * w0 + ty;\n\n    var x3 = a * w0 + c * h0 + tx;\n    var y3 = d * h0 + b * w0 + ty;\n\n    var x4 =  a * w1 + c * h0 + tx;\n    var y4 =  d * h0 + b * w1 + ty;\n\n    var maxX = x1;\n    var maxY = y1;\n\n    var minX = x1;\n    var minY = y1;\n\n    minX = x2 < minX ? x2 : minX;\n    minX = x3 < minX ? x3 : minX;\n    minX = x4 < minX ? x4 : minX;\n\n    minY = y2 < minY ? y2 : minY;\n    minY = y3 < minY ? y3 : minY;\n    minY = y4 < minY ? y4 : minY;\n\n    maxX = x2 > maxX ? x2 : maxX;\n    maxX = x3 > maxX ? x3 : maxX;\n    maxX = x4 > maxX ? x4 : maxX;\n\n    maxY = y2 > maxY ? y2 : maxY;\n    maxY = y3 > maxY ? y3 : maxY;\n    maxY = y4 > maxY ? y4 : maxY;\n\n    this._bounds.x = minX;\n    this._bounds.width = maxX - minX;\n\n    this._bounds.y = minY;\n    this._bounds.height = maxY - minY;\n\n    return  this._bounds;\n};\n\n/**\n * Update the bounds of the object\n *\n * @method updateLocalBounds\n */\nPIXI.Graphics.prototype.updateLocalBounds = function()\n{\n    var minX = Infinity;\n    var maxX = -Infinity;\n\n    var minY = Infinity;\n    var maxY = -Infinity;\n\n    if(this.graphicsData.length)\n    {\n        var shape, points, x, y, w, h;\n\n        for (var i = 0; i < this.graphicsData.length; i++) {\n            var data = this.graphicsData[i];\n            var type = data.type;\n            var lineWidth = data.lineWidth;\n            shape = data.shape;\n           \n\n            if(type === PIXI.Graphics.RECT || type === PIXI.Graphics.RREC)\n            {\n                x = shape.x - lineWidth/2;\n                y = shape.y - lineWidth/2;\n                w = shape.width + lineWidth;\n                h = shape.height + lineWidth;\n\n                minX = x < minX ? x : minX;\n                maxX = x + w > maxX ? x + w : maxX;\n\n                minY = y < minY ? y : minY;\n                maxY = y + h > maxY ? y + h : maxY;\n            }\n            else if(type === PIXI.Graphics.CIRC)\n            {\n                x = shape.x;\n                y = shape.y;\n                w = shape.radius + lineWidth/2;\n                h = shape.radius + lineWidth/2;\n\n                minX = x - w < minX ? x - w : minX;\n                maxX = x + w > maxX ? x + w : maxX;\n\n                minY = y - h < minY ? y - h : minY;\n                maxY = y + h > maxY ? y + h : maxY;\n            }\n            else if(type === PIXI.Graphics.ELIP)\n            {\n                x = shape.x;\n                y = shape.y;\n                w = shape.width + lineWidth/2;\n                h = shape.height + lineWidth/2;\n\n                minX = x - w < minX ? x - w : minX;\n                maxX = x + w > maxX ? x + w : maxX;\n\n                minY = y - h < minY ? y - h : minY;\n                maxY = y + h > maxY ? y + h : maxY;\n            }\n            else\n            {\n                // POLY\n                points = shape.points;\n                \n                for (var j = 0; j < points.length; j+=2)\n                {\n\n                    x = points[j];\n                    y = points[j+1];\n                    minX = x-lineWidth < minX ? x-lineWidth : minX;\n                    maxX = x+lineWidth > maxX ? x+lineWidth : maxX;\n\n                    minY = y-lineWidth < minY ? y-lineWidth : minY;\n                    maxY = y+lineWidth > maxY ? y+lineWidth : maxY;\n                }\n            }\n        }\n    }\n    else\n    {\n        minX = 0;\n        maxX = 0;\n        minY = 0;\n        maxY = 0;\n    }\n\n    var padding = this.boundsPadding;\n    \n    this._localBounds.x = minX - padding;\n    this._localBounds.width = (maxX - minX) + padding * 2;\n\n    this._localBounds.y = minY - padding;\n    this._localBounds.height = (maxY - minY) + padding * 2;\n};\n\n/**\n * Generates the cached sprite when the sprite has cacheAsBitmap = true\n *\n * @method _generateCachedSprite\n * @private\n */\nPIXI.Graphics.prototype._generateCachedSprite = function()\n{\n    var bounds = this.getLocalBounds();\n\n    if(!this._cachedSprite)\n    {\n        var canvasBuffer = new PIXI.CanvasBuffer(bounds.width, bounds.height);\n        var texture = PIXI.Texture.fromCanvas(canvasBuffer.canvas);\n        \n        this._cachedSprite = new PIXI.Sprite(texture);\n        this._cachedSprite.buffer = canvasBuffer;\n\n        this._cachedSprite.worldTransform = this.worldTransform;\n    }\n    else\n    {\n        this._cachedSprite.buffer.resize(bounds.width, bounds.height);\n    }\n\n    // leverage the anchor to account for the offset of the element\n    this._cachedSprite.anchor.x = -( bounds.x / bounds.width );\n    this._cachedSprite.anchor.y = -( bounds.y / bounds.height );\n\n   // this._cachedSprite.buffer.context.save();\n    this._cachedSprite.buffer.context.translate(-bounds.x,-bounds.y);\n    \n    // make sure we set the alpha of the graphics to 1 for the render.. \n    this.worldAlpha = 1;\n\n    // now render the graphic..\n    PIXI.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context);\n    this._cachedSprite.alpha = this.alpha;\n};\n\n/**\n * Updates texture size based on canvas size\n *\n * @method updateCachedSpriteTexture\n * @private\n */\nPIXI.Graphics.prototype.updateCachedSpriteTexture = function()\n{\n    var cachedSprite = this._cachedSprite;\n    var texture = cachedSprite.texture;\n    var canvas = cachedSprite.buffer.canvas;\n\n    texture.baseTexture.width = canvas.width;\n    texture.baseTexture.height = canvas.height;\n    texture.crop.width = texture.frame.width = canvas.width;\n    texture.crop.height = texture.frame.height = canvas.height;\n\n    cachedSprite._width = canvas.width;\n    cachedSprite._height = canvas.height;\n\n    // update the dirty base textures\n    texture.baseTexture.dirty();\n};\n\n/**\n * Destroys a previous cached sprite.\n *\n * @method destroyCachedSprite\n */\nPIXI.Graphics.prototype.destroyCachedSprite = function()\n{\n    this._cachedSprite.texture.destroy(true);\n\n    // let the gc collect the unused sprite\n    // TODO could be object pooled!\n    this._cachedSprite = null;\n};\n\n/**\n * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n *\n * @method drawShape\n * @param {Circle|Rectangle|Ellipse|Line|Polygon} shape The Shape object to draw.\n * @return {GraphicsData} The generated GraphicsData object.\n */\nPIXI.Graphics.prototype.drawShape = function(shape)\n{\n    if(this.currentPath)\n    {\n        // check current path!\n        if(this.currentPath.shape.points.length <= 2)this.graphicsData.pop();\n    }\n\n    this.currentPath = null;\n\n    var data = new PIXI.GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, shape);\n    \n    this.graphicsData.push(data);\n    \n    if(data.type === PIXI.Graphics.POLY)\n    {\n        data.shape.closed = this.filling;\n        this.currentPath = data;\n    }\n\n    this.dirty = true;\n\n    return data;\n};\n\n/**\n * A GraphicsData object.\n * \n * @class GraphicsData\n * @constructor\n */\nPIXI.GraphicsData = function(lineWidth, lineColor, lineAlpha, fillColor, fillAlpha, fill, shape)\n{\n    this.lineWidth = lineWidth;\n    this.lineColor = lineColor;\n    this.lineAlpha = lineAlpha;\n\n    this.fillColor = fillColor;\n    this.fillAlpha = fillAlpha;\n    this.fill = fill;\n\n    this.shape = shape;\n    this.type = shape.type;\n};\n\n// SOME TYPES:\nPIXI.Graphics.POLY = 0;\nPIXI.Graphics.RECT = 1;\nPIXI.Graphics.CIRC = 2;\nPIXI.Graphics.ELIP = 3;\nPIXI.Graphics.RREC = 4;\n\nPIXI.Polygon.prototype.type = PIXI.Graphics.POLY;\nPIXI.Rectangle.prototype.type = PIXI.Graphics.RECT;\nPIXI.Circle.prototype.type = PIXI.Graphics.CIRC;\nPIXI.Ellipse.prototype.type = PIXI.Graphics.ELIP;\nPIXI.RoundedRectangle.prototype.type = PIXI.Graphics.RREC;\n\n\n/**\n * @author Mat Groves http://matgroves.com/\n */\n\n /**\n * \n * @class Strip\n * @extends DisplayObjectContainer\n * @constructor\n * @param texture {Texture} The texture to use\n * @param width {Number} the width \n * @param height {Number} the height\n * \n */\nPIXI.Strip = function(texture)\n{\n    PIXI.DisplayObjectContainer.call( this );\n    \n\n    /**\n     * The texture of the strip\n     *\n     * @property texture\n     * @type Texture\n     */\n    this.texture = texture;\n\n    // set up the main bits..\n    this.uvs = new PIXI.Float32Array([0, 1,\n                                      1, 1,\n                                      1, 0,\n                                      0, 1]);\n\n    this.verticies = new PIXI.Float32Array([0, 0,\n                                            100, 0,\n                                            100, 100,\n                                            0, 100]);\n\n    this.colors = new PIXI.Float32Array([1, 1, 1, 1]);\n\n    this.indices = new PIXI.Uint16Array([0, 1, 2, 3]);\n    \n    /**\n     * Whether the strip is dirty or not\n     *\n     * @property dirty\n     * @type Boolean\n     */\n    this.dirty = true;\n\n    /**\n     * The blend mode to be applied to the sprite. Set to PIXI.blendModes.NORMAL to remove any blend mode.\n     *\n     * @property blendMode\n     * @type Number\n     * @default PIXI.blendModes.NORMAL;\n     */\n    this.blendMode = PIXI.blendModes.NORMAL;\n    \n    /**\n     * if you need a padding, not yet implemented\n     *\n     * @property padding\n     * @type Number\n     */\n    this.padding = 0;\n     // NYI, TODO padding ?\n\n};\n\n// constructor\nPIXI.Strip.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);\nPIXI.Strip.prototype.constructor = PIXI.Strip;\n\nPIXI.Strip.prototype._renderWebGL = function(renderSession)\n{\n    // if the sprite is not visible or the alpha is 0 then no need to render this element\n    if(!this.visible || this.alpha <= 0)return;\n    // render triangle strip..\n\n    renderSession.spriteBatch.stop();\n\n    // init! init!\n    if(!this._vertexBuffer)this._initWebGL(renderSession);\n    \n    renderSession.shaderManager.setShader(renderSession.shaderManager.stripShader);\n\n    this._renderStrip(renderSession);\n\n    ///renderSession.shaderManager.activateDefaultShader();\n\n    renderSession.spriteBatch.start();\n\n    //TODO check culling  \n};\n\nPIXI.Strip.prototype._initWebGL = function(renderSession)\n{\n    // build the strip!\n    var gl = renderSession.gl;\n    \n    this._vertexBuffer = gl.createBuffer();\n    this._indexBuffer = gl.createBuffer();\n    this._uvBuffer = gl.createBuffer();\n    this._colorBuffer = gl.createBuffer();\n    \n    gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, this.verticies, gl.DYNAMIC_DRAW);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this._uvBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER,  this.uvs, gl.STATIC_DRAW);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this._colorBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, this.colors, gl.STATIC_DRAW);\n \n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);\n};\n\nPIXI.Strip.prototype._renderStrip = function(renderSession)\n{\n    var gl = renderSession.gl;\n    var projection = renderSession.projection,\n        offset = renderSession.offset,\n        shader = renderSession.shaderManager.stripShader;\n\n\n    // gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mat4Real);\n\n    renderSession.blendModeManager.setBlendMode(this.blendMode);\n    \n\n    // set uniforms\n    gl.uniformMatrix3fv(shader.translationMatrix, false, this.worldTransform.toArray(true));\n    gl.uniform2f(shader.projectionVector, projection.x, -projection.y);\n    gl.uniform2f(shader.offsetVector, -offset.x, -offset.y);\n    gl.uniform1f(shader.alpha, this.worldAlpha);\n\n    if(!this.dirty)\n    {\n        \n        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.verticies);\n        gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 0, 0);\n        \n        // update the uvs\n        gl.bindBuffer(gl.ARRAY_BUFFER, this._uvBuffer);\n        gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, false, 0, 0);\n            \n        gl.activeTexture(gl.TEXTURE0);\n\n        // check if a texture is dirty..\n        if(this.texture.baseTexture._dirty[gl.id])\n        {\n            renderSession.renderer.updateTexture(this.texture.baseTexture);\n        }\n        else\n        {\n            // bind the current texture\n            gl.bindTexture(gl.TEXTURE_2D, this.texture.baseTexture._glTextures[gl.id]);\n        }\n    \n        // dont need to upload!\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);\n    \n    \n    }\n    else\n    {\n\n        this.dirty = false;\n        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, this.verticies, gl.STATIC_DRAW);\n        gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 0, 0);\n        \n        // update the uvs\n        gl.bindBuffer(gl.ARRAY_BUFFER, this._uvBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, this.uvs, gl.STATIC_DRAW);\n        gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, false, 0, 0);\n            \n        gl.activeTexture(gl.TEXTURE0);\n\n        // check if a texture is dirty..\n        if(this.texture.baseTexture._dirty[gl.id])\n        {\n            renderSession.renderer.updateTexture(this.texture.baseTexture);\n        }\n        else\n        {\n            gl.bindTexture(gl.TEXTURE_2D, this.texture.baseTexture._glTextures[gl.id]);\n        }\n    \n        // dont need to upload!\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);\n        \n    }\n    //console.log(gl.TRIANGLE_STRIP)\n    //\n    //\n    gl.drawElements(gl.TRIANGLE_STRIP, this.indices.length, gl.UNSIGNED_SHORT, 0);\n    \n  \n};\n\n\n\nPIXI.Strip.prototype._renderCanvas = function(renderSession)\n{\n    var context = renderSession.context;\n    \n    var transform = this.worldTransform;\n\n    if (renderSession.roundPixels)\n    {\n        context.setTransform(transform.a, transform.b, transform.c, transform.d, transform.tx | 0, transform.ty | 0);\n    }\n    else\n    {\n        context.setTransform(transform.a, transform.b, transform.c, transform.d, transform.tx, transform.ty);\n    }\n        \n    var strip = this;\n    // draw triangles!!\n    var verticies = strip.verticies;\n    var uvs = strip.uvs;\n\n    var length = verticies.length/2;\n    this.count++;\n\n    for (var i = 0; i < length-2; i++)\n    {\n        // draw some triangles!\n        var index = i*2;\n\n        var x0 = verticies[index],   x1 = verticies[index+2], x2 = verticies[index+4];\n        var y0 = verticies[index+1], y1 = verticies[index+3], y2 = verticies[index+5];\n\n        if(this.padding > 0)\n        {\n            var centerX = (x0 + x1 + x2)/3;\n            var centerY = (y0 + y1 + y2)/3;\n\n            var normX = x0 - centerX;\n            var normY = y0 - centerY;\n\n            var dist = Math.sqrt( normX * normX + normY * normY );\n            x0 = centerX + (normX / dist) * (dist + 3);\n            y0 = centerY + (normY / dist) * (dist + 3);\n\n            // \n            \n            normX = x1 - centerX;\n            normY = y1 - centerY;\n\n            dist = Math.sqrt( normX * normX + normY * normY );\n            x1 = centerX + (normX / dist) * (dist + 3);\n            y1 = centerY + (normY / dist) * (dist + 3);\n\n            normX = x2 - centerX;\n            normY = y2 - centerY;\n\n            dist = Math.sqrt( normX * normX + normY * normY );\n            x2 = centerX + (normX / dist) * (dist + 3);\n            y2 = centerY + (normY / dist) * (dist + 3);\n        }\n\n        var u0 = uvs[index] * strip.texture.width,   u1 = uvs[index+2] * strip.texture.width, u2 = uvs[index+4]* strip.texture.width;\n        var v0 = uvs[index+1]* strip.texture.height, v1 = uvs[index+3] * strip.texture.height, v2 = uvs[index+5]* strip.texture.height;\n\n        context.save();\n        context.beginPath();\n\n\n        context.moveTo(x0, y0);\n        context.lineTo(x1, y1);\n        context.lineTo(x2, y2);\n\n        context.closePath();\n\n        context.clip();\n\n        // Compute matrix transform\n        var delta = u0*v1 + v0*u2 + u1*v2 - v1*u2 - v0*u1 - u0*v2;\n        var deltaA = x0*v1 + v0*x2 + x1*v2 - v1*x2 - v0*x1 - x0*v2;\n        var deltaB = u0*x1 + x0*u2 + u1*x2 - x1*u2 - x0*u1 - u0*x2;\n        var deltaC = u0*v1*x2 + v0*x1*u2 + x0*u1*v2 - x0*v1*u2 - v0*u1*x2 - u0*x1*v2;\n        var deltaD = y0*v1 + v0*y2 + y1*v2 - v1*y2 - v0*y1 - y0*v2;\n        var deltaE = u0*y1 + y0*u2 + u1*y2 - y1*u2 - y0*u1 - u0*y2;\n        var deltaF = u0*v1*y2 + v0*y1*u2 + y0*u1*v2 - y0*v1*u2 - v0*u1*y2 - u0*y1*v2;\n\n        context.transform(deltaA / delta, deltaD / delta,\n                            deltaB / delta, deltaE / delta,\n                            deltaC / delta, deltaF / delta);\n\n        context.drawImage(strip.texture.baseTexture.source, 0, 0);\n        context.restore();\n    }\n};\n\n\n/**\n * Renders a flat strip\n *\n * @method renderStripFlat\n * @param strip {Strip} The Strip to render\n * @private\n */\nPIXI.Strip.prototype.renderStripFlat = function(strip)\n{\n    var context = this.context;\n    var verticies = strip.verticies;\n\n    var length = verticies.length/2;\n    this.count++;\n\n    context.beginPath();\n    for (var i=1; i < length-2; i++)\n    {\n        // draw some triangles!\n        var index = i*2;\n\n        var x0 = verticies[index],   x1 = verticies[index+2], x2 = verticies[index+4];\n        var y0 = verticies[index+1], y1 = verticies[index+3], y2 = verticies[index+5];\n\n        context.moveTo(x0, y0);\n        context.lineTo(x1, y1);\n        context.lineTo(x2, y2);\n    }\n\n    context.fillStyle = \"#FF0000\";\n    context.fill();\n    context.closePath();\n};\n\n/*\nPIXI.Strip.prototype.setTexture = function(texture)\n{\n    //TODO SET THE TEXTURES\n    //TODO VISIBILITY\n\n    // stop current texture\n    this.texture = texture;\n    this.width   = texture.frame.width;\n    this.height  = texture.frame.height;\n    this.updateFrame = true;\n};\n*/\n\n/**\n * When the texture is updated, this event will fire to update the scale and frame\n *\n * @method onTextureUpdate\n * @param event\n * @private\n */\n\nPIXI.Strip.prototype.onTextureUpdate = function()\n{\n    this.updateFrame = true;\n};\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n * @copyright Mat Groves, Rovanion Luckey\n */\n\n/**\n *\n * @class Rope\n * @constructor\n * @extends Strip\n * @param {Texture} texture - The texture to use on the rope.\n * @param {Array} points - An array of {PIXI.Point}.\n *\n */\nPIXI.Rope = function(texture, points)\n{\n    PIXI.Strip.call( this, texture );\n    this.points = points;\n\n    this.verticies = new PIXI.Float32Array(points.length * 4);\n    this.uvs = new PIXI.Float32Array(points.length * 4);\n    this.colors = new PIXI.Float32Array(points.length * 2);\n    this.indices = new PIXI.Uint16Array(points.length * 2);\n\n\n    this.refresh();\n};\n\n\n// constructor\nPIXI.Rope.prototype = Object.create( PIXI.Strip.prototype );\nPIXI.Rope.prototype.constructor = PIXI.Rope;\n\n/*\n * Refreshes\n *\n * @method refresh\n */\nPIXI.Rope.prototype.refresh = function()\n{\n    var points = this.points;\n    if(points.length < 1) return;\n\n    var uvs = this.uvs;\n\n    var lastPoint = points[0];\n    var indices = this.indices;\n    var colors = this.colors;\n\n    this.count-=0.2;\n\n    uvs[0] = 0;\n    uvs[1] = 0;\n    uvs[2] = 0;\n    uvs[3] = 1;\n\n    colors[0] = 1;\n    colors[1] = 1;\n\n    indices[0] = 0;\n    indices[1] = 1;\n\n    var total = points.length,\n        point, index, amount;\n\n    for (var i = 1; i < total; i++)\n    {\n        point = points[i];\n        index = i * 4;\n        // time to do some smart drawing!\n        amount = i / (total-1);\n\n        if(i%2)\n        {\n            uvs[index] = amount;\n            uvs[index+1] = 0;\n\n            uvs[index+2] = amount;\n            uvs[index+3] = 1;\n        }\n        else\n        {\n            uvs[index] = amount;\n            uvs[index+1] = 0;\n\n            uvs[index+2] = amount;\n            uvs[index+3] = 1;\n        }\n\n        index = i * 2;\n        colors[index] = 1;\n        colors[index+1] = 1;\n\n        index = i * 2;\n        indices[index] = index;\n        indices[index + 1] = index + 1;\n\n        lastPoint = point;\n    }\n};\n\n/*\n * Updates the object transform for rendering\n *\n * @method updateTransform\n * @private\n */\nPIXI.Rope.prototype.updateTransform = function()\n{\n\n    var points = this.points;\n    if(points.length < 1)return;\n\n    var lastPoint = points[0];\n    var nextPoint;\n    var perp = {x:0, y:0};\n\n    this.count-=0.2;\n\n    var verticies = this.verticies;\n    var total = points.length,\n        point, index, ratio, perpLength, num;\n\n    for (var i = 0; i < total; i++)\n    {\n        point = points[i];\n        index = i * 4;\n\n        if(i < points.length-1)\n        {\n            nextPoint = points[i+1];\n        }\n        else\n        {\n            nextPoint = point;\n        }\n\n        perp.y = -(nextPoint.x - lastPoint.x);\n        perp.x = nextPoint.y - lastPoint.y;\n\n        ratio = (1 - (i / (total-1))) * 10;\n\n        if(ratio > 1) ratio = 1;\n\n        perpLength = Math.sqrt(perp.x * perp.x + perp.y * perp.y);\n        num = this.texture.height / 2; //(20 + Math.abs(Math.sin((i + this.count) * 0.3) * 50) )* ratio;\n        perp.x /= perpLength;\n        perp.y /= perpLength;\n\n        perp.x *= num;\n        perp.y *= num;\n\n        verticies[index] = point.x + perp.x;\n        verticies[index+1] = point.y + perp.y;\n        verticies[index+2] = point.x - perp.x;\n        verticies[index+3] = point.y - perp.y;\n\n        lastPoint = point;\n    }\n\n    PIXI.DisplayObjectContainer.prototype.updateTransform.call( this );\n};\n/*\n * Sets the texture that the Rope will use\n *\n * @method setTexture\n * @param texture {Texture} the texture that will be used\n */\nPIXI.Rope.prototype.setTexture = function(texture)\n{\n    // stop current texture\n    this.texture = texture;\n    //this.updateFrame = true;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/\n */\n\n/**\n * A tiling sprite is a fast way of rendering a tiling image\n *\n * @class TilingSprite\n * @extends Sprite\n * @constructor\n * @param texture {Texture} the texture of the tiling sprite\n * @param width {Number}  the width of the tiling sprite\n * @param height {Number} the height of the tiling sprite\n */\nPIXI.TilingSprite = function(texture, width, height)\n{\n    PIXI.Sprite.call( this, texture);\n\n    /**\n     * The with of the tiling sprite\n     *\n     * @property width\n     * @type Number\n     */\n    this._width = width || 100;\n\n    /**\n     * The height of the tiling sprite\n     *\n     * @property height\n     * @type Number\n     */\n    this._height = height || 100;\n\n    /**\n     * The scaling of the image that is being tiled\n     *\n     * @property tileScale\n     * @type Point\n     */\n    this.tileScale = new PIXI.Point(1,1);\n\n    /**\n     * A point that represents the scale of the texture object\n     *\n     * @property tileScaleOffset\n     * @type Point\n     */\n    this.tileScaleOffset = new PIXI.Point(1,1);\n    \n    /**\n     * The offset position of the image that is being tiled\n     *\n     * @property tilePosition\n     * @type Point\n     */\n    this.tilePosition = new PIXI.Point(0,0);\n\n    /**\n     * Whether this sprite is renderable or not\n     *\n     * @property renderable\n     * @type Boolean\n     * @default true\n     */\n    this.renderable = true;\n\n    /**\n     * The tint applied to the sprite. This is a hex value\n     *\n     * @property tint\n     * @type Number\n     * @default 0xFFFFFF\n     */\n    this.tint = 0xFFFFFF;\n    \n    /**\n     * The blend mode to be applied to the sprite\n     *\n     * @property blendMode\n     * @type Number\n     * @default PIXI.blendModes.NORMAL;\n     */\n    this.blendMode = PIXI.blendModes.NORMAL;\n\n    \n\n};\n\n// constructor\nPIXI.TilingSprite.prototype = Object.create(PIXI.Sprite.prototype);\nPIXI.TilingSprite.prototype.constructor = PIXI.TilingSprite;\n\n\n/**\n * The width of the sprite, setting this will actually modify the scale to achieve the value set\n *\n * @property width\n * @type Number\n */\nObject.defineProperty(PIXI.TilingSprite.prototype, 'width', {\n    get: function() {\n        return this._width;\n    },\n    set: function(value) {\n        \n        this._width = value;\n    }\n});\n\n/**\n * The height of the TilingSprite, setting this will actually modify the scale to achieve the value set\n *\n * @property height\n * @type Number\n */\nObject.defineProperty(PIXI.TilingSprite.prototype, 'height', {\n    get: function() {\n        return  this._height;\n    },\n    set: function(value) {\n        this._height = value;\n    }\n});\n\nPIXI.TilingSprite.prototype.setTexture = function(texture)\n{\n    if (this.texture === texture) return;\n\n    this.texture = texture;\n\n    this.refreshTexture = true;\n\n    this.cachedTint = 0xFFFFFF;\n};\n\n/**\n* Renders the object using the WebGL renderer\n*\n* @method _renderWebGL\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.TilingSprite.prototype._renderWebGL = function(renderSession)\n{\n    if (this.visible === false || this.alpha === 0) return;\n    var i,j;\n\n    if (this._mask)\n    {\n        renderSession.spriteBatch.stop();\n        renderSession.maskManager.pushMask(this.mask, renderSession);\n        renderSession.spriteBatch.start();\n    }\n\n    if (this._filters)\n    {\n        renderSession.spriteBatch.flush();\n        renderSession.filterManager.pushFilter(this._filterBlock);\n    }\n\n   \n\n    if (!this.tilingTexture || this.refreshTexture)\n    {\n        this.generateTilingTexture(true);\n\n        if (this.tilingTexture && this.tilingTexture.needsUpdate)\n        {\n            //TODO - tweaking\n            PIXI.updateWebGLTexture(this.tilingTexture.baseTexture, renderSession.gl);\n            this.tilingTexture.needsUpdate = false;\n           // this.tilingTexture._uvs = null;\n        }\n    }\n    else\n    {\n        renderSession.spriteBatch.renderTilingSprite(this);\n    }\n    // simple render children!\n    for (i=0,j=this.children.length; i<j; i++)\n    {\n        this.children[i]._renderWebGL(renderSession);\n    }\n\n    renderSession.spriteBatch.stop();\n\n    if (this._filters) renderSession.filterManager.popFilter();\n    if (this._mask) renderSession.maskManager.popMask(this._mask, renderSession);\n    \n    renderSession.spriteBatch.start();\n};\n\n/**\n* Renders the object using the Canvas renderer\n*\n* @method _renderCanvas\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.TilingSprite.prototype._renderCanvas = function(renderSession)\n{\n    if (this.visible === false || this.alpha === 0)return;\n    \n    var context = renderSession.context;\n\n    if (this._mask)\n    {\n        renderSession.maskManager.pushMask(this._mask, context);\n    }\n\n    context.globalAlpha = this.worldAlpha;\n    \n    var transform = this.worldTransform;\n\n    var i,j;\n\n    var resolution = renderSession.resolution;\n\n    context.setTransform(transform.a * resolution,\n                         transform.c * resolution,\n                         transform.b * resolution,\n                         transform.d * resolution,\n                         transform.tx * resolution,\n                         transform.ty * resolution);\n\n    if (!this.__tilePattern ||  this.refreshTexture)\n    {\n        this.generateTilingTexture(false);\n    \n        if (this.tilingTexture)\n        {\n            this.__tilePattern = context.createPattern(this.tilingTexture.baseTexture.source, 'repeat');\n        }\n        else\n        {\n            return;\n        }\n    }\n\n    // check blend mode\n    if (this.blendMode !== renderSession.currentBlendMode)\n    {\n        renderSession.currentBlendMode = this.blendMode;\n        context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode];\n    }\n\n    var tilePosition = this.tilePosition;\n    var tileScale = this.tileScale;\n\n    tilePosition.x %= this.tilingTexture.baseTexture.width;\n    tilePosition.y %= this.tilingTexture.baseTexture.height;\n\n    // offset - make sure to account for the anchor point..\n    context.scale(tileScale.x,tileScale.y);\n    context.translate(tilePosition.x + (this.anchor.x * -this._width), tilePosition.y + (this.anchor.y * -this._height));\n\n    context.fillStyle = this.__tilePattern;\n\n    context.fillRect(-tilePosition.x,\n                    -tilePosition.y,\n                    this._width / tileScale.x,\n                    this._height / tileScale.y);\n\n    context.scale(1 / tileScale.x, 1 / tileScale.y);\n    context.translate(-tilePosition.x + (this.anchor.x * this._width), -tilePosition.y + (this.anchor.y * this._height));\n\n    if (this._mask)\n    {\n        renderSession.maskManager.popMask(renderSession.context);\n    }\n\n    for (i=0,j=this.children.length; i<j; i++)\n    {\n        this.children[i]._renderCanvas(renderSession);\n    }\n};\n\n\n/**\n* Returns the framing rectangle of the sprite as a PIXI.Rectangle object\n*\n* @method getBounds\n* @return {Rectangle} the framing rectangle\n*/\nPIXI.TilingSprite.prototype.getBounds = function()\n{\n    var width = this._width;\n    var height = this._height;\n\n    var w0 = width * (1-this.anchor.x);\n    var w1 = width * -this.anchor.x;\n\n    var h0 = height * (1-this.anchor.y);\n    var h1 = height * -this.anchor.y;\n\n    var worldTransform = this.worldTransform;\n\n    var a = worldTransform.a;\n    var b = worldTransform.b;\n    var c = worldTransform.c;\n    var d = worldTransform.d;\n    var tx = worldTransform.tx;\n    var ty = worldTransform.ty;\n    \n    var x1 = a * w1 + c * h1 + tx;\n    var y1 = d * h1 + b * w1 + ty;\n\n    var x2 = a * w0 + c * h1 + tx;\n    var y2 = d * h1 + b * w0 + ty;\n\n    var x3 = a * w0 + c * h0 + tx;\n    var y3 = d * h0 + b * w0 + ty;\n\n    var x4 =  a * w1 + c * h0 + tx;\n    var y4 =  d * h0 + b * w1 + ty;\n\n    var maxX = -Infinity;\n    var maxY = -Infinity;\n\n    var minX = Infinity;\n    var minY = Infinity;\n\n    minX = x1 < minX ? x1 : minX;\n    minX = x2 < minX ? x2 : minX;\n    minX = x3 < minX ? x3 : minX;\n    minX = x4 < minX ? x4 : minX;\n\n    minY = y1 < minY ? y1 : minY;\n    minY = y2 < minY ? y2 : minY;\n    minY = y3 < minY ? y3 : minY;\n    minY = y4 < minY ? y4 : minY;\n\n    maxX = x1 > maxX ? x1 : maxX;\n    maxX = x2 > maxX ? x2 : maxX;\n    maxX = x3 > maxX ? x3 : maxX;\n    maxX = x4 > maxX ? x4 : maxX;\n\n    maxY = y1 > maxY ? y1 : maxY;\n    maxY = y2 > maxY ? y2 : maxY;\n    maxY = y3 > maxY ? y3 : maxY;\n    maxY = y4 > maxY ? y4 : maxY;\n\n    var bounds = this._bounds;\n\n    bounds.x = minX;\n    bounds.width = maxX - minX;\n\n    bounds.y = minY;\n    bounds.height = maxY - minY;\n\n    // store a reference so that if this function gets called again in the render cycle we do not have to recalculate\n    this._currentBounds = bounds;\n\n    return bounds;\n};\n\n\n\n/**\n * When the texture is updated, this event will fire to update the scale and frame\n *\n * @method onTextureUpdate\n * @param event\n * @private\n */\nPIXI.TilingSprite.prototype.onTextureUpdate = function()\n{\n   // overriding the sprite version of this!\n};\n\n\n/**\n* \n* @method generateTilingTexture\n* \n* @param forcePowerOfTwo {Boolean} Whether we want to force the texture to be a power of two\n*/\nPIXI.TilingSprite.prototype.generateTilingTexture = function(forcePowerOfTwo)\n{\n    if (!this.texture.baseTexture.hasLoaded) return;\n\n    var texture = this.originalTexture || this.texture;\n    var frame = texture.frame;\n    var targetWidth, targetHeight;\n\n    //  Check that the frame is the same size as the base texture.\n    var isFrame = frame.width !== texture.baseTexture.width || frame.height !== texture.baseTexture.height;\n\n    var newTextureRequired = false;\n\n    if (!forcePowerOfTwo)\n    {\n        if (isFrame)\n        {\n            targetWidth = frame.width;\n            targetHeight = frame.height;\n           \n            newTextureRequired = true;\n        }\n    }\n    else\n    {\n        targetWidth = PIXI.getNextPowerOfTwo(frame.width);\n        targetHeight = PIXI.getNextPowerOfTwo(frame.height);\n\n        if (frame.width !== targetWidth || frame.height !== targetHeight) newTextureRequired = true;\n    }\n\n    if (newTextureRequired)\n    {\n        var canvasBuffer;\n\n        if (this.tilingTexture && this.tilingTexture.isTiling)\n        {\n            canvasBuffer = this.tilingTexture.canvasBuffer;\n            canvasBuffer.resize(targetWidth, targetHeight);\n            this.tilingTexture.baseTexture.width = targetWidth;\n            this.tilingTexture.baseTexture.height = targetHeight;\n            this.tilingTexture.needsUpdate = true;\n        }\n        else\n        {\n            canvasBuffer = new PIXI.CanvasBuffer(targetWidth, targetHeight);\n\n            this.tilingTexture = PIXI.Texture.fromCanvas(canvasBuffer.canvas);\n            this.tilingTexture.canvasBuffer = canvasBuffer;\n            this.tilingTexture.isTiling = true;\n        }\n\n        canvasBuffer.context.drawImage(texture.baseTexture.source,\n                               texture.crop.x,\n                               texture.crop.y,\n                               texture.crop.width,\n                               texture.crop.height,\n                               0,\n                               0,\n                               targetWidth,\n                               targetHeight);\n\n        this.tileScaleOffset.x = frame.width / targetWidth;\n        this.tileScaleOffset.y = frame.height / targetHeight;\n    }\n    else\n    {\n        //  TODO - switching?\n        if (this.tilingTexture && this.tilingTexture.isTiling)\n        {\n            // destroy the tiling texture!\n            // TODO could store this somewhere?\n            this.tilingTexture.destroy(true);\n        }\n\n        this.tileScaleOffset.x = 1;\n        this.tileScaleOffset.y = 1;\n        this.tilingTexture = texture;\n    }\n\n    this.refreshTexture = false;\n    \n    this.originalTexture = this.texture;\n    this.texture = this.tilingTexture;\n    \n    this.tilingTexture.baseTexture._powerOf2 = true;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n * based on pixi impact spine implementation made by Eemeli Kelokorpi (@ekelokorpi) https://github.com/ekelokorpi\n *\n * Awesome JS run time provided by EsotericSoftware\n * https://github.com/EsotericSoftware/spine-runtimes\n *\n */\n\n/*\n * Awesome JS run time provided by EsotericSoftware\n *\n * https://github.com/EsotericSoftware/spine-runtimes\n *\n */\n\n\n\nvar spine = {};\n\nspine.BoneData = function (name, parent) {\n    this.name = name;\n    this.parent = parent;\n};\nspine.BoneData.prototype = {\n    length: 0,\n    x: 0, y: 0,\n    rotation: 0,\n    scaleX: 1, scaleY: 1\n};\n\nspine.SlotData = function (name, boneData) {\n    this.name = name;\n    this.boneData = boneData;\n};\nspine.SlotData.prototype = {\n    r: 1, g: 1, b: 1, a: 1,\n    attachmentName: null\n};\n\nspine.Bone = function (boneData, parent) {\n    this.data = boneData;\n    this.parent = parent;\n    this.setToSetupPose();\n};\nspine.Bone.yDown = false;\nspine.Bone.prototype = {\n    x: 0, y: 0,\n    rotation: 0,\n    scaleX: 1, scaleY: 1,\n    m00: 0, m01: 0, worldX: 0, // a b x\n    m10: 0, m11: 0, worldY: 0, // c d y\n    worldRotation: 0,\n    worldScaleX: 1, worldScaleY: 1,\n    updateWorldTransform: function (flipX, flipY) {\n        var parent = this.parent;\n        if (parent != null) {\n            this.worldX = this.x * parent.m00 + this.y * parent.m01 + parent.worldX;\n            this.worldY = this.x * parent.m10 + this.y * parent.m11 + parent.worldY;\n            this.worldScaleX = parent.worldScaleX * this.scaleX;\n            this.worldScaleY = parent.worldScaleY * this.scaleY;\n            this.worldRotation = parent.worldRotation + this.rotation;\n        } else {\n            this.worldX = this.x;\n            this.worldY = this.y;\n            this.worldScaleX = this.scaleX;\n            this.worldScaleY = this.scaleY;\n            this.worldRotation = this.rotation;\n        }\n        var radians = this.worldRotation * Math.PI / 180;\n        var cos = Math.cos(radians);\n        var sin = Math.sin(radians);\n        this.m00 = cos * this.worldScaleX;\n        this.m10 = sin * this.worldScaleX;\n        this.m01 = -sin * this.worldScaleY;\n        this.m11 = cos * this.worldScaleY;\n        if (flipX) {\n            this.m00 = -this.m00;\n            this.m01 = -this.m01;\n        }\n        if (flipY) {\n            this.m10 = -this.m10;\n            this.m11 = -this.m11;\n        }\n        if (spine.Bone.yDown) {\n            this.m10 = -this.m10;\n            this.m11 = -this.m11;\n        }\n    },\n    setToSetupPose: function () {\n        var data = this.data;\n        this.x = data.x;\n        this.y = data.y;\n        this.rotation = data.rotation;\n        this.scaleX = data.scaleX;\n        this.scaleY = data.scaleY;\n    }\n};\n\nspine.Slot = function (slotData, skeleton, bone) {\n    this.data = slotData;\n    this.skeleton = skeleton;\n    this.bone = bone;\n    this.setToSetupPose();\n};\nspine.Slot.prototype = {\n    r: 1, g: 1, b: 1, a: 1,\n    _attachmentTime: 0,\n    attachment: null,\n    setAttachment: function (attachment) {\n        this.attachment = attachment;\n        this._attachmentTime = this.skeleton.time;\n    },\n    setAttachmentTime: function (time) {\n        this._attachmentTime = this.skeleton.time - time;\n    },\n    getAttachmentTime: function () {\n        return this.skeleton.time - this._attachmentTime;\n    },\n    setToSetupPose: function () {\n        var data = this.data;\n        this.r = data.r;\n        this.g = data.g;\n        this.b = data.b;\n        this.a = data.a;\n\n        var slotDatas = this.skeleton.data.slots;\n        for (var i = 0, n = slotDatas.length; i < n; i++) {\n            if (slotDatas[i] == data) {\n                this.setAttachment(!data.attachmentName ? null : this.skeleton.getAttachmentBySlotIndex(i, data.attachmentName));\n                break;\n            }\n        }\n    }\n};\n\nspine.Skin = function (name) {\n    this.name = name;\n    this.attachments = {};\n};\nspine.Skin.prototype = {\n    addAttachment: function (slotIndex, name, attachment) {\n        this.attachments[slotIndex + \":\" + name] = attachment;\n    },\n    getAttachment: function (slotIndex, name) {\n        return this.attachments[slotIndex + \":\" + name];\n    },\n    _attachAll: function (skeleton, oldSkin) {\n        for (var key in oldSkin.attachments) {\n            var colon = key.indexOf(\":\");\n            var slotIndex = parseInt(key.substring(0, colon), 10);\n            var name = key.substring(colon + 1);\n            var slot = skeleton.slots[slotIndex];\n            if (slot.attachment && slot.attachment.name == name) {\n                var attachment = this.getAttachment(slotIndex, name);\n                if (attachment) slot.setAttachment(attachment);\n            }\n        }\n    }\n};\n\nspine.Animation = function (name, timelines, duration) {\n    this.name = name;\n    this.timelines = timelines;\n    this.duration = duration;\n};\nspine.Animation.prototype = {\n    apply: function (skeleton, time, loop) {\n        if (loop && this.duration) time %= this.duration;\n        var timelines = this.timelines;\n        for (var i = 0, n = timelines.length; i < n; i++)\n            timelines[i].apply(skeleton, time, 1);\n    },\n    mix: function (skeleton, time, loop, alpha) {\n        if (loop && this.duration) time %= this.duration;\n        var timelines = this.timelines;\n        for (var i = 0, n = timelines.length; i < n; i++)\n            timelines[i].apply(skeleton, time, alpha);\n    }\n};\n\nspine.binarySearch = function (values, target, step) {\n    var low = 0;\n    var high = Math.floor(values.length / step) - 2;\n    if (!high) return step;\n    var current = high >>> 1;\n    while (true) {\n        if (values[(current + 1) * step] <= target)\n            low = current + 1;\n        else\n            high = current;\n        if (low == high) return (low + 1) * step;\n        current = (low + high) >>> 1;\n    }\n};\nspine.linearSearch = function (values, target, step) {\n    for (var i = 0, last = values.length - step; i <= last; i += step)\n        if (values[i] > target) return i;\n    return -1;\n};\n\nspine.Curves = function (frameCount) {\n    this.curves = []; // dfx, dfy, ddfx, ddfy, dddfx, dddfy, ...\n    this.curves.length = (frameCount - 1) * 6;\n};\nspine.Curves.prototype = {\n    setLinear: function (frameIndex) {\n        this.curves[frameIndex * 6] = 0/*LINEAR*/;\n    },\n    setStepped: function (frameIndex) {\n        this.curves[frameIndex * 6] = -1/*STEPPED*/;\n    },\n    /** Sets the control handle positions for an interpolation bezier curve used to transition from this keyframe to the next.\n     * cx1 and cx2 are from 0 to 1, representing the percent of time between the two keyframes. cy1 and cy2 are the percent of\n     * the difference between the keyframe's values. */\n    setCurve: function (frameIndex, cx1, cy1, cx2, cy2) {\n        var subdiv_step = 1 / 10/*BEZIER_SEGMENTS*/;\n        var subdiv_step2 = subdiv_step * subdiv_step;\n        var subdiv_step3 = subdiv_step2 * subdiv_step;\n        var pre1 = 3 * subdiv_step;\n        var pre2 = 3 * subdiv_step2;\n        var pre4 = 6 * subdiv_step2;\n        var pre5 = 6 * subdiv_step3;\n        var tmp1x = -cx1 * 2 + cx2;\n        var tmp1y = -cy1 * 2 + cy2;\n        var tmp2x = (cx1 - cx2) * 3 + 1;\n        var tmp2y = (cy1 - cy2) * 3 + 1;\n        var i = frameIndex * 6;\n        var curves = this.curves;\n        curves[i] = cx1 * pre1 + tmp1x * pre2 + tmp2x * subdiv_step3;\n        curves[i + 1] = cy1 * pre1 + tmp1y * pre2 + tmp2y * subdiv_step3;\n        curves[i + 2] = tmp1x * pre4 + tmp2x * pre5;\n        curves[i + 3] = tmp1y * pre4 + tmp2y * pre5;\n        curves[i + 4] = tmp2x * pre5;\n        curves[i + 5] = tmp2y * pre5;\n    },\n    getCurvePercent: function (frameIndex, percent) {\n        percent = percent < 0 ? 0 : (percent > 1 ? 1 : percent);\n        var curveIndex = frameIndex * 6;\n        var curves = this.curves;\n        var dfx = curves[curveIndex];\n        if (!dfx/*LINEAR*/) return percent;\n        if (dfx == -1/*STEPPED*/) return 0;\n        var dfy = curves[curveIndex + 1];\n        var ddfx = curves[curveIndex + 2];\n        var ddfy = curves[curveIndex + 3];\n        var dddfx = curves[curveIndex + 4];\n        var dddfy = curves[curveIndex + 5];\n        var x = dfx, y = dfy;\n        var i = 10/*BEZIER_SEGMENTS*/ - 2;\n        while (true) {\n            if (x >= percent) {\n                var lastX = x - dfx;\n                var lastY = y - dfy;\n                return lastY + (y - lastY) * (percent - lastX) / (x - lastX);\n            }\n            if (!i) break;\n            i--;\n            dfx += ddfx;\n            dfy += ddfy;\n            ddfx += dddfx;\n            ddfy += dddfy;\n            x += dfx;\n            y += dfy;\n        }\n        return y + (1 - y) * (percent - x) / (1 - x); // Last point is 1,1.\n    }\n};\n\nspine.RotateTimeline = function (frameCount) {\n    this.curves = new spine.Curves(frameCount);\n    this.frames = []; // time, angle, ...\n    this.frames.length = frameCount * 2;\n};\nspine.RotateTimeline.prototype = {\n    boneIndex: 0,\n    getFrameCount: function () {\n        return this.frames.length / 2;\n    },\n    setFrame: function (frameIndex, time, angle) {\n        frameIndex *= 2;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + 1] = angle;\n    },\n    apply: function (skeleton, time, alpha) {\n        var frames = this.frames,\n            amount;\n\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var bone = skeleton.bones[this.boneIndex];\n\n        if (time >= frames[frames.length - 2]) { // Time is after last frame.\n            amount = bone.data.rotation + frames[frames.length - 1] - bone.rotation;\n            while (amount > 180)\n                amount -= 360;\n            while (amount < -180)\n                amount += 360;\n            bone.rotation += amount * alpha;\n            return;\n        }\n\n        // Interpolate between the last frame and the current frame.\n        var frameIndex = spine.binarySearch(frames, time, 2);\n        var lastFrameValue = frames[frameIndex - 1];\n        var frameTime = frames[frameIndex];\n        var percent = 1 - (time - frameTime) / (frames[frameIndex - 2/*LAST_FRAME_TIME*/] - frameTime);\n        percent = this.curves.getCurvePercent(frameIndex / 2 - 1, percent);\n\n        amount = frames[frameIndex + 1/*FRAME_VALUE*/] - lastFrameValue;\n        while (amount > 180)\n            amount -= 360;\n        while (amount < -180)\n            amount += 360;\n        amount = bone.data.rotation + (lastFrameValue + amount * percent) - bone.rotation;\n        while (amount > 180)\n            amount -= 360;\n        while (amount < -180)\n            amount += 360;\n        bone.rotation += amount * alpha;\n    }\n};\n\nspine.TranslateTimeline = function (frameCount) {\n    this.curves = new spine.Curves(frameCount);\n    this.frames = []; // time, x, y, ...\n    this.frames.length = frameCount * 3;\n};\nspine.TranslateTimeline.prototype = {\n    boneIndex: 0,\n    getFrameCount: function () {\n        return this.frames.length / 3;\n    },\n    setFrame: function (frameIndex, time, x, y) {\n        frameIndex *= 3;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + 1] = x;\n        this.frames[frameIndex + 2] = y;\n    },\n    apply: function (skeleton, time, alpha) {\n        var frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var bone = skeleton.bones[this.boneIndex];\n\n        if (time >= frames[frames.length - 3]) { // Time is after last frame.\n            bone.x += (bone.data.x + frames[frames.length - 2] - bone.x) * alpha;\n            bone.y += (bone.data.y + frames[frames.length - 1] - bone.y) * alpha;\n            return;\n        }\n\n        // Interpolate between the last frame and the current frame.\n        var frameIndex = spine.binarySearch(frames, time, 3);\n        var lastFrameX = frames[frameIndex - 2];\n        var lastFrameY = frames[frameIndex - 1];\n        var frameTime = frames[frameIndex];\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*LAST_FRAME_TIME*/] - frameTime);\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\n\n        bone.x += (bone.data.x + lastFrameX + (frames[frameIndex + 1/*FRAME_X*/] - lastFrameX) * percent - bone.x) * alpha;\n        bone.y += (bone.data.y + lastFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - lastFrameY) * percent - bone.y) * alpha;\n    }\n};\n\nspine.ScaleTimeline = function (frameCount) {\n    this.curves = new spine.Curves(frameCount);\n    this.frames = []; // time, x, y, ...\n    this.frames.length = frameCount * 3;\n};\nspine.ScaleTimeline.prototype = {\n    boneIndex: 0,\n    getFrameCount: function () {\n        return this.frames.length / 3;\n    },\n    setFrame: function (frameIndex, time, x, y) {\n        frameIndex *= 3;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + 1] = x;\n        this.frames[frameIndex + 2] = y;\n    },\n    apply: function (skeleton, time, alpha) {\n        var frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var bone = skeleton.bones[this.boneIndex];\n\n        if (time >= frames[frames.length - 3]) { // Time is after last frame.\n            bone.scaleX += (bone.data.scaleX - 1 + frames[frames.length - 2] - bone.scaleX) * alpha;\n            bone.scaleY += (bone.data.scaleY - 1 + frames[frames.length - 1] - bone.scaleY) * alpha;\n            return;\n        }\n\n        // Interpolate between the last frame and the current frame.\n        var frameIndex = spine.binarySearch(frames, time, 3);\n        var lastFrameX = frames[frameIndex - 2];\n        var lastFrameY = frames[frameIndex - 1];\n        var frameTime = frames[frameIndex];\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*LAST_FRAME_TIME*/] - frameTime);\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\n\n        bone.scaleX += (bone.data.scaleX - 1 + lastFrameX + (frames[frameIndex + 1/*FRAME_X*/] - lastFrameX) * percent - bone.scaleX) * alpha;\n        bone.scaleY += (bone.data.scaleY - 1 + lastFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - lastFrameY) * percent - bone.scaleY) * alpha;\n    }\n};\n\nspine.ColorTimeline = function (frameCount) {\n    this.curves = new spine.Curves(frameCount);\n    this.frames = []; // time, r, g, b, a, ...\n    this.frames.length = frameCount * 5;\n};\nspine.ColorTimeline.prototype = {\n    slotIndex: 0,\n    getFrameCount: function () {\n        return this.frames.length / 5;\n    },\n    setFrame: function (frameIndex, time, r, g, b, a) {\n        frameIndex *= 5;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + 1] = r;\n        this.frames[frameIndex + 2] = g;\n        this.frames[frameIndex + 3] = b;\n        this.frames[frameIndex + 4] = a;\n    },\n    apply: function (skeleton, time, alpha) {\n        var frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var slot = skeleton.slots[this.slotIndex];\n\n        if (time >= frames[frames.length - 5]) { // Time is after last frame.\n            var i = frames.length - 1;\n            slot.r = frames[i - 3];\n            slot.g = frames[i - 2];\n            slot.b = frames[i - 1];\n            slot.a = frames[i];\n            return;\n        }\n\n        // Interpolate between the last frame and the current frame.\n        var frameIndex = spine.binarySearch(frames, time, 5);\n        var lastFrameR = frames[frameIndex - 4];\n        var lastFrameG = frames[frameIndex - 3];\n        var lastFrameB = frames[frameIndex - 2];\n        var lastFrameA = frames[frameIndex - 1];\n        var frameTime = frames[frameIndex];\n        var percent = 1 - (time - frameTime) / (frames[frameIndex - 5/*LAST_FRAME_TIME*/] - frameTime);\n        percent = this.curves.getCurvePercent(frameIndex / 5 - 1, percent);\n\n        var r = lastFrameR + (frames[frameIndex + 1/*FRAME_R*/] - lastFrameR) * percent;\n        var g = lastFrameG + (frames[frameIndex + 2/*FRAME_G*/] - lastFrameG) * percent;\n        var b = lastFrameB + (frames[frameIndex + 3/*FRAME_B*/] - lastFrameB) * percent;\n        var a = lastFrameA + (frames[frameIndex + 4/*FRAME_A*/] - lastFrameA) * percent;\n        if (alpha < 1) {\n            slot.r += (r - slot.r) * alpha;\n            slot.g += (g - slot.g) * alpha;\n            slot.b += (b - slot.b) * alpha;\n            slot.a += (a - slot.a) * alpha;\n        } else {\n            slot.r = r;\n            slot.g = g;\n            slot.b = b;\n            slot.a = a;\n        }\n    }\n};\n\nspine.AttachmentTimeline = function (frameCount) {\n    this.curves = new spine.Curves(frameCount);\n    this.frames = []; // time, ...\n    this.frames.length = frameCount;\n    this.attachmentNames = []; // time, ...\n    this.attachmentNames.length = frameCount;\n};\nspine.AttachmentTimeline.prototype = {\n    slotIndex: 0,\n    getFrameCount: function () {\n            return this.frames.length;\n    },\n    setFrame: function (frameIndex, time, attachmentName) {\n        this.frames[frameIndex] = time;\n        this.attachmentNames[frameIndex] = attachmentName;\n    },\n    apply: function (skeleton, time, alpha) {\n        var frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var frameIndex;\n        if (time >= frames[frames.length - 1]) // Time is after last frame.\n            frameIndex = frames.length - 1;\n        else\n            frameIndex = spine.binarySearch(frames, time, 1) - 1;\n\n        var attachmentName = this.attachmentNames[frameIndex];\n        skeleton.slots[this.slotIndex].setAttachment(!attachmentName ? null : skeleton.getAttachmentBySlotIndex(this.slotIndex, attachmentName));\n    }\n};\n\nspine.SkeletonData = function () {\n    this.bones = [];\n    this.slots = [];\n    this.skins = [];\n    this.animations = [];\n};\nspine.SkeletonData.prototype = {\n    defaultSkin: null,\n    /** @return May be null. */\n    findBone: function (boneName) {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            if (bones[i].name == boneName) return bones[i];\n        return null;\n    },\n    /** @return -1 if the bone was not found. */\n    findBoneIndex: function (boneName) {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            if (bones[i].name == boneName) return i;\n        return -1;\n    },\n    /** @return May be null. */\n    findSlot: function (slotName) {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++) {\n            if (slots[i].name == slotName) return slot[i];\n        }\n        return null;\n    },\n    /** @return -1 if the bone was not found. */\n    findSlotIndex: function (slotName) {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n            if (slots[i].name == slotName) return i;\n        return -1;\n    },\n    /** @return May be null. */\n    findSkin: function (skinName) {\n        var skins = this.skins;\n        for (var i = 0, n = skins.length; i < n; i++)\n            if (skins[i].name == skinName) return skins[i];\n        return null;\n    },\n    /** @return May be null. */\n    findAnimation: function (animationName) {\n        var animations = this.animations;\n        for (var i = 0, n = animations.length; i < n; i++)\n            if (animations[i].name == animationName) return animations[i];\n        return null;\n    }\n};\n\nspine.Skeleton = function (skeletonData) {\n    this.data = skeletonData;\n\n    this.bones = [];\n    for (var i = 0, n = skeletonData.bones.length; i < n; i++) {\n        var boneData = skeletonData.bones[i];\n        var parent = !boneData.parent ? null : this.bones[skeletonData.bones.indexOf(boneData.parent)];\n        this.bones.push(new spine.Bone(boneData, parent));\n    }\n\n    this.slots = [];\n    this.drawOrder = [];\n    for (i = 0, n = skeletonData.slots.length; i < n; i++) {\n        var slotData = skeletonData.slots[i];\n        var bone = this.bones[skeletonData.bones.indexOf(slotData.boneData)];\n        var slot = new spine.Slot(slotData, this, bone);\n        this.slots.push(slot);\n        this.drawOrder.push(slot);\n    }\n};\nspine.Skeleton.prototype = {\n    x: 0, y: 0,\n    skin: null,\n    r: 1, g: 1, b: 1, a: 1,\n    time: 0,\n    flipX: false, flipY: false,\n    /** Updates the world transform for each bone. */\n    updateWorldTransform: function () {\n        var flipX = this.flipX;\n        var flipY = this.flipY;\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            bones[i].updateWorldTransform(flipX, flipY);\n    },\n    /** Sets the bones and slots to their setup pose values. */\n    setToSetupPose: function () {\n        this.setBonesToSetupPose();\n        this.setSlotsToSetupPose();\n    },\n    setBonesToSetupPose: function () {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            bones[i].setToSetupPose();\n    },\n    setSlotsToSetupPose: function () {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n            slots[i].setToSetupPose(i);\n    },\n    /** @return May return null. */\n    getRootBone: function () {\n        return this.bones.length ? this.bones[0] : null;\n    },\n    /** @return May be null. */\n    findBone: function (boneName) {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            if (bones[i].data.name == boneName) return bones[i];\n        return null;\n    },\n    /** @return -1 if the bone was not found. */\n    findBoneIndex: function (boneName) {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            if (bones[i].data.name == boneName) return i;\n        return -1;\n    },\n    /** @return May be null. */\n    findSlot: function (slotName) {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n            if (slots[i].data.name == slotName) return slots[i];\n        return null;\n    },\n    /** @return -1 if the bone was not found. */\n    findSlotIndex: function (slotName) {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n            if (slots[i].data.name == slotName) return i;\n        return -1;\n    },\n    setSkinByName: function (skinName) {\n        var skin = this.data.findSkin(skinName);\n        if (!skin) throw \"Skin not found: \" + skinName;\n        this.setSkin(skin);\n    },\n    /** Sets the skin used to look up attachments not found in the {@link SkeletonData#getDefaultSkin() default skin}. Attachments\n     * from the new skin are attached if the corresponding attachment from the old skin was attached.\n     * @param newSkin May be null. */\n    setSkin: function (newSkin) {\n        if (this.skin && newSkin) newSkin._attachAll(this, this.skin);\n        this.skin = newSkin;\n    },\n    /** @return May be null. */\n    getAttachmentBySlotName: function (slotName, attachmentName) {\n        return this.getAttachmentBySlotIndex(this.data.findSlotIndex(slotName), attachmentName);\n    },\n    /** @return May be null. */\n    getAttachmentBySlotIndex: function (slotIndex, attachmentName) {\n        if (this.skin) {\n            var attachment = this.skin.getAttachment(slotIndex, attachmentName);\n            if (attachment) return attachment;\n        }\n        if (this.data.defaultSkin) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\n        return null;\n    },\n    /** @param attachmentName May be null. */\n    setAttachment: function (slotName, attachmentName) {\n        var slots = this.slots;\n        for (var i = 0, n = slots.size; i < n; i++) {\n            var slot = slots[i];\n            if (slot.data.name == slotName) {\n                var attachment = null;\n                if (attachmentName) {\n                    attachment = this.getAttachment(i, attachmentName);\n                    if (attachment == null) throw \"Attachment not found: \" + attachmentName + \", for slot: \" + slotName;\n                }\n                slot.setAttachment(attachment);\n                return;\n            }\n        }\n        throw \"Slot not found: \" + slotName;\n    },\n    update: function (delta) {\n        time += delta;\n    }\n};\n\nspine.AttachmentType = {\n    region: 0\n};\n\nspine.RegionAttachment = function () {\n    this.offset = [];\n    this.offset.length = 8;\n    this.uvs = [];\n    this.uvs.length = 8;\n};\nspine.RegionAttachment.prototype = {\n    x: 0, y: 0,\n    rotation: 0,\n    scaleX: 1, scaleY: 1,\n    width: 0, height: 0,\n    rendererObject: null,\n    regionOffsetX: 0, regionOffsetY: 0,\n    regionWidth: 0, regionHeight: 0,\n    regionOriginalWidth: 0, regionOriginalHeight: 0,\n    setUVs: function (u, v, u2, v2, rotate) {\n        var uvs = this.uvs;\n        if (rotate) {\n            uvs[2/*X2*/] = u;\n            uvs[3/*Y2*/] = v2;\n            uvs[4/*X3*/] = u;\n            uvs[5/*Y3*/] = v;\n            uvs[6/*X4*/] = u2;\n            uvs[7/*Y4*/] = v;\n            uvs[0/*X1*/] = u2;\n            uvs[1/*Y1*/] = v2;\n        } else {\n            uvs[0/*X1*/] = u;\n            uvs[1/*Y1*/] = v2;\n            uvs[2/*X2*/] = u;\n            uvs[3/*Y2*/] = v;\n            uvs[4/*X3*/] = u2;\n            uvs[5/*Y3*/] = v;\n            uvs[6/*X4*/] = u2;\n            uvs[7/*Y4*/] = v2;\n        }\n    },\n    updateOffset: function () {\n        var regionScaleX = this.width / this.regionOriginalWidth * this.scaleX;\n        var regionScaleY = this.height / this.regionOriginalHeight * this.scaleY;\n        var localX = -this.width / 2 * this.scaleX + this.regionOffsetX * regionScaleX;\n        var localY = -this.height / 2 * this.scaleY + this.regionOffsetY * regionScaleY;\n        var localX2 = localX + this.regionWidth * regionScaleX;\n        var localY2 = localY + this.regionHeight * regionScaleY;\n        var radians = this.rotation * Math.PI / 180;\n        var cos = Math.cos(radians);\n        var sin = Math.sin(radians);\n        var localXCos = localX * cos + this.x;\n        var localXSin = localX * sin;\n        var localYCos = localY * cos + this.y;\n        var localYSin = localY * sin;\n        var localX2Cos = localX2 * cos + this.x;\n        var localX2Sin = localX2 * sin;\n        var localY2Cos = localY2 * cos + this.y;\n        var localY2Sin = localY2 * sin;\n        var offset = this.offset;\n        offset[0/*X1*/] = localXCos - localYSin;\n        offset[1/*Y1*/] = localYCos + localXSin;\n        offset[2/*X2*/] = localXCos - localY2Sin;\n        offset[3/*Y2*/] = localY2Cos + localXSin;\n        offset[4/*X3*/] = localX2Cos - localY2Sin;\n        offset[5/*Y3*/] = localY2Cos + localX2Sin;\n        offset[6/*X4*/] = localX2Cos - localYSin;\n        offset[7/*Y4*/] = localYCos + localX2Sin;\n    },\n    computeVertices: function (x, y, bone, vertices) {\n        x += bone.worldX;\n        y += bone.worldY;\n        var m00 = bone.m00;\n        var m01 = bone.m01;\n        var m10 = bone.m10;\n        var m11 = bone.m11;\n        var offset = this.offset;\n        vertices[0/*X1*/] = offset[0/*X1*/] * m00 + offset[1/*Y1*/] * m01 + x;\n        vertices[1/*Y1*/] = offset[0/*X1*/] * m10 + offset[1/*Y1*/] * m11 + y;\n        vertices[2/*X2*/] = offset[2/*X2*/] * m00 + offset[3/*Y2*/] * m01 + x;\n        vertices[3/*Y2*/] = offset[2/*X2*/] * m10 + offset[3/*Y2*/] * m11 + y;\n        vertices[4/*X3*/] = offset[4/*X3*/] * m00 + offset[5/*X3*/] * m01 + x;\n        vertices[5/*X3*/] = offset[4/*X3*/] * m10 + offset[5/*X3*/] * m11 + y;\n        vertices[6/*X4*/] = offset[6/*X4*/] * m00 + offset[7/*Y4*/] * m01 + x;\n        vertices[7/*Y4*/] = offset[6/*X4*/] * m10 + offset[7/*Y4*/] * m11 + y;\n    }\n}\n\nspine.AnimationStateData = function (skeletonData) {\n    this.skeletonData = skeletonData;\n    this.animationToMixTime = {};\n};\nspine.AnimationStateData.prototype = {\n        defaultMix: 0,\n    setMixByName: function (fromName, toName, duration) {\n        var from = this.skeletonData.findAnimation(fromName);\n        if (!from) throw \"Animation not found: \" + fromName;\n        var to = this.skeletonData.findAnimation(toName);\n        if (!to) throw \"Animation not found: \" + toName;\n        this.setMix(from, to, duration);\n    },\n    setMix: function (from, to, duration) {\n        this.animationToMixTime[from.name + \":\" + to.name] = duration;\n    },\n    getMix: function (from, to) {\n        var time = this.animationToMixTime[from.name + \":\" + to.name];\n            return time ? time : this.defaultMix;\n    }\n};\n\nspine.AnimationState = function (stateData) {\n    this.data = stateData;\n    this.queue = [];\n};\nspine.AnimationState.prototype = {\n    animationSpeed: 1,\n    current: null,\n    previous: null,\n    currentTime: 0,\n    previousTime: 0,\n    currentLoop: false,\n    previousLoop: false,\n    mixTime: 0,\n    mixDuration: 0,\n    update: function (delta) {\n        this.currentTime += (delta * this.animationSpeed); //timeScale: Multiply delta by the speed of animation required.\n        this.previousTime += delta;\n        this.mixTime += delta;\n\n        if (this.queue.length > 0) {\n            var entry = this.queue[0];\n            if (this.currentTime >= entry.delay) {\n                this._setAnimation(entry.animation, entry.loop);\n                this.queue.shift();\n            }\n        }\n    },\n    apply: function (skeleton) {\n        if (!this.current) return;\n        if (this.previous) {\n            this.previous.apply(skeleton, this.previousTime, this.previousLoop);\n            var alpha = this.mixTime / this.mixDuration;\n            if (alpha >= 1) {\n                alpha = 1;\n                this.previous = null;\n            }\n            this.current.mix(skeleton, this.currentTime, this.currentLoop, alpha);\n        } else\n            this.current.apply(skeleton, this.currentTime, this.currentLoop);\n    },\n    clearAnimation: function () {\n        this.previous = null;\n        this.current = null;\n        this.queue.length = 0;\n    },\n    _setAnimation: function (animation, loop) {\n        this.previous = null;\n        if (animation && this.current) {\n            this.mixDuration = this.data.getMix(this.current, animation);\n            if (this.mixDuration > 0) {\n                this.mixTime = 0;\n                this.previous = this.current;\n                this.previousTime = this.currentTime;\n                this.previousLoop = this.currentLoop;\n            }\n        }\n        this.current = animation;\n        this.currentLoop = loop;\n        this.currentTime = 0;\n    },\n    /** @see #setAnimation(Animation, Boolean) */\n    setAnimationByName: function (animationName, loop) {\n        var animation = this.data.skeletonData.findAnimation(animationName);\n        if (!animation) throw \"Animation not found: \" + animationName;\n        this.setAnimation(animation, loop);\n    },\n    /** Set the current animation. Any queued animations are cleared and the current animation time is set to 0.\n     * @param animation May be null. */\n    setAnimation: function (animation, loop) {\n        this.queue.length = 0;\n        this._setAnimation(animation, loop);\n    },\n    /** @see #addAnimation(Animation, Boolean, Number) */\n    addAnimationByName: function (animationName, loop, delay) {\n        var animation = this.data.skeletonData.findAnimation(animationName);\n        if (!animation) throw \"Animation not found: \" + animationName;\n        this.addAnimation(animation, loop, delay);\n    },\n    /** Adds an animation to be played delay seconds after the current or last queued animation.\n     * @param delay May be <= 0 to use duration of previous animation minus any mix duration plus the negative delay. */\n    addAnimation: function (animation, loop, delay) {\n        var entry = {};\n        entry.animation = animation;\n        entry.loop = loop;\n\n        if (!delay || delay <= 0) {\n            var previousAnimation = this.queue.length ? this.queue[this.queue.length - 1].animation : this.current;\n            if (previousAnimation != null)\n                delay = previousAnimation.duration - this.data.getMix(previousAnimation, animation) + (delay || 0);\n            else\n                delay = 0;\n        }\n        entry.delay = delay;\n\n        this.queue.push(entry);\n    },\n    /** Returns true if no animation is set or if the current time is greater than the animation duration, regardless of looping. */\n    isComplete: function () {\n        return !this.current || this.currentTime >= this.current.duration;\n    }\n};\n\nspine.SkeletonJson = function (attachmentLoader) {\n    this.attachmentLoader = attachmentLoader;\n};\nspine.SkeletonJson.prototype = {\n    scale: 1,\n    readSkeletonData: function (root) {\n        /*jshint -W069*/\n        var skeletonData = new spine.SkeletonData(),\n            boneData;\n\n        // Bones.\n        var bones = root[\"bones\"];\n        for (var i = 0, n = bones.length; i < n; i++) {\n            var boneMap = bones[i];\n            var parent = null;\n            if (boneMap[\"parent\"]) {\n                parent = skeletonData.findBone(boneMap[\"parent\"]);\n                if (!parent) throw \"Parent bone not found: \" + boneMap[\"parent\"];\n            }\n            boneData = new spine.BoneData(boneMap[\"name\"], parent);\n            boneData.length = (boneMap[\"length\"] || 0) * this.scale;\n            boneData.x = (boneMap[\"x\"] || 0) * this.scale;\n            boneData.y = (boneMap[\"y\"] || 0) * this.scale;\n            boneData.rotation = (boneMap[\"rotation\"] || 0);\n            boneData.scaleX = boneMap[\"scaleX\"] || 1;\n            boneData.scaleY = boneMap[\"scaleY\"] || 1;\n            skeletonData.bones.push(boneData);\n        }\n\n        // Slots.\n        var slots = root[\"slots\"];\n        for (i = 0, n = slots.length; i < n; i++) {\n            var slotMap = slots[i];\n            boneData = skeletonData.findBone(slotMap[\"bone\"]);\n            if (!boneData) throw \"Slot bone not found: \" + slotMap[\"bone\"];\n            var slotData = new spine.SlotData(slotMap[\"name\"], boneData);\n\n            var color = slotMap[\"color\"];\n            if (color) {\n                slotData.r = spine.SkeletonJson.toColor(color, 0);\n                slotData.g = spine.SkeletonJson.toColor(color, 1);\n                slotData.b = spine.SkeletonJson.toColor(color, 2);\n                slotData.a = spine.SkeletonJson.toColor(color, 3);\n            }\n\n            slotData.attachmentName = slotMap[\"attachment\"];\n\n            skeletonData.slots.push(slotData);\n        }\n\n        // Skins.\n        var skins = root[\"skins\"];\n        for (var skinName in skins) {\n            if (!skins.hasOwnProperty(skinName)) continue;\n            var skinMap = skins[skinName];\n            var skin = new spine.Skin(skinName);\n            for (var slotName in skinMap) {\n                if (!skinMap.hasOwnProperty(slotName)) continue;\n                var slotIndex = skeletonData.findSlotIndex(slotName);\n                var slotEntry = skinMap[slotName];\n                for (var attachmentName in slotEntry) {\n                    if (!slotEntry.hasOwnProperty(attachmentName)) continue;\n                    var attachment = this.readAttachment(skin, attachmentName, slotEntry[attachmentName]);\n                    if (attachment != null) skin.addAttachment(slotIndex, attachmentName, attachment);\n                }\n            }\n            skeletonData.skins.push(skin);\n            if (skin.name == \"default\") skeletonData.defaultSkin = skin;\n        }\n\n        // Animations.\n        var animations = root[\"animations\"];\n        for (var animationName in animations) {\n            if (!animations.hasOwnProperty(animationName)) continue;\n            this.readAnimation(animationName, animations[animationName], skeletonData);\n        }\n\n        return skeletonData;\n    },\n    readAttachment: function (skin, name, map) {\n        /*jshint -W069*/\n        name = map[\"name\"] || name;\n\n        var type = spine.AttachmentType[map[\"type\"] || \"region\"];\n\n        if (type == spine.AttachmentType.region) {\n            var attachment = new spine.RegionAttachment();\n            attachment.x = (map[\"x\"] || 0) * this.scale;\n            attachment.y = (map[\"y\"] || 0) * this.scale;\n            attachment.scaleX = map[\"scaleX\"] || 1;\n            attachment.scaleY = map[\"scaleY\"] || 1;\n            attachment.rotation = map[\"rotation\"] || 0;\n            attachment.width = (map[\"width\"] || 32) * this.scale;\n            attachment.height = (map[\"height\"] || 32) * this.scale;\n            attachment.updateOffset();\n\n            attachment.rendererObject = {};\n            attachment.rendererObject.name = name;\n            attachment.rendererObject.scale = {};\n            attachment.rendererObject.scale.x = attachment.scaleX;\n            attachment.rendererObject.scale.y = attachment.scaleY;\n            attachment.rendererObject.rotation = -attachment.rotation * Math.PI / 180;\n            return attachment;\n        }\n\n            throw \"Unknown attachment type: \" + type;\n    },\n\n    readAnimation: function (name, map, skeletonData) {\n        /*jshint -W069*/\n        var timelines = [];\n        var duration = 0;\n        var frameIndex, timeline, timelineName, valueMap, values,\n            i, n;\n\n        var bones = map[\"bones\"];\n        for (var boneName in bones) {\n            if (!bones.hasOwnProperty(boneName)) continue;\n            var boneIndex = skeletonData.findBoneIndex(boneName);\n            if (boneIndex == -1) throw \"Bone not found: \" + boneName;\n            var boneMap = bones[boneName];\n\n            for (timelineName in boneMap) {\n                if (!boneMap.hasOwnProperty(timelineName)) continue;\n                values = boneMap[timelineName];\n                if (timelineName == \"rotate\") {\n                    timeline = new spine.RotateTimeline(values.length);\n                    timeline.boneIndex = boneIndex;\n\n                    frameIndex = 0;\n                    for (i = 0, n = values.length; i < n; i++) {\n                        valueMap = values[i];\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], valueMap[\"angle\"]);\n                        spine.SkeletonJson.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 2 - 2]);\n\n                } else if (timelineName == \"translate\" || timelineName == \"scale\") {\n                    var timelineScale = 1;\n                    if (timelineName == \"scale\")\n                        timeline = new spine.ScaleTimeline(values.length);\n                    else {\n                        timeline = new spine.TranslateTimeline(values.length);\n                        timelineScale = this.scale;\n                    }\n                    timeline.boneIndex = boneIndex;\n\n                    frameIndex = 0;\n                    for (i = 0, n = values.length; i < n; i++) {\n                        valueMap = values[i];\n                        var x = (valueMap[\"x\"] || 0) * timelineScale;\n                        var y = (valueMap[\"y\"] || 0) * timelineScale;\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], x, y);\n                        spine.SkeletonJson.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 3 - 3]);\n\n                } else\n                    throw \"Invalid timeline type for a bone: \" + timelineName + \" (\" + boneName + \")\";\n            }\n        }\n        var slots = map[\"slots\"];\n        for (var slotName in slots) {\n            if (!slots.hasOwnProperty(slotName)) continue;\n            var slotMap = slots[slotName];\n            var slotIndex = skeletonData.findSlotIndex(slotName);\n\n            for (timelineName in slotMap) {\n                if (!slotMap.hasOwnProperty(timelineName)) continue;\n                values = slotMap[timelineName];\n                if (timelineName == \"color\") {\n                    timeline = new spine.ColorTimeline(values.length);\n                    timeline.slotIndex = slotIndex;\n\n                    frameIndex = 0;\n                    for (i = 0, n = values.length; i < n; i++) {\n                        valueMap = values[i];\n                        var color = valueMap[\"color\"];\n                        var r = spine.SkeletonJson.toColor(color, 0);\n                        var g = spine.SkeletonJson.toColor(color, 1);\n                        var b = spine.SkeletonJson.toColor(color, 2);\n                        var a = spine.SkeletonJson.toColor(color, 3);\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], r, g, b, a);\n                        spine.SkeletonJson.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 5 - 5]);\n\n                } else if (timelineName == \"attachment\") {\n                    timeline = new spine.AttachmentTimeline(values.length);\n                    timeline.slotIndex = slotIndex;\n\n                    frameIndex = 0;\n                    for (i = 0, n = values.length; i < n; i++) {\n                        valueMap = values[i];\n                        timeline.setFrame(frameIndex++, valueMap[\"time\"], valueMap[\"name\"]);\n                    }\n                    timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n\n                } else\n                    throw \"Invalid timeline type for a slot: \" + timelineName + \" (\" + slotName + \")\";\n            }\n        }\n        skeletonData.animations.push(new spine.Animation(name, timelines, duration));\n    }\n};\nspine.SkeletonJson.readCurve = function (timeline, frameIndex, valueMap) {\n    /*jshint -W069*/\n    var curve = valueMap[\"curve\"];\n    if (!curve) return;\n    if (curve == \"stepped\")\n        timeline.curves.setStepped(frameIndex);\n    else if (curve instanceof Array)\n        timeline.curves.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);\n};\nspine.SkeletonJson.toColor = function (hexString, colorIndex) {\n    if (hexString.length != 8) throw \"Color hexidecimal length must be 8, recieved: \" + hexString;\n    return parseInt(hexString.substr(colorIndex * 2, 2), 16) / 255;\n};\n\nspine.Atlas = function (atlasText, textureLoader) {\n    this.textureLoader = textureLoader;\n    this.pages = [];\n    this.regions = [];\n\n    var reader = new spine.AtlasReader(atlasText);\n    var tuple = [];\n    tuple.length = 4;\n    var page = null;\n    while (true) {\n        var line = reader.readLine();\n        if (line == null) break;\n        line = reader.trim(line);\n        if (!line.length)\n            page = null;\n        else if (!page) {\n            page = new spine.AtlasPage();\n            page.name = line;\n\n            page.format = spine.Atlas.Format[reader.readValue()];\n\n            reader.readTuple(tuple);\n            page.minFilter = spine.Atlas.TextureFilter[tuple[0]];\n            page.magFilter = spine.Atlas.TextureFilter[tuple[1]];\n\n            var direction = reader.readValue();\n            page.uWrap = spine.Atlas.TextureWrap.clampToEdge;\n            page.vWrap = spine.Atlas.TextureWrap.clampToEdge;\n            if (direction == \"x\")\n                page.uWrap = spine.Atlas.TextureWrap.repeat;\n            else if (direction == \"y\")\n                page.vWrap = spine.Atlas.TextureWrap.repeat;\n            else if (direction == \"xy\")\n                page.uWrap = page.vWrap = spine.Atlas.TextureWrap.repeat;\n\n            textureLoader.load(page, line);\n\n            this.pages.push(page);\n\n        } else {\n            var region = new spine.AtlasRegion();\n            region.name = line;\n            region.page = page;\n\n            region.rotate = reader.readValue() == \"true\";\n\n            reader.readTuple(tuple);\n            var x = parseInt(tuple[0], 10);\n            var y = parseInt(tuple[1], 10);\n\n            reader.readTuple(tuple);\n            var width = parseInt(tuple[0], 10);\n            var height = parseInt(tuple[1], 10);\n\n            region.u = x / page.width;\n            region.v = y / page.height;\n            if (region.rotate) {\n                region.u2 = (x + height) / page.width;\n                region.v2 = (y + width) / page.height;\n            } else {\n                region.u2 = (x + width) / page.width;\n                region.v2 = (y + height) / page.height;\n            }\n            region.x = x;\n            region.y = y;\n            region.width = Math.abs(width);\n            region.height = Math.abs(height);\n\n            if (reader.readTuple(tuple) == 4) { // split is optional\n                region.splits = [parseInt(tuple[0], 10), parseInt(tuple[1], 10), parseInt(tuple[2], 10), parseInt(tuple[3], 10)];\n\n                if (reader.readTuple(tuple) == 4) { // pad is optional, but only present with splits\n                    region.pads = [parseInt(tuple[0], 10), parseInt(tuple[1], 10), parseInt(tuple[2], 10), parseInt(tuple[3], 10)];\n\n                    reader.readTuple(tuple);\n                }\n            }\n\n            region.originalWidth = parseInt(tuple[0], 10);\n            region.originalHeight = parseInt(tuple[1], 10);\n\n            reader.readTuple(tuple);\n            region.offsetX = parseInt(tuple[0], 10);\n            region.offsetY = parseInt(tuple[1], 10);\n\n            region.index = parseInt(reader.readValue(), 10);\n\n            this.regions.push(region);\n        }\n    }\n};\nspine.Atlas.prototype = {\n    findRegion: function (name) {\n        var regions = this.regions;\n        for (var i = 0, n = regions.length; i < n; i++)\n            if (regions[i].name == name) return regions[i];\n        return null;\n    },\n    dispose: function () {\n        var pages = this.pages;\n        for (var i = 0, n = pages.length; i < n; i++)\n            this.textureLoader.unload(pages[i].rendererObject);\n    },\n    updateUVs: function (page) {\n        var regions = this.regions;\n        for (var i = 0, n = regions.length; i < n; i++) {\n            var region = regions[i];\n            if (region.page != page) continue;\n            region.u = region.x / page.width;\n            region.v = region.y / page.height;\n            if (region.rotate) {\n                region.u2 = (region.x + region.height) / page.width;\n                region.v2 = (region.y + region.width) / page.height;\n            } else {\n                region.u2 = (region.x + region.width) / page.width;\n                region.v2 = (region.y + region.height) / page.height;\n            }\n        }\n    }\n};\n\nspine.Atlas.Format = {\n    alpha: 0,\n    intensity: 1,\n    luminanceAlpha: 2,\n    rgb565: 3,\n    rgba4444: 4,\n    rgb888: 5,\n    rgba8888: 6\n};\n\nspine.Atlas.TextureFilter = {\n    nearest: 0,\n    linear: 1,\n    mipMap: 2,\n    mipMapNearestNearest: 3,\n    mipMapLinearNearest: 4,\n    mipMapNearestLinear: 5,\n    mipMapLinearLinear: 6\n};\n\nspine.Atlas.TextureWrap = {\n    mirroredRepeat: 0,\n    clampToEdge: 1,\n    repeat: 2\n};\n\nspine.AtlasPage = function () {};\nspine.AtlasPage.prototype = {\n    name: null,\n    format: null,\n    minFilter: null,\n    magFilter: null,\n    uWrap: null,\n    vWrap: null,\n    rendererObject: null,\n    width: 0,\n    height: 0\n};\n\nspine.AtlasRegion = function () {};\nspine.AtlasRegion.prototype = {\n    page: null,\n    name: null,\n    x: 0, y: 0,\n    width: 0, height: 0,\n    u: 0, v: 0, u2: 0, v2: 0,\n    offsetX: 0, offsetY: 0,\n    originalWidth: 0, originalHeight: 0,\n    index: 0,\n    rotate: false,\n    splits: null,\n    pads: null\n};\n\nspine.AtlasReader = function (text) {\n    this.lines = text.split(/\\r\\n|\\r|\\n/);\n};\nspine.AtlasReader.prototype = {\n    index: 0,\n    trim: function (value) {\n        return value.replace(/^\\s+|\\s+$/g, \"\");\n    },\n    readLine: function () {\n        if (this.index >= this.lines.length) return null;\n        return this.lines[this.index++];\n    },\n    readValue: function () {\n        var line = this.readLine();\n        var colon = line.indexOf(\":\");\n        if (colon == -1) throw \"Invalid line: \" + line;\n        return this.trim(line.substring(colon + 1));\n    },\n    /** Returns the number of tuple values read (2 or 4). */\n    readTuple: function (tuple) {\n        var line = this.readLine();\n        var colon = line.indexOf(\":\");\n        if (colon == -1) throw \"Invalid line: \" + line;\n        var i = 0, lastMatch= colon + 1;\n        for (; i < 3; i++) {\n            var comma = line.indexOf(\",\", lastMatch);\n            if (comma == -1) {\n                if (!i) throw \"Invalid line: \" + line;\n                break;\n            }\n            tuple[i] = this.trim(line.substr(lastMatch, comma - lastMatch));\n            lastMatch = comma + 1;\n        }\n        tuple[i] = this.trim(line.substring(lastMatch));\n        return i + 1;\n    }\n}\n\nspine.AtlasAttachmentLoader = function (atlas) {\n    this.atlas = atlas;\n}\nspine.AtlasAttachmentLoader.prototype = {\n    newAttachment: function (skin, type, name) {\n        switch (type) {\n        case spine.AttachmentType.region:\n            var region = this.atlas.findRegion(name);\n            if (!region) throw \"Region not found in atlas: \" + name + \" (\" + type + \")\";\n            var attachment = new spine.RegionAttachment(name);\n            attachment.rendererObject = region;\n            attachment.setUVs(region.u, region.v, region.u2, region.v2, region.rotate);\n            attachment.regionOffsetX = region.offsetX;\n            attachment.regionOffsetY = region.offsetY;\n            attachment.regionWidth = region.width;\n            attachment.regionHeight = region.height;\n            attachment.regionOriginalWidth = region.originalWidth;\n            attachment.regionOriginalHeight = region.originalHeight;\n            return attachment;\n        }\n        throw \"Unknown attachment type: \" + type;\n    }\n}\n\nspine.Bone.yDown = true;\nPIXI.AnimCache = {};\n\n/**\n * A class that enables the you to import and run your spine animations in pixi.\n * Spine animation data needs to be loaded using the PIXI.AssetLoader or PIXI.SpineLoader before it can be used by this class\n * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source\n *\n * @class Spine\n * @extends DisplayObjectContainer\n * @constructor\n * @param url {String} The url of the spine anim file to be used\n */\nPIXI.Spine = function (url) {\n    PIXI.DisplayObjectContainer.call(this);\n\n    this.spineData = PIXI.AnimCache[url];\n\n    if (!this.spineData) {\n        throw new Error(\"Spine data must be preloaded using PIXI.SpineLoader or PIXI.AssetLoader: \" + url);\n    }\n\n    this.skeleton = new spine.Skeleton(this.spineData);\n    this.skeleton.updateWorldTransform();\n\n    this.stateData = new spine.AnimationStateData(this.spineData);\n    this.state = new spine.AnimationState(this.stateData);\n\n    this.slotContainers = [];\n\n    for (var i = 0, n = this.skeleton.drawOrder.length; i < n; i++) {\n        var slot = this.skeleton.drawOrder[i];\n        var attachment = slot.attachment;\n        var slotContainer = new PIXI.DisplayObjectContainer();\n        this.slotContainers.push(slotContainer);\n        this.addChild(slotContainer);\n        if (!(attachment instanceof spine.RegionAttachment)) {\n            continue;\n        }\n        var spriteName = attachment.rendererObject.name;\n        var sprite = this.createSprite(slot, attachment.rendererObject);\n        slot.currentSprite = sprite;\n        slot.currentSpriteName = spriteName;\n        slotContainer.addChild(sprite);\n    }\n};\n\nPIXI.Spine.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);\nPIXI.Spine.prototype.constructor = PIXI.Spine;\n\n/*\n * Updates the object transform for rendering\n *\n * @method updateTransform\n * @private\n */\nPIXI.Spine.prototype.updateTransform = function () {\n    this.lastTime = this.lastTime || Date.now();\n    var timeDelta = (Date.now() - this.lastTime) * 0.001;\n    this.lastTime = Date.now();\n    this.state.update(timeDelta);\n    this.state.apply(this.skeleton);\n    this.skeleton.updateWorldTransform();\n\n    var drawOrder = this.skeleton.drawOrder;\n    for (var i = 0, n = drawOrder.length; i < n; i++) {\n        var slot = drawOrder[i];\n        var attachment = slot.attachment;\n        var slotContainer = this.slotContainers[i];\n        if (!(attachment instanceof spine.RegionAttachment)) {\n            slotContainer.visible = false;\n            continue;\n        }\n\n        if (attachment.rendererObject) {\n            if (!slot.currentSpriteName || slot.currentSpriteName != attachment.name) {\n                var spriteName = attachment.rendererObject.name;\n                if (slot.currentSprite !== undefined) {\n                    slot.currentSprite.visible = false;\n                }\n                slot.sprites = slot.sprites || {};\n                if (slot.sprites[spriteName] !== undefined) {\n                    slot.sprites[spriteName].visible = true;\n                } else {\n                    var sprite = this.createSprite(slot, attachment.rendererObject);\n                    slotContainer.addChild(sprite);\n                }\n                slot.currentSprite = slot.sprites[spriteName];\n                slot.currentSpriteName = spriteName;\n            }\n        }\n        slotContainer.visible = true;\n\n        var bone = slot.bone;\n\n        slotContainer.position.x = bone.worldX + attachment.x * bone.m00 + attachment.y * bone.m01;\n        slotContainer.position.y = bone.worldY + attachment.x * bone.m10 + attachment.y * bone.m11;\n        slotContainer.scale.x = bone.worldScaleX;\n        slotContainer.scale.y = bone.worldScaleY;\n\n        slotContainer.rotation = -(slot.bone.worldRotation * Math.PI / 180);\n\n        slotContainer.alpha = slot.a;\n        slot.currentSprite.tint = PIXI.rgb2hex([slot.r,slot.g,slot.b]);\n    }\n\n    PIXI.DisplayObjectContainer.prototype.updateTransform.call(this);\n};\n\n\nPIXI.Spine.prototype.createSprite = function (slot, descriptor) {\n    var name = PIXI.TextureCache[descriptor.name] ? descriptor.name : descriptor.name + \".png\";\n    var sprite = new PIXI.Sprite(PIXI.Texture.fromFrame(name));\n    sprite.scale = descriptor.scale;\n    sprite.rotation = descriptor.rotation;\n    sprite.anchor.x = sprite.anchor.y = 0.5;\n\n    slot.sprites = slot.sprites || {};\n    slot.sprites[descriptor.name] = sprite;\n    return sprite;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\nPIXI.BaseTextureCache = {};\n\nPIXI.BaseTextureCacheIdGenerator = 0;\n\n/**\n * A texture stores the information that represents an image. All textures have a base texture.\n *\n * @class BaseTexture\n * @uses EventTarget\n * @constructor\n * @param source {String} the source object (image or canvas)\n * @param scaleMode {Number} Should be one of the PIXI.scaleMode consts\n */\nPIXI.BaseTexture = function(source, scaleMode)\n{\n    /**\n     * The Resolution of the texture. \n     *\n     * @property resolution\n     * @type Number\n     */\n    this.resolution = 1;\n    \n    /**\n     * [read-only] The width of the base texture set when the image has loaded\n     *\n     * @property width\n     * @type Number\n     * @readOnly\n     */\n    this.width = 100;\n\n    /**\n     * [read-only] The height of the base texture set when the image has loaded\n     *\n     * @property height\n     * @type Number\n     * @readOnly\n     */\n    this.height = 100;\n\n    /**\n     * The scale mode to apply when scaling this texture\n     * \n     * @property scaleMode\n     * @type PIXI.scaleModes\n     * @default PIXI.scaleModes.LINEAR\n     */\n    this.scaleMode = scaleMode || PIXI.scaleModes.DEFAULT;\n\n    /**\n     * [read-only] Set to true once the base texture has loaded\n     *\n     * @property hasLoaded\n     * @type Boolean\n     * @readOnly\n     */\n    this.hasLoaded = false;\n\n    /**\n     * The image source that is used to create the texture.\n     *\n     * @property source\n     * @type Image\n     */\n    this.source = source;\n\n    this._UID = PIXI._UID++;\n\n    /**\n     * Controls if RGB channels should be pre-multiplied by Alpha  (WebGL only)\n     *\n     * @property premultipliedAlpha\n     * @type Boolean\n     * @default true\n     */\n    this.premultipliedAlpha = true;\n\n    // used for webGL\n\n    /**\n     * @property _glTextures\n     * @type Array\n     * @private\n     */\n    this._glTextures = [];\n\n    // used for webGL texture updating...\n    // TODO - this needs to be addressed\n\n    /**\n     * @property _dirty\n     * @type Array\n     * @private\n     */\n    this._dirty = [true, true, true, true];\n\n    if(!source)return;\n\n    if((this.source.complete || this.source.getContext) && this.source.width && this.source.height)\n    {\n        this.hasLoaded = true;\n        this.width = this.source.naturalWidth || this.source.width;\n        this.height = this.source.naturalHeight || this.source.height;\n        this.dirty();\n    }\n    else\n    {\n        var scope = this;\n\n        this.source.onload = function() {\n\n            scope.hasLoaded = true;\n            scope.width = scope.source.naturalWidth || scope.source.width;\n            scope.height = scope.source.naturalHeight || scope.source.height;\n\n            scope.dirty();\n\n            // add it to somewhere...\n            scope.dispatchEvent( { type: 'loaded', content: scope } );\n        };\n\n        this.source.onerror = function() {\n            scope.dispatchEvent( { type: 'error', content: scope } );\n        };\n    }\n\n    /**\n     * @property imageUrl\n     * @type String\n     */\n    this.imageUrl = null;\n\n    /**\n     * @property _powerOf2\n     * @type Boolean\n     * @private\n     */\n    this._powerOf2 = false;\n\n};\n\nPIXI.BaseTexture.prototype.constructor = PIXI.BaseTexture;\n\nPIXI.EventTarget.mixin(PIXI.BaseTexture.prototype);\n\n/**\n * Destroys this base texture\n *\n * @method destroy\n */\nPIXI.BaseTexture.prototype.destroy = function()\n{\n    if(this.imageUrl)\n    {\n        delete PIXI.BaseTextureCache[this.imageUrl];\n        delete PIXI.TextureCache[this.imageUrl];\n        this.imageUrl = null;\n        if (!navigator.isCocoonJS) this.source.src = '';\n    }\n    else if (this.source && this.source._pixiId)\n    {\n        delete PIXI.BaseTextureCache[this.source._pixiId];\n    }\n    this.source = null;\n\n    this.unloadFromGPU();\n};\n\n/**\n * Changes the source image of the texture\n *\n * @method updateSourceImage\n * @param newSrc {String} the path of the image\n */\nPIXI.BaseTexture.prototype.updateSourceImage = function(newSrc)\n{\n    this.hasLoaded = false;\n    this.source.src = null;\n    this.source.src = newSrc;\n};\n\n/**\n * Sets all glTextures to be dirty.\n *\n * @method dirty\n */\nPIXI.BaseTexture.prototype.dirty = function()\n{\n    for (var i = 0; i < this._glTextures.length; i++)\n    {\n        this._dirty[i] = true;\n    }\n};\n\n/**\n * Removes the base texture from the GPU, useful for managing resources on the GPU.\n * Atexture is still 100% usable and will simply be reuploaded if there is a sprite on screen that is using it.\n *\n * @method unloadFromGPU\n */\nPIXI.BaseTexture.prototype.unloadFromGPU = function()\n{\n    this.dirty();\n\n    // delete the webGL textures if any.\n    for (var i = this._glTextures.length - 1; i >= 0; i--)\n    {\n        var glTexture = this._glTextures[i];\n        var gl = PIXI.glContexts[i];\n\n        if(gl && glTexture)\n        {\n            gl.deleteTexture(glTexture);\n        }\n        \n    }\n\n    this._glTextures.length = 0;\n\n    this.dirty();\n};\n\n/**\n * Helper function that creates a base texture from the given image url.\n * If the image is not in the base texture cache it will be created and loaded.\n *\n * @static\n * @method fromImage\n * @param imageUrl {String} The image url of the texture\n * @param crossorigin {Boolean}\n * @param scaleMode {Number} Should be one of the PIXI.scaleMode consts\n * @return BaseTexture\n */\nPIXI.BaseTexture.fromImage = function(imageUrl, crossorigin, scaleMode)\n{\n    var baseTexture = PIXI.BaseTextureCache[imageUrl];\n\n    if(crossorigin === undefined && imageUrl.indexOf('data:') === -1) crossorigin = true;\n\n    if(!baseTexture)\n    {\n        // new Image() breaks tex loading in some versions of Chrome.\n        // See https://code.google.com/p/chromium/issues/detail?id=238071\n        var image = new Image();//document.createElement('img');\n        if (crossorigin)\n        {\n            image.crossOrigin = '';\n        }\n\n        image.src = imageUrl;\n        baseTexture = new PIXI.BaseTexture(image, scaleMode);\n        baseTexture.imageUrl = imageUrl;\n        PIXI.BaseTextureCache[imageUrl] = baseTexture;\n\n        // if there is an @2x at the end of the url we are going to assume its a highres image\n        if( imageUrl.indexOf(PIXI.RETINA_PREFIX + '.') !== -1)\n        {\n            baseTexture.resolution = 2;\n        }\n    }\n\n    return baseTexture;\n};\n\n/**\n * Helper function that creates a base texture from the given canvas element.\n *\n * @static\n * @method fromCanvas\n * @param canvas {Canvas} The canvas element source of the texture\n * @param scaleMode {Number} Should be one of the PIXI.scaleMode consts\n * @return BaseTexture\n */\nPIXI.BaseTexture.fromCanvas = function(canvas, scaleMode)\n{\n    if(!canvas._pixiId)\n    {\n        canvas._pixiId = 'canvas_' + PIXI.TextureCacheIdGenerator++;\n    }\n\n    var baseTexture = PIXI.BaseTextureCache[canvas._pixiId];\n\n    if(!baseTexture)\n    {\n        baseTexture = new PIXI.BaseTexture(canvas, scaleMode);\n        PIXI.BaseTextureCache[canvas._pixiId] = baseTexture;\n    }\n\n    return baseTexture;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\nPIXI.TextureCache = {};\nPIXI.FrameCache = {};\n\nPIXI.TextureCacheIdGenerator = 0;\n\n/**\n * A texture stores the information that represents an image or part of an image. It cannot be added\n * to the display list directly. Instead use it as the texture for a PIXI.Sprite. If no frame is provided then the whole image is used.\n *\n * @class Texture\n * @uses EventTarget\n * @constructor\n * @param baseTexture {BaseTexture} The base texture source to create the texture from\n * @param frame {Rectangle} The rectangle frame of the texture to show\n * @param [crop] {Rectangle} The area of original texture \n * @param [trim] {Rectangle} Trimmed texture rectangle\n */\nPIXI.Texture = function(baseTexture, frame, crop, trim)\n{\n    /**\n     * Does this Texture have any frame data assigned to it?\n     *\n     * @property noFrame\n     * @type Boolean\n     */\n    this.noFrame = false;\n\n    if (!frame)\n    {\n        this.noFrame = true;\n        frame = new PIXI.Rectangle(0,0,1,1);\n    }\n\n    if (baseTexture instanceof PIXI.Texture)\n    {\n        baseTexture = baseTexture.baseTexture;\n    }\n\n    /**\n     * The base texture that this texture uses.\n     *\n     * @property baseTexture\n     * @type BaseTexture\n     */\n    this.baseTexture = baseTexture;\n\n    /**\n     * The frame specifies the region of the base texture that this texture uses\n     *\n     * @property frame\n     * @type Rectangle\n     */\n    this.frame = frame;\n\n    /**\n     * The texture trim data.\n     *\n     * @property trim\n     * @type Rectangle\n     */\n    this.trim = trim;\n\n    /**\n     * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.\n     *\n     * @property valid\n     * @type Boolean\n     */\n    this.valid = false;\n\n    /**\n     * This will let a renderer know that a texture has been updated (used mainly for webGL uv updates)\n     *\n     * @property requiresUpdate\n     * @type Boolean\n     */\n    this.requiresUpdate = false;\n\n    /**\n     * The WebGL UV data cache.\n     *\n     * @property _uvs\n     * @type Object\n     * @private\n     */\n    this._uvs = null;\n\n    /**\n     * The width of the Texture in pixels.\n     *\n     * @property width\n     * @type Number\n     */\n    this.width = 0;\n\n    /**\n     * The height of the Texture in pixels.\n     *\n     * @property height\n     * @type Number\n     */\n    this.height = 0;\n\n    /**\n     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n     *\n     * @property crop\n     * @type Rectangle\n     */\n    this.crop = crop || new PIXI.Rectangle(0, 0, 1, 1);\n\n    if (baseTexture.hasLoaded)\n    {\n        if (this.noFrame) frame = new PIXI.Rectangle(0, 0, baseTexture.width, baseTexture.height);\n        this.setFrame(frame);\n    }\n    else\n    {\n        baseTexture.addEventListener('loaded', this.onBaseTextureLoaded.bind(this));\n    }\n};\n\nPIXI.Texture.prototype.constructor = PIXI.Texture;\nPIXI.EventTarget.mixin(PIXI.Texture.prototype);\n\n/**\n * Called when the base texture is loaded\n *\n * @method onBaseTextureLoaded\n * @private\n */\nPIXI.Texture.prototype.onBaseTextureLoaded = function()\n{\n    var baseTexture = this.baseTexture;\n    baseTexture.removeEventListener('loaded', this.onLoaded);\n\n    if (this.noFrame) this.frame = new PIXI.Rectangle(0, 0, baseTexture.width, baseTexture.height);\n\n    this.setFrame(this.frame);\n\n    this.dispatchEvent( { type: 'update', content: this } );\n};\n\n/**\n * Destroys this texture\n *\n * @method destroy\n * @param destroyBase {Boolean} Whether to destroy the base texture as well\n */\nPIXI.Texture.prototype.destroy = function(destroyBase)\n{\n    if (destroyBase) this.baseTexture.destroy();\n\n    this.valid = false;\n};\n\n/**\n * Specifies the region of the baseTexture that this texture will use.\n *\n * @method setFrame\n * @param frame {Rectangle} The frame of the texture to set it to\n */\nPIXI.Texture.prototype.setFrame = function(frame)\n{\n    this.noFrame = false;\n\n    this.frame = frame;\n    this.width = frame.width;\n    this.height = frame.height;\n\n    this.crop.x = frame.x;\n    this.crop.y = frame.y;\n    this.crop.width = frame.width;\n    this.crop.height = frame.height;\n\n    if (!this.trim && (frame.x + frame.width > this.baseTexture.width || frame.y + frame.height > this.baseTexture.height))\n    {\n        throw new Error('Texture Error: frame does not fit inside the base Texture dimensions ' + this);\n    }\n\n    this.valid = frame && frame.width && frame.height && this.baseTexture.source && this.baseTexture.hasLoaded;\n\n    if (this.trim)\n    {\n        this.width = this.trim.width;\n        this.height = this.trim.height;\n        this.frame.width = this.trim.width;\n        this.frame.height = this.trim.height;\n    }\n    \n    if (this.valid) this._updateUvs();\n\n};\n\n/**\n * Updates the internal WebGL UV cache.\n *\n * @method _updateUvs\n * @private\n */\nPIXI.Texture.prototype._updateUvs = function()\n{\n    if(!this._uvs)this._uvs = new PIXI.TextureUvs();\n\n    var frame = this.crop;\n    var tw = this.baseTexture.width;\n    var th = this.baseTexture.height;\n    \n    this._uvs.x0 = frame.x / tw;\n    this._uvs.y0 = frame.y / th;\n\n    this._uvs.x1 = (frame.x + frame.width) / tw;\n    this._uvs.y1 = frame.y / th;\n\n    this._uvs.x2 = (frame.x + frame.width) / tw;\n    this._uvs.y2 = (frame.y + frame.height) / th;\n\n    this._uvs.x3 = frame.x / tw;\n    this._uvs.y3 = (frame.y + frame.height) / th;\n};\n\n/**\n * Helper function that creates a Texture object from the given image url.\n * If the image is not in the texture cache it will be  created and loaded.\n *\n * @static\n * @method fromImage\n * @param imageUrl {String} The image url of the texture\n * @param crossorigin {Boolean} Whether requests should be treated as crossorigin\n * @param scaleMode {Number} Should be one of the PIXI.scaleMode consts\n * @return Texture\n */\nPIXI.Texture.fromImage = function(imageUrl, crossorigin, scaleMode)\n{\n    var texture = PIXI.TextureCache[imageUrl];\n\n    if(!texture)\n    {\n        texture = new PIXI.Texture(PIXI.BaseTexture.fromImage(imageUrl, crossorigin, scaleMode));\n        PIXI.TextureCache[imageUrl] = texture;\n    }\n\n    return texture;\n};\n\n/**\n * Helper function that returns a Texture objected based on the given frame id.\n * If the frame id is not in the texture cache an error will be thrown.\n *\n * @static\n * @method fromFrame\n * @param frameId {String} The frame id of the texture\n * @return Texture\n */\nPIXI.Texture.fromFrame = function(frameId)\n{\n    var texture = PIXI.TextureCache[frameId];\n    if(!texture) throw new Error('The frameId \"' + frameId + '\" does not exist in the texture cache ');\n    return texture;\n};\n\n/**\n * Helper function that creates a new a Texture based on the given canvas element.\n *\n * @static\n * @method fromCanvas\n * @param canvas {Canvas} The canvas element source of the texture\n * @param scaleMode {Number} Should be one of the PIXI.scaleMode consts\n * @return Texture\n */\nPIXI.Texture.fromCanvas = function(canvas, scaleMode)\n{\n    var baseTexture = PIXI.BaseTexture.fromCanvas(canvas, scaleMode);\n\n    return new PIXI.Texture( baseTexture );\n\n};\n\n/**\n * Adds a texture to the global PIXI.TextureCache. This cache is shared across the whole PIXI object.\n *\n * @static\n * @method addTextureToCache\n * @param texture {Texture} The Texture to add to the cache.\n * @param id {String} The id that the texture will be stored against.\n */\nPIXI.Texture.addTextureToCache = function(texture, id)\n{\n    PIXI.TextureCache[id] = texture;\n};\n\n/**\n * Remove a texture from the global PIXI.TextureCache.\n *\n * @static\n * @method removeTextureFromCache\n * @param id {String} The id of the texture to be removed\n * @return {Texture} The texture that was removed\n */\nPIXI.Texture.removeTextureFromCache = function(id)\n{\n    var texture = PIXI.TextureCache[id];\n    delete PIXI.TextureCache[id];\n    delete PIXI.BaseTextureCache[id];\n    return texture;\n};\n\nPIXI.TextureUvs = function()\n{\n    this.x0 = 0;\n    this.y0 = 0;\n\n    this.x1 = 0;\n    this.y1 = 0;\n\n    this.x2 = 0;\n    this.y2 = 0;\n\n    this.x3 = 0;\n    this.y3 = 0;\n};\n\nPIXI.Texture.emptyTexture = new PIXI.Texture(new PIXI.BaseTexture());\n\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * A RenderTexture is a special texture that allows any Pixi display object to be rendered to it.\n *\n * __Hint__: All DisplayObjects (i.e. Sprites) that render to a RenderTexture should be preloaded otherwise black rectangles will be drawn instead.\n *\n * A RenderTexture takes a snapshot of any Display Object given to its render method. The position and rotation of the given Display Objects is ignored. For example:\n *\n *    var renderTexture = new PIXI.RenderTexture(800, 600);\n *    var sprite = PIXI.Sprite.fromImage(\"spinObj_01.png\");\n *    sprite.position.x = 800/2;\n *    sprite.position.y = 600/2;\n *    sprite.anchor.x = 0.5;\n *    sprite.anchor.y = 0.5;\n *    renderTexture.render(sprite);\n *\n * The Sprite in this case will be rendered to a position of 0,0. To render this sprite at its actual position a DisplayObjectContainer should be used:\n *\n *    var doc = new PIXI.DisplayObjectContainer();\n *    doc.addChild(sprite);\n *    renderTexture.render(doc);  // Renders to center of renderTexture\n *\n * @class RenderTexture\n * @extends Texture\n * @constructor\n * @param width {Number} The width of the render texture\n * @param height {Number} The height of the render texture\n * @param renderer {CanvasRenderer|WebGLRenderer} The renderer used for this RenderTexture\n * @param scaleMode {Number} Should be one of the PIXI.scaleMode consts\n * @param resolution {Number} The resolution of the texture being generated\n */\nPIXI.RenderTexture = function(width, height, renderer, scaleMode, resolution)\n{\n    /**\n     * The with of the render texture\n     *\n     * @property width\n     * @type Number\n     */\n    this.width = width || 100;\n\n    /**\n     * The height of the render texture\n     *\n     * @property height\n     * @type Number\n     */\n    this.height = height || 100;\n\n    /**\n     * The Resolution of the texture.\n     *\n     * @property resolution\n     * @type Number\n     */\n    this.resolution = resolution || 1;\n\n    /**\n     * The framing rectangle of the render texture\n     *\n     * @property frame\n     * @type Rectangle\n     */\n    this.frame = new PIXI.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution);\n\n    /**\n     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n     *\n     * @property crop\n     * @type Rectangle\n     */\n    this.crop = new PIXI.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution);\n\n    /**\n     * The base texture object that this texture uses\n     *\n     * @property baseTexture\n     * @type BaseTexture\n     */\n    this.baseTexture = new PIXI.BaseTexture();\n    this.baseTexture.width = this.width * this.resolution;\n    this.baseTexture.height = this.height * this.resolution;\n    this.baseTexture._glTextures = [];\n    this.baseTexture.resolution = this.resolution;\n\n    this.baseTexture.scaleMode = scaleMode || PIXI.scaleModes.DEFAULT;\n\n    this.baseTexture.hasLoaded = true;\n\n    PIXI.Texture.call(this,\n        this.baseTexture,\n        new PIXI.Rectangle(0, 0, this.width, this.height)\n    );\n\n    /**\n     * The renderer this RenderTexture uses. A RenderTexture can only belong to one renderer at the moment if its webGL.\n     *\n     * @property renderer\n     * @type CanvasRenderer|WebGLRenderer\n     */\n    this.renderer = renderer || PIXI.defaultRenderer;\n\n    if(this.renderer.type === PIXI.WEBGL_RENDERER)\n    {\n        var gl = this.renderer.gl;\n        this.baseTexture._dirty[gl.id] = false;\n\n        this.textureBuffer = new PIXI.FilterTexture(gl, this.width * this.resolution, this.height * this.resolution, this.baseTexture.scaleMode);\n        this.baseTexture._glTextures[gl.id] =  this.textureBuffer.texture;\n\n        this.render = this.renderWebGL;\n        this.projection = new PIXI.Point(this.width*0.5, -this.height*0.5);\n    }\n    else\n    {\n        this.render = this.renderCanvas;\n        this.textureBuffer = new PIXI.CanvasBuffer(this.width* this.resolution, this.height* this.resolution);\n        this.baseTexture.source = this.textureBuffer.canvas;\n    }\n\n    /**\n     * @property valid\n     * @type Boolean\n     */\n    this.valid = true;\n\n    this._updateUvs();\n};\n\nPIXI.RenderTexture.prototype = Object.create(PIXI.Texture.prototype);\nPIXI.RenderTexture.prototype.constructor = PIXI.RenderTexture;\n\n/**\n * Resizes the RenderTexture.\n *\n * @method resize\n * @param width {Number} The width to resize to.\n * @param height {Number} The height to resize to.\n * @param updateBase {Boolean} Should the baseTexture.width and height values be resized as well?\n */\nPIXI.RenderTexture.prototype.resize = function(width, height, updateBase)\n{\n    if (width === this.width && height === this.height)return;\n\n    this.valid = (width > 0 && height > 0);\n\n    this.width = this.frame.width = this.crop.width = width;\n    this.height =  this.frame.height = this.crop.height = height;\n\n    if (updateBase)\n    {\n        this.baseTexture.width = this.width;\n        this.baseTexture.height = this.height;\n    }\n\n    if (this.renderer.type === PIXI.WEBGL_RENDERER)\n    {\n        this.projection.x = this.width / 2;\n        this.projection.y = -this.height / 2;\n    }\n\n    if(!this.valid)return;\n\n    this.textureBuffer.resize(this.width * this.resolution, this.height * this.resolution);\n};\n\n/**\n * Clears the RenderTexture.\n *\n * @method clear\n */\nPIXI.RenderTexture.prototype.clear = function()\n{\n    if(!this.valid)return;\n\n    if (this.renderer.type === PIXI.WEBGL_RENDERER)\n    {\n        this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);\n    }\n\n    this.textureBuffer.clear();\n};\n\n/**\n * This function will draw the display object to the texture.\n *\n * @method renderWebGL\n * @param displayObject {DisplayObject} The display object to render this texture on\n * @param [matrix] {Matrix} Optional matrix to apply to the display object before rendering.\n * @param [clear] {Boolean} If true the texture will be cleared before the displayObject is drawn\n * @private\n */\nPIXI.RenderTexture.prototype.renderWebGL = function(displayObject, matrix, clear)\n{\n    if(!this.valid)return;\n    //TOOD replace position with matrix..\n   \n    //Lets create a nice matrix to apply to our display object. Frame buffers come in upside down so we need to flip the matrix \n    var wt = displayObject.worldTransform;\n    wt.identity();\n    wt.translate(0, this.projection.y * 2);\n    if(matrix)wt.append(matrix);\n    wt.scale(1,-1);\n\n    // setWorld Alpha to ensure that the object is renderer at full opacity\n    displayObject.worldAlpha = 1;\n\n    // Time to update all the children of the displayObject with the new matrix..    \n    var children = displayObject.children;\n\n    for(var i=0,j=children.length; i<j; i++)\n    {\n        children[i].updateTransform();\n    }\n    \n    // time for the webGL fun stuff!\n    var gl = this.renderer.gl;\n\n    gl.viewport(0, 0, this.width * this.resolution, this.height * this.resolution);\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer );\n\n    if(clear)this.textureBuffer.clear();\n\n    this.renderer.spriteBatch.dirty = true;\n\n    this.renderer.renderDisplayObject(displayObject, this.projection, this.textureBuffer.frameBuffer);\n\n    this.renderer.spriteBatch.dirty = true;\n};\n\n\n/**\n * This function will draw the display object to the texture.\n *\n * @method renderCanvas\n * @param displayObject {DisplayObject} The display object to render this texture on\n * @param [matrix] {Matrix} Optional matrix to apply to the display object before rendering.\n * @param [clear] {Boolean} If true the texture will be cleared before the displayObject is drawn\n * @private\n */\nPIXI.RenderTexture.prototype.renderCanvas = function(displayObject, matrix, clear)\n{\n    if(!this.valid)return;\n\n    var wt = displayObject.worldTransform;\n    wt.identity();\n    if(matrix)wt.append(matrix);\n    \n    // setWorld Alpha to ensure that the object is renderer at full opacity\n    displayObject.worldAlpha = 1;\n\n    // Time to update all the children of the displayObject with the new matrix..    \n    var children = displayObject.children;\n\n    for(var i = 0, j = children.length; i < j; i++)\n    {\n        children[i].updateTransform();\n    }\n\n    if(clear)this.textureBuffer.clear();\n\n    var context = this.textureBuffer.context;\n\n    var realResolution = this.renderer.resolution;\n\n    this.renderer.resolution = this.resolution;\n\n    this.renderer.renderDisplayObject(displayObject, context);\n\n    this.renderer.resolution = realResolution;\n};\n\n/**\n * Will return a HTML Image of the texture\n *\n * @method getImage\n * @return {Image}\n */\nPIXI.RenderTexture.prototype.getImage = function()\n{\n    var image = new Image();\n    image.src = this.getBase64();\n    return image;\n};\n\n/**\n * Will return a a base64 encoded string of this texture. It works by calling RenderTexture.getCanvas and then running toDataURL on that.\n *\n * @method getBase64\n * @return {String} A base64 encoded string of the texture.\n */\nPIXI.RenderTexture.prototype.getBase64 = function()\n{\n    return this.getCanvas().toDataURL();\n};\n\n/**\n * Creates a Canvas element, renders this RenderTexture to it and then returns it.\n *\n * @method getCanvas\n * @return {HTMLCanvasElement} A Canvas element with the texture rendered on.\n */\nPIXI.RenderTexture.prototype.getCanvas = function()\n{\n    if (this.renderer.type === PIXI.WEBGL_RENDERER)\n    {\n        var gl =  this.renderer.gl;\n        var width = this.textureBuffer.width;\n        var height = this.textureBuffer.height;\n\n        var webGLPixels = new Uint8Array(4 * width * height);\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);\n        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webGLPixels);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        var tempCanvas = new PIXI.CanvasBuffer(width, height);\n        var canvasData = tempCanvas.context.getImageData(0, 0, width, height);\n        canvasData.data.set(webGLPixels);\n\n        tempCanvas.context.putImageData(canvasData, 0, 0);\n\n        return tempCanvas.canvas;\n    }\n    else\n    {\n        return this.textureBuffer.canvas;\n    }\n};\n\nPIXI.RenderTexture.tempMatrix = new PIXI.Matrix();\n\n\nPIXI.VideoTexture = function( source, scaleMode )\n{\n    if( !source ){\n        throw new Error( 'No video source element specified.' );\n    }\n\n    // hook in here to check if video is already available.\n    // PIXI.BaseTexture looks for a source.complete boolean, plus width & height.\n\n    if( (source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA ) && source.width && source.height )\n    {\n        source.complete = true;\n    }\n\n    PIXI.BaseTexture.call( this, source, scaleMode );\n\n    this.autoUpdate = false;\n    this.updateBound = this._onUpdate.bind(this);\n\n    if( !source.complete )\n    {\n        this._onCanPlay = this.onCanPlay.bind(this);\n\n        source.addEventListener( 'canplay', this._onCanPlay );\n        source.addEventListener( 'canplaythrough', this._onCanPlay );\n\n        // started playing..\n        source.addEventListener( 'play', this.onPlayStart.bind(this) );\n        source.addEventListener( 'pause', this.onPlayStop.bind(this) );\n    }\n\n};\n\nPIXI.VideoTexture.prototype   = Object.create( PIXI.BaseTexture.prototype );\n\nPIXI.VideoTexture.constructor = PIXI.VideoTexture;\n\nPIXI.VideoTexture.prototype._onUpdate = function()\n{\n    if(this.autoUpdate)\n    {\n        window.requestAnimationFrame(this.updateBound);\n        this.dirty();\n    }\n};\n\nPIXI.VideoTexture.prototype.onPlayStart = function()\n{\n    if(!this.autoUpdate)\n    {\n        window.requestAnimationFrame(this.updateBound);\n        this.autoUpdate = true;\n    }\n};\n\nPIXI.VideoTexture.prototype.onPlayStop = function()\n{\n    this.autoUpdate = false;\n};\n\nPIXI.VideoTexture.prototype.onCanPlay = function()\n{\n    if( event.type === 'canplaythrough' )\n    {\n        this.hasLoaded  = true;\n\n\n        if( this.source )\n        {\n            this.source.removeEventListener( 'canplay', this._onCanPlay );\n            this.source.removeEventListener( 'canplaythrough', this._onCanPlay );\n\n            this.width      = this.source.videoWidth;\n            this.height     = this.source.videoHeight;\n\n            // prevent multiple loaded dispatches..\n            if( !this.__loaded ){\n                this.__loaded = true;\n                this.dispatchEvent( { type: 'loaded', content: this } );\n            }\n        }\n    }\n};\n\n\n/**\n * Mimic Pixi BaseTexture.from.... method.\n * @param video\n * @param scaleMode\n * @returns {PIXI.VideoTexture}\n */\nPIXI.VideoTexture.baseTextureFromVideo = function( video, scaleMode )\n{\n    if( !video._pixiId )\n    {\n        video._pixiId = 'video_' + PIXI.TextureCacheIdGenerator++;\n    }\n\n    var baseTexture = PIXI.BaseTextureCache[ video._pixiId ];\n\n    if( !baseTexture )\n    {\n        baseTexture = new PIXI.VideoTexture( video, scaleMode );\n        PIXI.BaseTextureCache[ video._pixiId ] = baseTexture;\n    }\n\n    return baseTexture;\n};\n\n\nPIXI.VideoTexture.prototype.destroy = function()\n{\n    if( this.source && this.source._pixiId )\n    {\n        PIXI.BaseTextureCache[ this.source._pixiId ] = null;\n        delete PIXI.BaseTextureCache[ this.source._pixiId ];\n\n        this.source._pixiId = null;\n        delete this.source._pixiId;\n    }\n\n    PIXI.BaseTexture.prototype.destroy.call( this );\n};\n\n/**\n * Mimic PIXI Texture.from... method.\n * @param video\n * @param scaleMode\n * @returns {PIXI.Texture}\n */\nPIXI.VideoTexture.textureFromVideo = function( video, scaleMode )\n{\n    var baseTexture = PIXI.VideoTexture.baseTextureFromVideo( video, scaleMode );\n    return new PIXI.Texture( baseTexture );\n};\n\nPIXI.VideoTexture.fromUrl = function( videoSrc, scaleMode )\n{\n    var video = document.createElement('video');\n    video.src = videoSrc;\n    video.autoPlay = true;\n    video.play();\n    return PIXI.VideoTexture.textureFromVideo( video, scaleMode);\n};\n\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * A Class that loads a bunch of images / sprite sheet / bitmap font files. Once the\n * assets have been loaded they are added to the PIXI Texture cache and can be accessed\n * easily through PIXI.Texture.fromImage() and PIXI.Sprite.fromImage()\n * When all items have been loaded this class will dispatch a 'onLoaded' event\n * As each individual item is loaded this class will dispatch a 'onProgress' event\n *\n * @class AssetLoader\n * @constructor\n * @uses EventTarget\n * @param assetURLs {Array<String>} An array of image/sprite sheet urls that you would like loaded\n *      supported. Supported image formats include 'jpeg', 'jpg', 'png', 'gif'. Supported\n *      sprite sheet data formats only include 'JSON' at this time. Supported bitmap font\n *      data formats include 'xml' and 'fnt'.\n * @param crossorigin {Boolean} Whether requests should be treated as crossorigin\n */\nPIXI.AssetLoader = function(assetURLs, crossorigin)\n{\n    /**\n     * The array of asset URLs that are going to be loaded\n     *\n     * @property assetURLs\n     * @type Array<String>\n     */\n    this.assetURLs = assetURLs;\n\n    /**\n     * Whether the requests should be treated as cross origin\n     *\n     * @property crossorigin\n     * @type Boolean\n     */\n    this.crossorigin = crossorigin;\n\n    /**\n     * Maps file extension to loader types\n     *\n     * @property loadersByType\n     * @type Object\n     */\n    this.loadersByType = {\n        'jpg':  PIXI.ImageLoader,\n        'jpeg': PIXI.ImageLoader,\n        'png':  PIXI.ImageLoader,\n        'gif':  PIXI.ImageLoader,\n        'webp': PIXI.ImageLoader,\n        'json': PIXI.JsonLoader,\n        'atlas': PIXI.AtlasLoader,\n        'anim': PIXI.SpineLoader,\n        'xml':  PIXI.BitmapFontLoader,\n        'fnt':  PIXI.BitmapFontLoader\n    };\n};\n\nPIXI.EventTarget.mixin(PIXI.AssetLoader.prototype);\n\n/**\n * Fired when an item has loaded\n * @event onProgress\n */\n\n/**\n * Fired when all the assets have loaded\n * @event onComplete\n */\n\n// constructor\nPIXI.AssetLoader.prototype.constructor = PIXI.AssetLoader;\n\n/**\n * Given a filename, returns its extension.\n *\n * @method _getDataType\n * @param str {String} the name of the asset\n */\nPIXI.AssetLoader.prototype._getDataType = function(str)\n{\n    var test = 'data:';\n    //starts with 'data:'\n    var start = str.slice(0, test.length).toLowerCase();\n    if (start === test) {\n        var data = str.slice(test.length);\n\n        var sepIdx = data.indexOf(',');\n        if (sepIdx === -1) //malformed data URI scheme\n            return null;\n\n        //e.g. 'image/gif;base64' => 'image/gif'\n        var info = data.slice(0, sepIdx).split(';')[0];\n\n        //We might need to handle some special cases here...\n        //standardize text/plain to 'txt' file extension\n        if (!info || info.toLowerCase() === 'text/plain')\n            return 'txt';\n\n        //User specified mime type, try splitting it by '/'\n        return info.split('/').pop().toLowerCase();\n    }\n\n    return null;\n};\n\n/**\n * Starts loading the assets sequentially\n *\n * @method load\n */\nPIXI.AssetLoader.prototype.load = function()\n{\n    var scope = this;\n\n    function onLoad(evt) {\n        scope.onAssetLoaded(evt.data.content);\n    }\n\n    this.loadCount = this.assetURLs.length;\n\n    for (var i=0; i < this.assetURLs.length; i++)\n    {\n        var fileName = this.assetURLs[i];\n        //first see if we have a data URI scheme..\n        var fileType = this._getDataType(fileName);\n\n        //if not, assume it's a file URI\n        if (!fileType)\n            fileType = fileName.split('?').shift().split('.').pop().toLowerCase();\n\n        var Constructor = this.loadersByType[fileType];\n        if(!Constructor)\n            throw new Error(fileType + ' is an unsupported file type');\n\n        var loader = new Constructor(fileName, this.crossorigin);\n\n        loader.on('loaded', onLoad);\n        loader.load();\n    }\n};\n\n/**\n * Invoked after each file is loaded\n *\n * @method onAssetLoaded\n * @private\n */\nPIXI.AssetLoader.prototype.onAssetLoaded = function(loader)\n{\n    this.loadCount--;\n    this.emit('onProgress', { content: this, loader: loader });\n    if (this.onProgress) this.onProgress(loader);\n\n    if (!this.loadCount)\n    {\n        this.emit('onComplete', { content: this });\n        if(this.onComplete) this.onComplete();\n    }\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * The json file loader is used to load in JSON data and parse it\n * When loaded this class will dispatch a 'loaded' event\n * If loading fails this class will dispatch an 'error' event\n *\n * @class JsonLoader\n * @uses EventTarget\n * @constructor\n * @param url {String} The url of the JSON file\n * @param crossorigin {Boolean} Whether requests should be treated as crossorigin\n */\nPIXI.JsonLoader = function (url, crossorigin) {\n\n    /**\n     * The url of the bitmap font data\n     *\n     * @property url\n     * @type String\n     */\n    this.url = url;\n\n    /**\n     * Whether the requests should be treated as cross origin\n     *\n     * @property crossorigin\n     * @type Boolean\n     */\n    this.crossorigin = crossorigin;\n\n    /**\n     * [read-only] The base url of the bitmap font data\n     *\n     * @property baseUrl\n     * @type String\n     * @readOnly\n     */\n    this.baseUrl = url.replace(/[^\\/]*$/, '');\n\n    /**\n     * [read-only] Whether the data has loaded yet\n     *\n     * @property loaded\n     * @type Boolean\n     * @readOnly\n     */\n    this.loaded = false;\n\n};\n\n// constructor\nPIXI.JsonLoader.prototype.constructor = PIXI.JsonLoader;\n\nPIXI.EventTarget.mixin(PIXI.JsonLoader.prototype);\n\n/**\n * Loads the JSON data\n *\n * @method load\n */\nPIXI.JsonLoader.prototype.load = function () {\n\n    if(window.XDomainRequest && this.crossorigin)\n    {\n        this.ajaxRequest = new window.XDomainRequest();\n\n        // XDomainRequest has a few quirks. Occasionally it will abort requests\n        // A way to avoid this is to make sure ALL callbacks are set even if not used\n        // More info here: http://stackoverflow.com/questions/15786966/xdomainrequest-aborts-post-on-ie-9\n        this.ajaxRequest.timeout = 3000;\n\n        this.ajaxRequest.onerror = this.onError.bind(this);\n\n        this.ajaxRequest.ontimeout = this.onError.bind(this);\n\n        this.ajaxRequest.onprogress = function() {};\n\n    }\n    else if (window.XMLHttpRequest)\n    {\n        this.ajaxRequest = new window.XMLHttpRequest();\n    }\n    else\n    {\n        this.ajaxRequest = new window.ActiveXObject('Microsoft.XMLHTTP');\n    }\n\n    this.ajaxRequest.onload = this.onJSONLoaded.bind(this);\n\n    this.ajaxRequest.open('GET',this.url,true);\n\n    this.ajaxRequest.send();\n};\n\n/**\n * Invoked when the JSON file is loaded.\n *\n * @method onJSONLoaded\n * @private\n */\nPIXI.JsonLoader.prototype.onJSONLoaded = function () {\n\n    if(!this.ajaxRequest.responseText )\n    {\n        this.onError();\n        return;\n    }\n\n    this.json = JSON.parse(this.ajaxRequest.responseText);\n\n    if(this.json.frames)\n    {\n        // sprite sheet\n        var textureUrl = this.baseUrl + this.json.meta.image;\n        var image = new PIXI.ImageLoader(textureUrl, this.crossorigin);\n        var frameData = this.json.frames;\n\n        this.texture = image.texture.baseTexture;\n        image.addEventListener('loaded', this.onLoaded.bind(this));\n\n        for (var i in frameData)\n        {\n            var rect = frameData[i].frame;\n\n            if (rect)\n            {\n                var textureSize = new PIXI.Rectangle(rect.x, rect.y, rect.w, rect.h);\n                var crop = textureSize.clone();\n                var trim = null;\n                \n                //  Check to see if the sprite is trimmed\n                if (frameData[i].trimmed)\n                {\n                    var actualSize = frameData[i].sourceSize;\n                    var realSize = frameData[i].spriteSourceSize;\n                    trim = new PIXI.Rectangle(realSize.x, realSize.y, actualSize.w, actualSize.h);\n                }\n                PIXI.TextureCache[i] = new PIXI.Texture(this.texture, textureSize, crop, trim);\n            }\n        }\n\n        image.load();\n\n    }\n    else if(this.json.bones)\n    {\n        // spine animation\n        var spineJsonParser = new spine.SkeletonJson();\n        var skeletonData = spineJsonParser.readSkeletonData(this.json);\n        PIXI.AnimCache[this.url] = skeletonData;\n        this.onLoaded();\n    }\n    else\n    {\n        this.onLoaded();\n    }\n};\n\n/**\n * Invoked when the json file has loaded.\n *\n * @method onLoaded\n * @private\n */\nPIXI.JsonLoader.prototype.onLoaded = function () {\n    this.loaded = true;\n    this.dispatchEvent({\n        type: 'loaded',\n        content: this\n    });\n};\n\n/**\n * Invoked if an error occurs.\n *\n * @method onError\n * @private\n */\nPIXI.JsonLoader.prototype.onError = function () {\n\n    this.dispatchEvent({\n        type: 'error',\n        content: this\n    });\n};\n\n/**\n * @author Martin Kelm http://mkelm.github.com\n */\n\n/**\n * The atlas file loader is used to load in Texture Atlas data and parse it. When loaded this class will dispatch a 'loaded' event. If loading fails this class will dispatch an 'error' event.\n *\n * To generate the data you can use http://www.codeandweb.com/texturepacker and publish in the 'JSON' format.\n * \n * It is highly recommended to use texture atlases (also know as 'sprite sheets') as it allowed sprites to be batched and drawn together for highly increased rendering speed.\n * Once the data has been loaded the frames are stored in the PIXI texture cache and can be accessed though PIXI.Texture.fromFrameId() and PIXI.Sprite.fromFrameId()\n * \n * @class AtlasLoader\n * @uses EventTarget\n * @constructor\n * @param url {String} The url of the JSON file\n * @param crossorigin {Boolean} Whether requests should be treated as crossorigin\n */\nPIXI.AtlasLoader = function (url, crossorigin) {\n    this.url = url;\n    this.baseUrl = url.replace(/[^\\/]*$/, '');\n    this.crossorigin = crossorigin;\n    this.loaded = false;\n\n};\n\n// constructor\nPIXI.AtlasLoader.constructor = PIXI.AtlasLoader;\n\nPIXI.EventTarget.mixin(PIXI.AtlasLoader.prototype);\n\n /**\n * Starts loading the JSON file\n *\n * @method load\n */\nPIXI.AtlasLoader.prototype.load = function () {\n    this.ajaxRequest = new PIXI.AjaxRequest();\n    this.ajaxRequest.onreadystatechange = this.onAtlasLoaded.bind(this);\n\n    this.ajaxRequest.open('GET', this.url, true);\n    if (this.ajaxRequest.overrideMimeType) this.ajaxRequest.overrideMimeType('application/json');\n    this.ajaxRequest.send(null);\n};\n\n/**\n * Invoked when the Atlas has fully loaded. Parses the JSON and builds the texture frames.\n * \n * @method onAtlasLoaded\n * @private\n */\nPIXI.AtlasLoader.prototype.onAtlasLoaded = function () {\n    if (this.ajaxRequest.readyState === 4) {\n        if (this.ajaxRequest.status === 200 || window.location.href.indexOf('http') === -1) {\n            this.atlas = {\n                meta : {\n                    image : []\n                },\n                frames : []\n            };\n            var result = this.ajaxRequest.responseText.split(/\\r?\\n/);\n            var lineCount = -3;\n\n            var currentImageId = 0;\n            var currentFrame = null;\n            var nameInNextLine = false;\n\n            var i = 0,\n                j = 0,\n                selfOnLoaded = this.onLoaded.bind(this);\n\n            // parser without rotation support yet!\n            for (i = 0; i < result.length; i++) {\n                result[i] = result[i].replace(/^\\s+|\\s+$/g, '');\n                if (result[i] === '') {\n                    nameInNextLine = i+1;\n                }\n                if (result[i].length > 0) {\n                    if (nameInNextLine === i) {\n                        this.atlas.meta.image.push(result[i]);\n                        currentImageId = this.atlas.meta.image.length - 1;\n                        this.atlas.frames.push({});\n                        lineCount = -3;\n                    } else if (lineCount > 0) {\n                        if (lineCount % 7 === 1) { // frame name\n                            if (currentFrame != null) { //jshint ignore:line\n                                this.atlas.frames[currentImageId][currentFrame.name] = currentFrame;\n                            }\n                            currentFrame = { name: result[i], frame : {} };\n                        } else {\n                            var text = result[i].split(' ');\n                            if (lineCount % 7 === 3) { // position\n                                currentFrame.frame.x = Number(text[1].replace(',', ''));\n                                currentFrame.frame.y = Number(text[2]);\n                            } else if (lineCount % 7 === 4) { // size\n                                currentFrame.frame.w = Number(text[1].replace(',', ''));\n                                currentFrame.frame.h = Number(text[2]);\n                            } else if (lineCount % 7 === 5) { // real size\n                                var realSize = {\n                                    x : 0,\n                                    y : 0,\n                                    w : Number(text[1].replace(',', '')),\n                                    h : Number(text[2])\n                                };\n\n                                if (realSize.w > currentFrame.frame.w || realSize.h > currentFrame.frame.h) {\n                                    currentFrame.trimmed = true;\n                                    currentFrame.realSize = realSize;\n                                } else {\n                                    currentFrame.trimmed = false;\n                                }\n                            }\n                        }\n                    }\n                    lineCount++;\n                }\n            }\n\n            if (currentFrame != null) { //jshint ignore:line\n                this.atlas.frames[currentImageId][currentFrame.name] = currentFrame;\n            }\n\n            if (this.atlas.meta.image.length > 0) {\n                this.images = [];\n                for (j = 0; j < this.atlas.meta.image.length; j++) {\n                    // sprite sheet\n                    var textureUrl = this.baseUrl + this.atlas.meta.image[j];\n                    var frameData = this.atlas.frames[j];\n                    this.images.push(new PIXI.ImageLoader(textureUrl, this.crossorigin));\n\n                    for (i in frameData) {\n                        var rect = frameData[i].frame;\n                        if (rect) {\n                            PIXI.TextureCache[i] = new PIXI.Texture(this.images[j].texture.baseTexture, {\n                                x: rect.x,\n                                y: rect.y,\n                                width: rect.w,\n                                height: rect.h\n                            });\n                            if (frameData[i].trimmed) {\n                                PIXI.TextureCache[i].realSize = frameData[i].realSize;\n                                // trim in pixi not supported yet, todo update trim properties if it is done ...\n                                PIXI.TextureCache[i].trim.x = 0;\n                                PIXI.TextureCache[i].trim.y = 0;\n                            }\n                        }\n                    }\n                }\n\n                this.currentImageId = 0;\n                for (j = 0; j < this.images.length; j++) {\n                    this.images[j].on('loaded', selfOnLoaded);\n                }\n                this.images[this.currentImageId].load();\n\n            } else {\n                this.onLoaded();\n            }\n\n        } else {\n            this.onError();\n        }\n    }\n};\n\n/**\n * Invoked when json file has loaded.\n * \n * @method onLoaded\n * @private\n */\nPIXI.AtlasLoader.prototype.onLoaded = function () {\n    if (this.images.length - 1 > this.currentImageId) {\n        this.currentImageId++;\n        this.images[this.currentImageId].load();\n    } else {\n        this.loaded = true;\n        this.emit('loaded', { content: this });\n    }\n};\n\n/**\n * Invoked when an error occurs.\n * \n * @method onError\n * @private\n */\nPIXI.AtlasLoader.prototype.onError = function () {\n    this.emit('error', { content: this });\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * The sprite sheet loader is used to load in JSON sprite sheet data\n * To generate the data you can use http://www.codeandweb.com/texturepacker and publish in the 'JSON' format\n * There is a free version so thats nice, although the paid version is great value for money.\n * It is highly recommended to use Sprite sheets (also know as a 'texture atlas') as it means sprites can be batched and drawn together for highly increased rendering speed.\n * Once the data has been loaded the frames are stored in the PIXI texture cache and can be accessed though PIXI.Texture.fromFrameId() and PIXI.Sprite.fromFrameId()\n * This loader will load the image file that the Spritesheet points to as well as the data.\n * When loaded this class will dispatch a 'loaded' event\n *\n * @class SpriteSheetLoader\n * @uses EventTarget\n * @constructor\n * @param url {String} The url of the sprite sheet JSON file\n * @param crossorigin {Boolean} Whether requests should be treated as crossorigin\n */\nPIXI.SpriteSheetLoader = function (url, crossorigin) {\n\n    /**\n     * The url of the atlas data\n     *\n     * @property url\n     * @type String\n     */\n    this.url = url;\n\n    /**\n     * Whether the requests should be treated as cross origin\n     *\n     * @property crossorigin\n     * @type Boolean\n     */\n    this.crossorigin = crossorigin;\n\n    /**\n     * [read-only] The base url of the bitmap font data\n     *\n     * @property baseUrl\n     * @type String\n     * @readOnly\n     */\n    this.baseUrl = url.replace(/[^\\/]*$/, '');\n\n    /**\n     * The texture being loaded\n     *\n     * @property texture\n     * @type Texture\n     */\n    this.texture = null;\n\n    /**\n     * The frames of the sprite sheet\n     *\n     * @property frames\n     * @type Object\n     */\n    this.frames = {};\n};\n\n// constructor\nPIXI.SpriteSheetLoader.prototype.constructor = PIXI.SpriteSheetLoader;\n\nPIXI.EventTarget.mixin(PIXI.SpriteSheetLoader.prototype);\n\n/**\n * This will begin loading the JSON file\n *\n * @method load\n */\nPIXI.SpriteSheetLoader.prototype.load = function () {\n    var scope = this;\n    var jsonLoader = new PIXI.JsonLoader(this.url, this.crossorigin);\n    jsonLoader.on('loaded', function (event) {\n        scope.json = event.data.content.json;\n        scope.onLoaded();\n    });\n    jsonLoader.load();\n};\n\n/**\n * Invoke when all files are loaded (json and texture)\n *\n * @method onLoaded\n * @private\n */\nPIXI.SpriteSheetLoader.prototype.onLoaded = function () {\n    this.emit('loaded', {\n        content: this\n    });\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * The image loader class is responsible for loading images file formats ('jpeg', 'jpg', 'png' and 'gif')\n * Once the image has been loaded it is stored in the PIXI texture cache and can be accessed though PIXI.Texture.fromFrame() and PIXI.Sprite.fromFrame()\n * When loaded this class will dispatch a 'loaded' event\n *\n * @class ImageLoader\n * @uses EventTarget\n * @constructor\n * @param url {String} The url of the image\n * @param crossorigin {Boolean} Whether requests should be treated as crossorigin\n */\nPIXI.ImageLoader = function(url, crossorigin)\n{\n    /**\n     * The texture being loaded\n     *\n     * @property texture\n     * @type Texture\n     */\n    this.texture = PIXI.Texture.fromImage(url, crossorigin);\n\n    /**\n     * if the image is loaded with loadFramedSpriteSheet\n     * frames will contain the sprite sheet frames\n     *\n     * @property frames\n     * @type Array\n     * @readOnly\n     */\n    this.frames = [];\n};\n\n// constructor\nPIXI.ImageLoader.prototype.constructor = PIXI.ImageLoader;\n\nPIXI.EventTarget.mixin(PIXI.ImageLoader.prototype);\n\n/**\n * Loads image or takes it from cache\n *\n * @method load\n */\nPIXI.ImageLoader.prototype.load = function()\n{\n    if(!this.texture.baseTexture.hasLoaded)\n    {\n        this.texture.baseTexture.on('loaded', this.onLoaded.bind(this));\n    }\n    else\n    {\n        this.onLoaded();\n    }\n};\n\n/**\n * Invoked when image file is loaded or it is already cached and ready to use\n *\n * @method onLoaded\n * @private\n */\nPIXI.ImageLoader.prototype.onLoaded = function()\n{\n    this.emit('loaded', { content: this });\n};\n\n/**\n * Loads image and split it to uniform sized frames\n *\n * @method loadFramedSpriteSheet\n * @param frameWidth {Number} width of each frame\n * @param frameHeight {Number} height of each frame\n * @param textureName {String} if given, the frames will be cached in <textureName>-<ord> format\n */\nPIXI.ImageLoader.prototype.loadFramedSpriteSheet = function(frameWidth, frameHeight, textureName)\n{\n    this.frames = [];\n    var cols = Math.floor(this.texture.width / frameWidth);\n    var rows = Math.floor(this.texture.height / frameHeight);\n\n    var i=0;\n    for (var y=0; y<rows; y++)\n    {\n        for (var x=0; x<cols; x++,i++)\n        {\n            var texture = new PIXI.Texture(this.texture.baseTexture, {\n                x: x*frameWidth,\n                y: y*frameHeight,\n                width: frameWidth,\n                height: frameHeight\n            });\n\n            this.frames.push(texture);\n            if (textureName) PIXI.TextureCache[textureName + '-' + i] = texture;\n        }\n    }\n\n	this.load();\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * The xml loader is used to load in XML bitmap font data ('xml' or 'fnt')\n * To generate the data you can use http://www.angelcode.com/products/bmfont/\n * This loader will also load the image file as the data.\n * When loaded this class will dispatch a 'loaded' event\n *\n * @class BitmapFontLoader\n * @uses EventTarget\n * @constructor\n * @param url {String} The url of the sprite sheet JSON file\n * @param crossorigin {Boolean} Whether requests should be treated as crossorigin\n */\nPIXI.BitmapFontLoader = function(url, crossorigin)\n{\n    /**\n     * The url of the bitmap font data\n     *\n     * @property url\n     * @type String\n     */\n    this.url = url;\n\n    /**\n     * Whether the requests should be treated as cross origin\n     *\n     * @property crossorigin\n     * @type Boolean\n     */\n    this.crossorigin = crossorigin;\n\n    /**\n     * [read-only] The base url of the bitmap font data\n     *\n     * @property baseUrl\n     * @type String\n     * @readOnly\n     */\n    this.baseUrl = url.replace(/[^\\/]*$/, '');\n\n    /**\n     * [read-only] The texture of the bitmap font\n     *\n     * @property texture\n     * @type Texture\n     */\n    this.texture = null;\n};\n\n// constructor\nPIXI.BitmapFontLoader.prototype.constructor = PIXI.BitmapFontLoader;\nPIXI.EventTarget.mixin(PIXI.BitmapFontLoader.prototype);\n\n/**\n * Loads the XML font data\n *\n * @method load\n */\nPIXI.BitmapFontLoader.prototype.load = function()\n{\n    this.ajaxRequest = new PIXI.AjaxRequest();\n    this.ajaxRequest.onreadystatechange = this.onXMLLoaded.bind(this);\n\n    this.ajaxRequest.open('GET', this.url, true);\n    if (this.ajaxRequest.overrideMimeType) this.ajaxRequest.overrideMimeType('application/xml');\n    this.ajaxRequest.send(null);\n};\n\n/**\n * Invoked when the XML file is loaded, parses the data.\n *\n * @method onXMLLoaded\n * @private\n */\nPIXI.BitmapFontLoader.prototype.onXMLLoaded = function()\n{\n    if (this.ajaxRequest.readyState === 4)\n    {\n        if (this.ajaxRequest.status === 200 || window.location.protocol.indexOf('http') === -1)\n        {\n            var responseXML = this.ajaxRequest.responseXML;\n            if(!responseXML || /MSIE 9/i.test(navigator.userAgent) || navigator.isCocoonJS) {\n                if(typeof(window.DOMParser) === 'function') {\n                    var domparser = new DOMParser();\n                    responseXML = domparser.parseFromString(this.ajaxRequest.responseText, 'text/xml');\n                } else {\n                    var div = document.createElement('div');\n                    div.innerHTML = this.ajaxRequest.responseText;\n                    responseXML = div;\n                }\n            }\n\n            var textureUrl = this.baseUrl + responseXML.getElementsByTagName('page')[0].getAttribute('file');\n            var image = new PIXI.ImageLoader(textureUrl, this.crossorigin);\n            this.texture = image.texture.baseTexture;\n\n            var data = {};\n            var info = responseXML.getElementsByTagName('info')[0];\n            var common = responseXML.getElementsByTagName('common')[0];\n            data.font = info.getAttribute('face');\n            data.size = parseInt(info.getAttribute('size'), 10);\n            data.lineHeight = parseInt(common.getAttribute('lineHeight'), 10);\n            data.chars = {};\n\n            //parse letters\n            var letters = responseXML.getElementsByTagName('char');\n\n            for (var i = 0; i < letters.length; i++)\n            {\n                var charCode = parseInt(letters[i].getAttribute('id'), 10);\n\n                var textureRect = new PIXI.Rectangle(\n                    parseInt(letters[i].getAttribute('x'), 10),\n                    parseInt(letters[i].getAttribute('y'), 10),\n                    parseInt(letters[i].getAttribute('width'), 10),\n                    parseInt(letters[i].getAttribute('height'), 10)\n                );\n\n                data.chars[charCode] = {\n                    xOffset: parseInt(letters[i].getAttribute('xoffset'), 10),\n                    yOffset: parseInt(letters[i].getAttribute('yoffset'), 10),\n                    xAdvance: parseInt(letters[i].getAttribute('xadvance'), 10),\n                    kerning: {},\n                    texture: PIXI.TextureCache[charCode] = new PIXI.Texture(this.texture, textureRect)\n\n                };\n            }\n\n            //parse kernings\n            var kernings = responseXML.getElementsByTagName('kerning');\n            for (i = 0; i < kernings.length; i++)\n            {\n                var first = parseInt(kernings[i].getAttribute('first'), 10);\n                var second = parseInt(kernings[i].getAttribute('second'), 10);\n                var amount = parseInt(kernings[i].getAttribute('amount'), 10);\n\n                data.chars[second].kerning[first] = amount;\n\n            }\n\n            PIXI.BitmapText.fonts[data.font] = data;\n\n            image.addEventListener('loaded', this.onLoaded.bind(this));\n            image.load();\n        }\n    }\n};\n\n/**\n * Invoked when all files are loaded (xml/fnt and texture)\n *\n * @method onLoaded\n * @private\n */\nPIXI.BitmapFontLoader.prototype.onLoaded = function()\n{\n    this.emit('loaded', { content: this });\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n * based on pixi impact spine implementation made by Eemeli Kelokorpi (@ekelokorpi) https://github.com/ekelokorpi\n *\n * Awesome JS run time provided by EsotericSoftware\n * https://github.com/EsotericSoftware/spine-runtimes\n *\n */\n\n/**\n * The Spine loader is used to load in JSON spine data\n * To generate the data you need to use http://esotericsoftware.com/ and export in the \"JSON\" format\n * Due to a clash of names  You will need to change the extension of the spine file from *.json to *.anim for it to load\n * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source\n * You will need to generate a sprite sheet to accompany the spine data\n * When loaded this class will dispatch a \"loaded\" event\n *\n * @class SpineLoader\n * @uses EventTarget\n * @constructor\n * @param url {String} The url of the JSON file\n * @param crossorigin {Boolean} Whether requests should be treated as crossorigin\n */\nPIXI.SpineLoader = function(url, crossorigin)\n{\n    /**\n     * The url of the bitmap font data\n     *\n     * @property url\n     * @type String\n     */\n    this.url = url;\n\n    /**\n     * Whether the requests should be treated as cross origin\n     *\n     * @property crossorigin\n     * @type Boolean\n     */\n    this.crossorigin = crossorigin;\n\n    /**\n     * [read-only] Whether the data has loaded yet\n     *\n     * @property loaded\n     * @type Boolean\n     * @readOnly\n     */\n    this.loaded = false;\n};\n\nPIXI.SpineLoader.prototype.constructor = PIXI.SpineLoader;\n\nPIXI.EventTarget.mixin(PIXI.SpineLoader.prototype);\n\n/**\n * Loads the JSON data\n *\n * @method load\n */\nPIXI.SpineLoader.prototype.load = function () {\n\n    var scope = this;\n    var jsonLoader = new PIXI.JsonLoader(this.url, this.crossorigin);\n    jsonLoader.on('loaded', function (event) {\n        scope.json = event.data.content.json;\n        scope.onLoaded();\n    });\n    jsonLoader.load();\n};\n\n/**\n * Invoked when JSON file is loaded.\n *\n * @method onLoaded\n * @private\n */\nPIXI.SpineLoader.prototype.onLoaded = function () {\n    this.loaded = true;\n    this.emit('loaded', { content: this });\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * This is the base class for creating a PIXI filter. Currently only webGL supports filters.\n * If you want to make a custom filter this should be your base class.\n * @class AbstractFilter\n * @constructor\n * @param fragmentSrc {Array} The fragment source in an array of strings.\n * @param uniforms {Object} An object containing the uniforms for this filter.\n */\nPIXI.AbstractFilter = function(fragmentSrc, uniforms)\n{\n    /**\n    * An array of passes - some filters contain a few steps this array simply stores the steps in a liniear fashion.\n    * For example the blur filter has two passes blurX and blurY.\n    * @property passes\n    * @type Array an array of filter objects\n    * @private\n    */\n    this.passes = [this];\n\n    /**\n    * @property shaders\n    * @type Array an array of shaders\n    * @private\n    */\n    this.shaders = [];\n    \n    /**\n    * @property dirty\n    * @type Boolean\n    */\n    this.dirty = true;\n\n    /**\n    * @property padding\n    * @type Number\n    */\n    this.padding = 0;\n\n    /**\n    * @property uniforms\n    * @type object\n    * @private\n    */\n    this.uniforms = uniforms || {};\n\n    /**\n    * @property fragmentSrc\n    * @type Array\n    * @private\n    */\n    this.fragmentSrc = fragmentSrc || [];\n};\n\nPIXI.AbstractFilter.prototype.constructor = PIXI.AbstractFilter;\n\n/**\n * Syncs the uniforms between the class object and the shaders.\n *\n * @method syncUniforms\n */\nPIXI.AbstractFilter.prototype.syncUniforms = function()\n{\n    for(var i=0,j=this.shaders.length; i<j; i++)\n    {\n        this.shaders[i].dirty = true;\n    }\n};\n\n/*\nPIXI.AbstractFilter.prototype.apply = function(frameBuffer)\n{\n    // TODO :)\n};\n*/\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * The AlphaMaskFilter class uses the pixel values from the specified texture (called the displacement map) to perform a displacement of an object.\n * You can use this filter to apply all manor of crazy warping effects\n * Currently the r property of the texture is used to offset the x and the g property of the texture is used to offset the y.\n * \n * @class AlphaMaskFilter\n * @extends AbstractFilter\n * @constructor\n * @param texture {Texture} The texture used for the displacement map * must be power of 2 texture at the moment\n */\nPIXI.AlphaMaskFilter = function(texture)\n{\n    PIXI.AbstractFilter.call( this );\n\n    this.passes = [this];\n    texture.baseTexture._powerOf2 = true;\n\n    // set the uniforms\n    this.uniforms = {\n        mask: {type: 'sampler2D', value:texture},\n        mapDimensions:   {type: '2f', value:{x:1, y:5112}},\n        dimensions:   {type: '4fv', value:[0,0,0,0]}\n    };\n\n    if(texture.baseTexture.hasLoaded)\n    {\n        this.uniforms.mask.value.x = texture.width;\n        this.uniforms.mask.value.y = texture.height;\n    }\n    else\n    {\n        this.boundLoadedFunction = this.onTextureLoaded.bind(this);\n\n        texture.baseTexture.on('loaded', this.boundLoadedFunction);\n    }\n\n    this.fragmentSrc = [\n        'precision mediump float;',\n        'varying vec2 vTextureCoord;',\n        'varying vec4 vColor;',\n        'uniform sampler2D mask;',\n        'uniform sampler2D uSampler;',\n        'uniform vec2 offset;',\n        'uniform vec4 dimensions;',\n        'uniform vec2 mapDimensions;',\n\n        'void main(void) {',\n        '   vec2 mapCords = vTextureCoord.xy;',\n        '   mapCords += (dimensions.zw + offset)/ dimensions.xy ;',\n        '   mapCords.y *= -1.0;',\n        '   mapCords.y += 1.0;',\n        '   mapCords *= dimensions.xy / mapDimensions;',\n\n        '   vec4 original =  texture2D(uSampler, vTextureCoord);',\n        '   float maskAlpha =  texture2D(mask, mapCords).r;',\n        '   original *= maskAlpha;',\n        //'   original.rgb *= maskAlpha;',\n        '   gl_FragColor =  original;',\n        //'   gl_FragColor = gl_FragColor;',\n        '}'\n    ];\n};\n\nPIXI.AlphaMaskFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );\nPIXI.AlphaMaskFilter.prototype.constructor = PIXI.AlphaMaskFilter;\n\n/**\n * Sets the map dimensions uniforms when the texture becomes available.\n *\n * @method onTextureLoaded\n */\nPIXI.AlphaMaskFilter.prototype.onTextureLoaded = function()\n{\n    this.uniforms.mapDimensions.value.x = this.uniforms.mask.value.width;\n    this.uniforms.mapDimensions.value.y = this.uniforms.mask.value.height;\n\n    this.uniforms.mask.value.baseTexture.off('loaded', this.boundLoadedFunction);\n};\n\n/**\n * The texture used for the displacement map. Must be power of 2 sized texture.\n *\n * @property map\n * @type Texture\n */\nObject.defineProperty(PIXI.AlphaMaskFilter.prototype, 'map', {\n    get: function() {\n        return this.uniforms.mask.value;\n    },\n    set: function(value) {\n        this.uniforms.mask.value = value;\n    }\n});\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * The ColorMatrixFilter class lets you apply a 4x4 matrix transformation on the RGBA\n * color and alpha values of every pixel on your displayObject to produce a result\n * with a new set of RGBA color and alpha values. It's pretty powerful!\n * \n * @class ColorMatrixFilter\n * @extends AbstractFilter\n * @constructor\n */\nPIXI.ColorMatrixFilter = function()\n{\n    PIXI.AbstractFilter.call( this );\n\n    this.passes = [this];\n\n    // set the uniforms\n    this.uniforms = {\n        matrix: {type: 'mat4', value: [1,0,0,0,\n                                       0,1,0,0,\n                                       0,0,1,0,\n                                       0,0,0,1]}\n    };\n\n    this.fragmentSrc = [\n        'precision mediump float;',\n        'varying vec2 vTextureCoord;',\n        'varying vec4 vColor;',\n        'uniform float invert;',\n        'uniform mat4 matrix;',\n        'uniform sampler2D uSampler;',\n\n        'void main(void) {',\n        '   gl_FragColor = texture2D(uSampler, vTextureCoord) * matrix;',\n      //  '   gl_FragColor = gl_FragColor;',\n        '}'\n    ];\n};\n\nPIXI.ColorMatrixFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );\nPIXI.ColorMatrixFilter.prototype.constructor = PIXI.ColorMatrixFilter;\n\n/**\n * Sets the matrix of the color matrix filter\n *\n * @property matrix\n * @type Array and array of 26 numbers\n * @default [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]\n */\nObject.defineProperty(PIXI.ColorMatrixFilter.prototype, 'matrix', {\n    get: function() {\n        return this.uniforms.matrix.value;\n    },\n    set: function(value) {\n        this.uniforms.matrix.value = value;\n    }\n});\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * This greyscales the palette of your Display Objects.\n * \n * @class GrayFilter\n * @extends AbstractFilter\n * @constructor\n */\nPIXI.GrayFilter = function()\n{\n    PIXI.AbstractFilter.call( this );\n\n    this.passes = [this];\n\n    // set the uniforms\n    this.uniforms = {\n        gray: {type: '1f', value: 1}\n    };\n\n    this.fragmentSrc = [\n        'precision mediump float;',\n        'varying vec2 vTextureCoord;',\n        'varying vec4 vColor;',\n        'uniform sampler2D uSampler;',\n        'uniform float gray;',\n\n        'void main(void) {',\n        '   gl_FragColor = texture2D(uSampler, vTextureCoord);',\n        '   gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.2126*gl_FragColor.r + 0.7152*gl_FragColor.g + 0.0722*gl_FragColor.b), gray);',\n     //   '   gl_FragColor = gl_FragColor;',\n        '}'\n    ];\n};\n\nPIXI.GrayFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );\nPIXI.GrayFilter.prototype.constructor = PIXI.GrayFilter;\n\n/**\n * The strength of the gray. 1 will make the object black and white, 0 will make the object its normal color.\n * @property gray\n * @type Number\n */\nObject.defineProperty(PIXI.GrayFilter.prototype, 'gray', {\n    get: function() {\n        return this.uniforms.gray.value;\n    },\n    set: function(value) {\n        this.uniforms.gray.value = value;\n    }\n});\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * The DisplacementFilter class uses the pixel values from the specified texture (called the displacement map) to perform a displacement of an object.\n * You can use this filter to apply all manor of crazy warping effects\n * Currently the r property of the texture is used offset the x and the g property of the texture is used to offset the y.\n * \n * @class DisplacementFilter\n * @extends AbstractFilter\n * @constructor\n * @param texture {Texture} The texture used for the displacement map * must be power of 2 texture at the moment\n */\nPIXI.DisplacementFilter = function(texture)\n{\n    PIXI.AbstractFilter.call( this );\n\n    this.passes = [this];\n    texture.baseTexture._powerOf2 = true;\n\n    // set the uniforms\n    this.uniforms = {\n        displacementMap: {type: 'sampler2D', value:texture},\n        scale:           {type: '2f', value:{x:30, y:30}},\n        offset:          {type: '2f', value:{x:0, y:0}},\n        mapDimensions:   {type: '2f', value:{x:1, y:5112}},\n        dimensions:   {type: '4fv', value:[0,0,0,0]}\n    };\n\n    if(texture.baseTexture.hasLoaded)\n    {\n        this.uniforms.mapDimensions.value.x = texture.width;\n        this.uniforms.mapDimensions.value.y = texture.height;\n    }\n    else\n    {\n        this.boundLoadedFunction = this.onTextureLoaded.bind(this);\n\n        texture.baseTexture.on('loaded', this.boundLoadedFunction);\n    }\n\n    this.fragmentSrc = [\n        'precision mediump float;',\n        'varying vec2 vTextureCoord;',\n        'varying vec4 vColor;',\n        'uniform sampler2D displacementMap;',\n        'uniform sampler2D uSampler;',\n        'uniform vec2 scale;',\n        'uniform vec2 offset;',\n        'uniform vec4 dimensions;',\n        'uniform vec2 mapDimensions;',// = vec2(256.0, 256.0);',\n        // 'const vec2 textureDimensions = vec2(750.0, 750.0);',\n\n        'void main(void) {',\n        '   vec2 mapCords = vTextureCoord.xy;',\n        //'   mapCords -= ;',\n        '   mapCords += (dimensions.zw + offset)/ dimensions.xy ;',\n        '   mapCords.y *= -1.0;',\n        '   mapCords.y += 1.0;',\n        '   vec2 matSample = texture2D(displacementMap, mapCords).xy;',\n        '   matSample -= 0.5;',\n        '   matSample *= scale;',\n        '   matSample /= mapDimensions;',\n        '   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x + matSample.x, vTextureCoord.y + matSample.y));',\n        '   gl_FragColor.rgb = mix( gl_FragColor.rgb, gl_FragColor.rgb, 1.0);',\n        '   vec2 cord = vTextureCoord;',\n\n        //'   gl_FragColor =  texture2D(displacementMap, cord);',\n     //   '   gl_FragColor = gl_FragColor;',\n        '}'\n    ];\n};\n\nPIXI.DisplacementFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );\nPIXI.DisplacementFilter.prototype.constructor = PIXI.DisplacementFilter;\n\n/**\n * Sets the map dimensions uniforms when the texture becomes available.\n *\n * @method onTextureLoaded\n */\nPIXI.DisplacementFilter.prototype.onTextureLoaded = function()\n{\n    this.uniforms.mapDimensions.value.x = this.uniforms.displacementMap.value.width;\n    this.uniforms.mapDimensions.value.y = this.uniforms.displacementMap.value.height;\n\n    this.uniforms.displacementMap.value.baseTexture.off('loaded', this.boundLoadedFunction);\n};\n\n/**\n * The texture used for the displacement map. Must be power of 2 texture.\n *\n * @property map\n * @type Texture\n */\nObject.defineProperty(PIXI.DisplacementFilter.prototype, 'map', {\n    get: function() {\n        return this.uniforms.displacementMap.value;\n    },\n    set: function(value) {\n        this.uniforms.displacementMap.value = value;\n    }\n});\n\n/**\n * The multiplier used to scale the displacement result from the map calculation.\n *\n * @property scale\n * @type Point\n */\nObject.defineProperty(PIXI.DisplacementFilter.prototype, 'scale', {\n    get: function() {\n        return this.uniforms.scale.value;\n    },\n    set: function(value) {\n        this.uniforms.scale.value = value;\n    }\n});\n\n/**\n * The offset used to move the displacement map.\n *\n * @property offset\n * @type Point\n */\nObject.defineProperty(PIXI.DisplacementFilter.prototype, 'offset', {\n    get: function() {\n        return this.uniforms.offset.value;\n    },\n    set: function(value) {\n        this.uniforms.offset.value = value;\n    }\n});\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * This filter applies a pixelate effect making display objects appear 'blocky'.\n * \n * @class PixelateFilter\n * @extends AbstractFilter\n * @constructor\n */\nPIXI.PixelateFilter = function()\n{\n    PIXI.AbstractFilter.call( this );\n\n    this.passes = [this];\n\n    // set the uniforms\n    this.uniforms = {\n        invert: {type: '1f', value: 0},\n        dimensions: {type: '4fv', value:new PIXI.Float32Array([10000, 100, 10, 10])},\n        pixelSize: {type: '2f', value:{x:10, y:10}}\n    };\n\n    this.fragmentSrc = [\n        'precision mediump float;',\n        'varying vec2 vTextureCoord;',\n        'varying vec4 vColor;',\n        'uniform vec2 testDim;',\n        'uniform vec4 dimensions;',\n        'uniform vec2 pixelSize;',\n        'uniform sampler2D uSampler;',\n\n        'void main(void) {',\n        '   vec2 coord = vTextureCoord;',\n\n        '   vec2 size = dimensions.xy/pixelSize;',\n\n        '   vec2 color = floor( ( vTextureCoord * size ) ) / size + pixelSize/dimensions.xy * 0.5;',\n        '   gl_FragColor = texture2D(uSampler, color);',\n        '}'\n    ];\n};\n\nPIXI.PixelateFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );\nPIXI.PixelateFilter.prototype.constructor = PIXI.PixelateFilter;\n\n/**\n * This a point that describes the size of the blocks. x is the width of the block and y is the height.\n * \n * @property size\n * @type Point\n */\nObject.defineProperty(PIXI.PixelateFilter.prototype, 'size', {\n    get: function() {\n        return this.uniforms.pixelSize.value;\n    },\n    set: function(value) {\n        this.dirty = true;\n        this.uniforms.pixelSize.value = value;\n    }\n});\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * The BlurXFilter applies a horizontal Gaussian blur to an object.\n *\n * @class BlurXFilter\n * @extends AbstractFilter\n * @constructor\n */\nPIXI.BlurXFilter = function()\n{\n    PIXI.AbstractFilter.call( this );\n\n    this.passes = [this];\n\n    // set the uniforms\n    this.uniforms = {\n        blur: {type: '1f', value: 1/512}\n    };\n\n    this.fragmentSrc = [\n        'precision mediump float;',\n        'varying vec2 vTextureCoord;',\n        'varying vec4 vColor;',\n        'uniform float blur;',\n        'uniform sampler2D uSampler;',\n\n        'void main(void) {',\n        '   vec4 sum = vec4(0.0);',\n\n        '   sum += texture2D(uSampler, vec2(vTextureCoord.x - 4.0*blur, vTextureCoord.y)) * 0.05;',\n        '   sum += texture2D(uSampler, vec2(vTextureCoord.x - 3.0*blur, vTextureCoord.y)) * 0.09;',\n        '   sum += texture2D(uSampler, vec2(vTextureCoord.x - 2.0*blur, vTextureCoord.y)) * 0.12;',\n        '   sum += texture2D(uSampler, vec2(vTextureCoord.x - blur, vTextureCoord.y)) * 0.15;',\n        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * 0.16;',\n        '   sum += texture2D(uSampler, vec2(vTextureCoord.x + blur, vTextureCoord.y)) * 0.15;',\n        '   sum += texture2D(uSampler, vec2(vTextureCoord.x + 2.0*blur, vTextureCoord.y)) * 0.12;',\n        '   sum += texture2D(uSampler, vec2(vTextureCoord.x + 3.0*blur, vTextureCoord.y)) * 0.09;',\n        '   sum += texture2D(uSampler, vec2(vTextureCoord.x + 4.0*blur, vTextureCoord.y)) * 0.05;',\n\n        '   gl_FragColor = sum;',\n        '}'\n    ];\n};\n\nPIXI.BlurXFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );\nPIXI.BlurXFilter.prototype.constructor = PIXI.BlurXFilter;\n\n/**\n * Sets the strength of both the blur.\n *\n * @property blur\n * @type Number the strength of the blur\n * @default 2\n */\nObject.defineProperty(PIXI.BlurXFilter.prototype, 'blur', {\n    get: function() {\n        return this.uniforms.blur.value / (1/7000);\n    },\n    set: function(value) {\n\n        this.dirty = true;\n        this.uniforms.blur.value = (1/7000) * value;\n    }\n});\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * The BlurYFilter applies a vertical Gaussian blur to an object.\n *\n * @class BlurYFilter\n * @extends AbstractFilter\n * @constructor\n */\nPIXI.BlurYFilter = function()\n{\n    PIXI.AbstractFilter.call( this );\n\n    this.passes = [this];\n\n    // set the uniforms\n    this.uniforms = {\n        blur: {type: '1f', value: 1/512}\n    };\n\n    this.fragmentSrc = [\n        'precision mediump float;',\n        'varying vec2 vTextureCoord;',\n        'varying vec4 vColor;',\n        'uniform float blur;',\n        'uniform sampler2D uSampler;',\n\n        'void main(void) {',\n        '   vec4 sum = vec4(0.0);',\n\n        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - 4.0*blur)) * 0.05;',\n        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - 3.0*blur)) * 0.09;',\n        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - 2.0*blur)) * 0.12;',\n        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - blur)) * 0.15;',\n        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * 0.16;',\n        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + blur)) * 0.15;',\n        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + 2.0*blur)) * 0.12;',\n        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + 3.0*blur)) * 0.09;',\n        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + 4.0*blur)) * 0.05;',\n\n        '   gl_FragColor = sum;',\n        '}'\n    ];\n};\n\nPIXI.BlurYFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );\nPIXI.BlurYFilter.prototype.constructor = PIXI.BlurYFilter;\n\n/**\n * Sets the strength of both the blur.\n *\n * @property blur\n * @type Number the strength of the blur\n * @default 2\n */\nObject.defineProperty(PIXI.BlurYFilter.prototype, 'blur', {\n    get: function() {\n        return this.uniforms.blur.value / (1/7000);\n    },\n    set: function(value) {\n        //this.padding = value;\n        this.uniforms.blur.value = (1/7000) * value;\n    }\n});\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * The BlurFilter applies a Gaussian blur to an object.\n * The strength of the blur can be set for x- and y-axis separately (always relative to the stage).\n *\n * @class BlurFilter\n * @extends AbstractFilter\n * @constructor\n */\nPIXI.BlurFilter = function()\n{\n    this.blurXFilter = new PIXI.BlurXFilter();\n    this.blurYFilter = new PIXI.BlurYFilter();\n\n    this.passes =[this.blurXFilter, this.blurYFilter];\n};\n\nPIXI.BlurFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );\nPIXI.BlurFilter.prototype.constructor = PIXI.BlurFilter;\n\n/**\n * Sets the strength of both the blurX and blurY properties simultaneously\n *\n * @property blur\n * @type Number the strength of the blur\n * @default 2\n */\nObject.defineProperty(PIXI.BlurFilter.prototype, 'blur', {\n    get: function() {\n        return this.blurXFilter.blur;\n    },\n    set: function(value) {\n        this.blurXFilter.blur = this.blurYFilter.blur = value;\n    }\n});\n\n/**\n * Sets the strength of the blurX property\n *\n * @property blurX\n * @type Number the strength of the blurX\n * @default 2\n */\nObject.defineProperty(PIXI.BlurFilter.prototype, 'blurX', {\n    get: function() {\n        return this.blurXFilter.blur;\n    },\n    set: function(value) {\n        this.blurXFilter.blur = value;\n    }\n});\n\n/**\n * Sets the strength of the blurY property\n *\n * @property blurY\n * @type Number the strength of the blurY\n * @default 2\n */\nObject.defineProperty(PIXI.BlurFilter.prototype, 'blurY', {\n    get: function() {\n        return this.blurYFilter.blur;\n    },\n    set: function(value) {\n        this.blurYFilter.blur = value;\n    }\n});\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * This inverts your Display Objects colors.\n * \n * @class InvertFilter\n * @extends AbstractFilter\n * @constructor\n */\nPIXI.InvertFilter = function()\n{\n    PIXI.AbstractFilter.call( this );\n\n    this.passes = [this];\n\n    // set the uniforms\n    this.uniforms = {\n        invert: {type: '1f', value: 1}\n    };\n\n    this.fragmentSrc = [\n        'precision mediump float;',\n        'varying vec2 vTextureCoord;',\n        'varying vec4 vColor;',\n        'uniform float invert;',\n        'uniform sampler2D uSampler;',\n\n        'void main(void) {',\n        '   gl_FragColor = texture2D(uSampler, vTextureCoord);',\n        '   gl_FragColor.rgb = mix( (vec3(1)-gl_FragColor.rgb) * gl_FragColor.a, gl_FragColor.rgb, 1.0 - invert);',\n        //'   gl_FragColor.rgb = gl_FragColor.rgb  * gl_FragColor.a;',\n      //  '   gl_FragColor = gl_FragColor * vColor;',\n        '}'\n    ];\n};\n\nPIXI.InvertFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );\nPIXI.InvertFilter.prototype.constructor = PIXI.InvertFilter;\n\n/**\n * The strength of the invert. 1 will fully invert the colors, 0 will make the object its normal color\n * @property invert\n * @type Number\n*/\nObject.defineProperty(PIXI.InvertFilter.prototype, 'invert', {\n    get: function() {\n        return this.uniforms.invert.value;\n    },\n    set: function(value) {\n        this.uniforms.invert.value = value;\n    }\n});\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * This applies a sepia effect to your Display Objects.\n * \n * @class SepiaFilter\n * @extends AbstractFilter\n * @constructor\n */\nPIXI.SepiaFilter = function()\n{\n    PIXI.AbstractFilter.call( this );\n\n    this.passes = [this];\n\n    // set the uniforms\n    this.uniforms = {\n        sepia: {type: '1f', value: 1}\n    };\n\n    this.fragmentSrc = [\n        'precision mediump float;',\n        'varying vec2 vTextureCoord;',\n        'varying vec4 vColor;',\n        'uniform float sepia;',\n        'uniform sampler2D uSampler;',\n\n        'const mat3 sepiaMatrix = mat3(0.3588, 0.7044, 0.1368, 0.2990, 0.5870, 0.1140, 0.2392, 0.4696, 0.0912);',\n\n        'void main(void) {',\n        '   gl_FragColor = texture2D(uSampler, vTextureCoord);',\n        '   gl_FragColor.rgb = mix( gl_FragColor.rgb, gl_FragColor.rgb * sepiaMatrix, sepia);',\n       // '   gl_FragColor = gl_FragColor * vColor;',\n        '}'\n    ];\n};\n\nPIXI.SepiaFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );\nPIXI.SepiaFilter.prototype.constructor = PIXI.SepiaFilter;\n\n/**\n * The strength of the sepia. 1 will apply the full sepia effect, 0 will make the object its normal color.\n * @property sepia\n * @type Number\n*/\nObject.defineProperty(PIXI.SepiaFilter.prototype, 'sepia', {\n    get: function() {\n        return this.uniforms.sepia.value;\n    },\n    set: function(value) {\n        this.uniforms.sepia.value = value;\n    }\n});\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * This filter applies a twist effect making display objects appear twisted in the given direction.\n * \n * @class TwistFilter\n * @extends AbstractFilter\n * @constructor\n */\nPIXI.TwistFilter = function()\n{\n    PIXI.AbstractFilter.call( this );\n\n    this.passes = [this];\n\n    // set the uniforms\n    this.uniforms = {\n        radius: {type: '1f', value:0.5},\n        angle: {type: '1f', value:5},\n        offset: {type: '2f', value:{x:0.5, y:0.5}}\n    };\n\n    this.fragmentSrc = [\n        'precision mediump float;',\n        'varying vec2 vTextureCoord;',\n        'varying vec4 vColor;',\n        'uniform vec4 dimensions;',\n        'uniform sampler2D uSampler;',\n\n        'uniform float radius;',\n        'uniform float angle;',\n        'uniform vec2 offset;',\n\n        'void main(void) {',\n        '   vec2 coord = vTextureCoord - offset;',\n        '   float distance = length(coord);',\n\n        '   if (distance < radius) {',\n        '       float ratio = (radius - distance) / radius;',\n        '       float angleMod = ratio * ratio * angle;',\n        '       float s = sin(angleMod);',\n        '       float c = cos(angleMod);',\n        '       coord = vec2(coord.x * c - coord.y * s, coord.x * s + coord.y * c);',\n        '   }',\n\n        '   gl_FragColor = texture2D(uSampler, coord+offset);',\n        '}'\n    ];\n};\n\nPIXI.TwistFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );\nPIXI.TwistFilter.prototype.constructor = PIXI.TwistFilter;\n\n/**\n * This point describes the the offset of the twist.\n * \n * @property offset\n * @type Point\n */\nObject.defineProperty(PIXI.TwistFilter.prototype, 'offset', {\n    get: function() {\n        return this.uniforms.offset.value;\n    },\n    set: function(value) {\n        this.dirty = true;\n        this.uniforms.offset.value = value;\n    }\n});\n\n/**\n * This radius of the twist.\n * \n * @property radius\n * @type Number\n */\nObject.defineProperty(PIXI.TwistFilter.prototype, 'radius', {\n    get: function() {\n        return this.uniforms.radius.value;\n    },\n    set: function(value) {\n        this.dirty = true;\n        this.uniforms.radius.value = value;\n    }\n});\n\n/**\n * This angle of the twist.\n * \n * @property angle\n * @type Number\n */\nObject.defineProperty(PIXI.TwistFilter.prototype, 'angle', {\n    get: function() {\n        return this.uniforms.angle.value;\n    },\n    set: function(value) {\n        this.dirty = true;\n        this.uniforms.angle.value = value;\n    }\n});\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * This lowers the color depth of your image by the given amount, producing an image with a smaller palette.\n * \n * @class ColorStepFilter\n * @extends AbstractFilter\n * @constructor\n */\nPIXI.ColorStepFilter = function()\n{\n    PIXI.AbstractFilter.call( this );\n\n    this.passes = [this];\n\n    // set the uniforms\n    this.uniforms = {\n        step: {type: '1f', value: 5}\n    };\n\n    this.fragmentSrc = [\n        'precision mediump float;',\n        'varying vec2 vTextureCoord;',\n        'varying vec4 vColor;',\n        'uniform sampler2D uSampler;',\n        'uniform float step;',\n\n        'void main(void) {',\n        '   vec4 color = texture2D(uSampler, vTextureCoord);',\n        '   color = floor(color * step) / step;',\n        '   gl_FragColor = color;',\n        '}'\n    ];\n};\n\nPIXI.ColorStepFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );\nPIXI.ColorStepFilter.prototype.constructor = PIXI.ColorStepFilter;\n\n/**\n * The number of steps to reduce the palette by.\n *\n * @property step\n * @type Number\n */\nObject.defineProperty(PIXI.ColorStepFilter.prototype, 'step', {\n    get: function() {\n        return this.uniforms.step.value;\n    },\n    set: function(value) {\n        this.uniforms.step.value = value;\n    }\n});\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n * original filter: https://github.com/evanw/glfx.js/blob/master/src/filters/fun/dotscreen.js\n */\n\n/**\n * This filter applies a dotscreen effect making display objects appear to be made out of black and white halftone dots like an old printer.\n * \n * @class DotScreenFilter\n * @extends AbstractFilter\n * @constructor\n */\nPIXI.DotScreenFilter = function()\n{\n    PIXI.AbstractFilter.call( this );\n\n    this.passes = [this];\n\n    // set the uniforms\n    this.uniforms = {\n        scale: {type: '1f', value:1},\n        angle: {type: '1f', value:5},\n        dimensions:   {type: '4fv', value:[0,0,0,0]}\n    };\n\n    this.fragmentSrc = [\n        'precision mediump float;',\n        'varying vec2 vTextureCoord;',\n        'varying vec4 vColor;',\n        'uniform vec4 dimensions;',\n        'uniform sampler2D uSampler;',\n\n        'uniform float angle;',\n        'uniform float scale;',\n\n        'float pattern() {',\n        '   float s = sin(angle), c = cos(angle);',\n        '   vec2 tex = vTextureCoord * dimensions.xy;',\n        '   vec2 point = vec2(',\n        '       c * tex.x - s * tex.y,',\n        '       s * tex.x + c * tex.y',\n        '   ) * scale;',\n        '   return (sin(point.x) * sin(point.y)) * 4.0;',\n        '}',\n\n        'void main() {',\n        '   vec4 color = texture2D(uSampler, vTextureCoord);',\n        '   float average = (color.r + color.g + color.b) / 3.0;',\n        '   gl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);',\n        '}'\n    ];\n};\n\nPIXI.DotScreenFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );\nPIXI.DotScreenFilter.prototype.constructor = PIXI.DotScreenFilter;\n\n/**\n * The scale of the effect.\n * @property scale\n * @type Number\n */\nObject.defineProperty(PIXI.DotScreenFilter.prototype, 'scale', {\n    get: function() {\n        return this.uniforms.scale.value;\n    },\n    set: function(value) {\n        this.dirty = true;\n        this.uniforms.scale.value = value;\n    }\n});\n\n/**\n * The radius of the effect.\n * @property angle\n * @type Number\n */\nObject.defineProperty(PIXI.DotScreenFilter.prototype, 'angle', {\n    get: function() {\n        return this.uniforms.angle.value;\n    },\n    set: function(value) {\n        this.dirty = true;\n        this.uniforms.angle.value = value;\n    }\n});\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * A Cross Hatch effect filter.\n * \n * @class CrossHatchFilter\n * @extends AbstractFilter\n * @constructor\n */\nPIXI.CrossHatchFilter = function()\n{\n    PIXI.AbstractFilter.call( this );\n\n    this.passes = [this];\n\n    // set the uniforms\n    this.uniforms = {\n        blur: {type: '1f', value: 1 / 512}\n    };\n\n    this.fragmentSrc = [\n        'precision mediump float;',\n        'varying vec2 vTextureCoord;',\n        'varying vec4 vColor;',\n        'uniform float blur;',\n        'uniform sampler2D uSampler;',\n\n        'void main(void) {',\n        '    float lum = length(texture2D(uSampler, vTextureCoord.xy).rgb);',\n\n        '    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);',\n\n        '    if (lum < 1.00) {',\n        '        if (mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0) {',\n        '            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);',\n        '        }',\n        '    }',\n\n        '    if (lum < 0.75) {',\n        '        if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0) {',\n        '            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);',\n        '        }',\n        '    }',\n\n        '    if (lum < 0.50) {',\n        '        if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0) {',\n        '            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);',\n        '        }',\n        '    }',\n\n        '    if (lum < 0.3) {',\n        '        if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0) {',\n        '            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);',\n        '        }',\n        '    }',\n        '}'\n    ];\n};\n\nPIXI.CrossHatchFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );\nPIXI.CrossHatchFilter.prototype.constructor = PIXI.CrossHatchFilter;\n\n/**\n * Sets the strength of both the blur.\n *\n * @property blur\n * @type Number the strength of the blur\n * @default 2\n */\nObject.defineProperty(PIXI.CrossHatchFilter.prototype, 'blur', {\n    get: function() {\n        return this.uniforms.blur.value / (1/7000);\n    },\n    set: function(value) {\n        //this.padding = value;\n        this.uniforms.blur.value = (1/7000) * value;\n    }\n});\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * An RGB Split Filter.\n * \n * @class RGBSplitFilter\n * @extends AbstractFilter\n * @constructor\n */\nPIXI.RGBSplitFilter = function()\n{\n    PIXI.AbstractFilter.call( this );\n\n    this.passes = [this];\n\n    // set the uniforms\n    this.uniforms = {\n        red: {type: '2f', value: {x:20, y:20}},\n        green: {type: '2f', value: {x:-20, y:20}},\n        blue: {type: '2f', value: {x:20, y:-20}},\n        dimensions:   {type: '4fv', value:[0,0,0,0]}\n    };\n\n    this.fragmentSrc = [\n        'precision mediump float;',\n        'varying vec2 vTextureCoord;',\n        'varying vec4 vColor;',\n        'uniform vec2 red;',\n        'uniform vec2 green;',\n        'uniform vec2 blue;',\n        'uniform vec4 dimensions;',\n        'uniform sampler2D uSampler;',\n\n        'void main(void) {',\n        '   gl_FragColor.r = texture2D(uSampler, vTextureCoord + red/dimensions.xy).r;',\n        '   gl_FragColor.g = texture2D(uSampler, vTextureCoord + green/dimensions.xy).g;',\n        '   gl_FragColor.b = texture2D(uSampler, vTextureCoord + blue/dimensions.xy).b;',\n        '   gl_FragColor.a = texture2D(uSampler, vTextureCoord).a;',\n        '}'\n    ];\n};\n\nPIXI.RGBSplitFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );\nPIXI.RGBSplitFilter.prototype.constructor = PIXI.RGBSplitFilter;\n\n/**\n * Red channel offset.\n * \n * @property red\n * @type Point\n */\nObject.defineProperty(PIXI.RGBSplitFilter.prototype, 'red', {\n    get: function() {\n        return this.uniforms.red.value;\n    },\n    set: function(value) {\n        this.uniforms.red.value = value;\n    }\n});\n\n/**\n * Green channel offset.\n * \n * @property green\n * @type Point\n */\nObject.defineProperty(PIXI.RGBSplitFilter.prototype, 'green', {\n    get: function() {\n        return this.uniforms.green.value;\n    },\n    set: function(value) {\n        this.uniforms.green.value = value;\n    }\n});\n\n/**\n * Blue offset.\n * \n * @property blue\n * @type Point\n */\nObject.defineProperty(PIXI.RGBSplitFilter.prototype, 'blue', {\n    get: function() {\n        return this.uniforms.blue.value;\n    },\n    set: function(value) {\n        this.uniforms.blue.value = value;\n    }\n});\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n    if (typeof exports !== 'undefined') {\n        if (typeof module !== 'undefined' && module.exports) {\n            exports = module.exports = PIXI;\n        }\n        exports.PIXI = PIXI;\n    } else if (typeof define !== 'undefined' && define.amd) {\n        define(PIXI);\n    } else {\n        root.PIXI = PIXI;\n    }\n}).call(this);"
}, function(module) {
    module.exports = "/*\nCopyright (c) | 2013 | soma-events | Romuald Quantin | www.soundstep.com\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy,\nmodify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software\nis furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR\nIN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n(function (soma) {\n\n	'use strict';\n\n	soma.events = {};\n	soma.events.version = '0.5.6';\n\n    if (!Function.prototype.bind) {\n        Function.prototype.bind = function bind(that) {\n            var target = this;\n            if (typeof target !== 'function') {\n                throw new Error('Error, you must bind a function.');\n            }\n            var args = Array.prototype.slice.call(arguments, 1); // for normal call\n            var bound = function () {\n                if (this instanceof bound) {\n                    var F = function(){};\n                    F.prototype = target.prototype;\n                    var self = new F();\n                    var result = target.apply(\n                        self,\n                        args.concat(Array.prototype.slice.call(arguments))\n                    );\n                    if (Object(result) === result) {\n                        return result;\n                    }\n                    return self;\n                } else {\n                    return target.apply(\n                        that,\n                        args.concat(Array.prototype.slice.call(arguments))\n                    );\n                }\n            };\n            return bound;\n        };\n    }\n\n	soma.Event = function (type, params, bubbles, cancelable) {\n		var e = soma.Event.createGenericEvent(type, bubbles, cancelable);\n		if (params !== null && params !== undefined) {\n			e.params = params;\n		}\n		e.isCloned = false;\n		e.clone = this.clone.bind(e);\n		e.isIE9orIE10 = this.isIE9orIE10;\n		e.isDefaultPrevented = this.isDefaultPrevented;\n		if (this.isIE9orIE10() || !e.preventDefault || (e.getDefaultPrevented === undefined && e.defaultPrevented === undefined )) {\n			e.preventDefault = this.preventDefault.bind(e);\n		}\n		if (this.isIE9orIE10()) {\n			e.IE9or10PreventDefault = false;\n		}\n		return e;\n	};\n\n	soma.Event.prototype.clone = function () {\n		var e = soma.Event.createGenericEvent(this.type, this.bubbles, this.cancelable);\n		e.params = this.params;\n		e.isCloned = true;\n		e.clone = this.clone;\n		e.isDefaultPrevented = this.isDefaultPrevented;\n		e.isIE9orIE10 = this.isIE9orIE10;\n		if (this.isIE9orIE10()) {\n			e.IE9or10PreventDefault = this.IE9or10PreventDefault;\n		}\n		return e;\n	};\n\n	soma.Event.prototype.preventDefault = function () {\n		if (!this.cancelable) {\n			return false;\n		}\n		if (this.isIE9orIE10()) {\n			this.IE9or10PreventDefault = true;\n		}\n		else {\n			this.defaultPrevented = true;\n		}\n		return this;\n	};\n\n	soma.Event.prototype.isDefaultPrevented = function () {\n		if (!this.cancelable) {\n			return false;\n		}\n		if (this.isIE9orIE10()) {\n			return this.IE9or10PreventDefault;\n		}\n		if (this.defaultPrevented !== undefined) {\n			return this.defaultPrevented;\n		} else if (this.getDefaultPrevented !== undefined) {\n			return this.getDefaultPrevented();\n		}\n		return false;\n	};\n\n	soma.Event.createGenericEvent = function (type, bubbles, cancelable) {\n		var event;\n		bubbles = bubbles !== undefined ? bubbles : true;\n		if (typeof document === 'object' && document.createEvent) {\n			event = document.createEvent('Event');\n			event.initEvent(type, !!bubbles, !!cancelable);\n		} else if (typeof document === 'object' && document.createEventObject) {\n			event = document.createEventObject();\n			event.type = type;\n			event.bubbles = !!bubbles;\n			event.cancelable = !!cancelable;\n		} else {\n			event = new EventObject(type, !!bubbles, !!cancelable);\n		}\n		return event;\n	};\n\n	soma.Event.prototype.isIE9orIE10 = function() {\n        if (typeof document !== 'object') {\n			return false;\n        }\n		return (document.body.style.scrollbar3dLightColor !== undefined && document.body.style.opacity !== undefined) || document.body.style.msTouchAction !== undefined;\n    };\n\n	soma.Event.prototype.toString = function() {\n		return '[soma.Event]';\n	};\n\n	var EventObject = function(type, bubbles, cancelable) {\n		this.type = type;\n		this.bubbles = !!bubbles;\n		this.cancelable = !!cancelable;\n		this.defaultPrevented = false;\n		this.currentTarget = null;\n		this.target = null;\n	};\n\n	soma.EventDispatcher = function () {\n		this.listeners = [];\n	};\n\n	soma.EventDispatcher.prototype.addEventListener = function(type, listener, priority) {\n		if (!this.listeners || !type || !listener) {\n			return;\n		}\n		if (isNaN(priority)) {\n			priority = 0;\n		}\n		for (var i=0; i<this.listeners.length; i++) {\n			var eventObj = this.listeners[i];\n			if (eventObj.type === type && eventObj.listener === listener) {\n				return;\n			}\n		}\n		this.listeners.push({type: type, listener: listener, priority: priority, scope:this});\n	};\n\n	soma.EventDispatcher.prototype.removeEventListener = function(type, listener) {\n		if (!this.listeners || !type || !listener) {\n			return;\n		}\n		var i = this.listeners.length;\n		while(i-- > 0) {\n			var eventObj = this.listeners[i];\n			if (eventObj.type === type && eventObj.listener === listener) {\n				this.listeners.splice(i, 1);\n			}\n		}\n	};\n\n	soma.EventDispatcher.prototype.hasEventListener = function(type) {\n		if (!this.listeners || !type) {\n			return false;\n		}\n		var i = 0;\n		var l = this.listeners.length;\n		for (; i < l; ++i) {\n			var eventObj = this.listeners[i];\n			if (eventObj.type === type) {\n				return true;\n			}\n		}\n		return false;\n	};\n\n	soma.EventDispatcher.prototype.dispatchEvent = function(event) {\n		if (!this.listeners || !event) {\n			throw new Error('Error in EventDispatcher (dispatchEvent), one of the parameters is null or undefined.');\n		}\n		var events = [];\n		var i;\n		for (i = 0; i < this.listeners.length; i++) {\n			var eventObj = this.listeners[i];\n			if (eventObj.type === event.type) {\n				events.push(eventObj);\n			}\n		}\n		events.sort(function(a, b) {\n			return b.priority - a.priority;\n		});\n		for (i = 0; i < events.length; i++) {\n			events[i].listener.apply((event.srcElement) ? event.srcElement : event.currentTarget, [event]);\n		}\n		return !event.isDefaultPrevented();\n	};\n\n	soma.EventDispatcher.prototype.dispatch = function(type, params, bubbles, cancelable) {\n		if (!this.listeners || !type || type === '') {\n			throw new Error('Error in EventDispatcher (dispatch), one of the parameters is null or undefined.');\n		}\n		var event = new soma.Event(type, params, bubbles, cancelable);\n		this.dispatchEvent(event);\n		return event;\n	};\n\n	soma.EventDispatcher.prototype.dispose = function() {\n		this.listeners = null;\n	};\n\n	soma.EventDispatcher.prototype.toString = function() {\n		return '[soma.EventDispatcher]';\n	};\n\n	// register for AMD module\n	if (typeof define === 'function' && typeof define.amd !== 'undefined') {\n		define(\"soma-events\", soma);\n	}\n\n	// export for node.js\n	if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n		module.exports = soma;\n	}\n	if (typeof exports !== 'undefined') {\n		exports = soma;\n	}\n\n})(this['soma'] = this['soma'] || {});\n\n"
}, function(module) {
    module.exports = "(function (soma) {\n\n	'use strict';\n\n	soma.template = soma.template || {};\n	soma.template.version = '0.2.8';\n\n	soma.template.errors = {\n		TEMPLATE_STRING_NO_ELEMENT: 'Error in soma.template, a string template requirement a second parameter: an element target - soma.template.create(\\'string\\', element)',\n		TEMPLATE_NO_PARAM: 'Error in soma.template, a template requires at least 1 parameter - soma.template.create(element)'\n	};\n\n	var tokenStart = '{{';\n	var tokenEnd = '}}';\n	var helpersObject = {};\n	var helpersScopeObject = {};\n\n	var settings = soma.template.settings = soma.template.settings || {};\n\n	settings.autocreate = true;\n\n	var tokens = settings.tokens = {\n		start: function(value) {\n			if (isDefined(value) && value !== '') {\n				tokenStart = escapeRegExp(value);\n				setRegEX(value, true);\n			}\n			return tokenStart;\n		},\n		end: function(value) {\n			if (isDefined(value) && value !== '') {\n				tokenEnd = escapeRegExp(value);\n				setRegEX(value, false);\n			}\n			return tokenEnd;\n		}\n	};\n\n	var attributes = settings.attributes = {\n		skip: 'data-skip',\n		repeat: 'data-repeat',\n		src: 'data-src',\n		href: 'data-href',\n		show: 'data-show',\n		hide: 'data-hide',\n		cloak: 'data-cloak',\n		checked: 'data-checked',\n		disabled: 'data-disabled',\n		multiple: 'data-multiple',\n		readonly: 'data-readonly',\n		selected: 'data-selected',\n		template: 'data-template',\n		html: 'data-html'\n	};\n\n	var vars = settings.vars = {\n		index: '$index',\n		key: '$key',\n		element: '$element',\n		parentElement: '$parentElement',\n		attribute: '$attribute',\n		scope: '$scope'\n	};\n\n	var events = settings.events = {};\n	settings.eventsPrefix = 'data-';\n	var eventsString = 'click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup focus blur change select selectstart scroll copy cut paste mousewheel keypress error contextmenu input textinput drag dragenter dragleave dragover dragend dragstart dragover drop load submit reset search resize beforepaste beforecut beforecopy';\n	eventsString += ' touchstart touchend touchmove touchenter touchleave touchcancel gesturestart gesturechange gestureend';\n	var eventsArray = eventsString.split(' ');\n	var i = -1, l = eventsArray.length;\n	while(++i < l) {\n		events[settings.eventsPrefix + eventsArray[i]] = eventsArray[i];\n	}\n\n	var regex = {\n		sequence: null,\n		token: null,\n		expression: null,\n		escape: /[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g,\n		trim: /^[\\s+]+|[\\s+]+$/g,\n		repeat: /(.*)\\s+in\\s+(.*)/,\n		func: /(.*)\\((.*)\\)/,\n		params: /,\\s+|,|\\s+,\\s+/,\n		quote: /\\\"|\\'/g,\n		content: /[^.|^\\s]/gm,\n		depth: /..\\//g,\n		string: /^(\\\"|\\')(.*)(\\\"|\\')$/\n	};\n\n	var ie = (function(){\n		if (typeof document !== 'object') {\n			return undefined;\n		}\n		var v = 3,\n			stop = false,\n			div = document.createElement('div');\n		while (!stop) {\n			div.innerHTML = '<!--[if gt IE ' + (++v) + ']><i></i><![endif]-->';\n			if (!div.getElementsByTagName('i')[0]) {\n				stop = true;\n			}\n		}\n		return v > 4 ? v : undefined;\n	}());\n	function isArray(value) {\n		return Object.prototype.toString.apply(value) === '[object Array]';\n	}\n	function isObject(value) {\n		return typeof value === 'object';\n	}\n	function isString(value) {\n		return typeof value === 'string';\n	}\n	function isElement(value) {\n		return value ? value.nodeType > 0 : false;\n	}\n	function isTextNode(el) {\n		return el && el.nodeType && el.nodeType === 3;\n	}\n	function isFunction(value) {\n		return value && typeof value === 'function';\n	}\n	function isDefined(value) {\n		return value !== null && value !== undefined;\n	}\n	function normalizeBoolean(value) {\n		if (!isDefined(value)) {\n			return false;\n		}\n		if (value === 'true' || value === '1' || value === true || value === 1) {\n			return true;\n		}\n		if (value === 'false' || value === '0' || value === false || value === 0 || (isString(value) && hasInterpolation(value))) {\n			return false;\n		}\n		return !!value;\n	}\n	function isExpression(value) {\n		return value && isFunction(value.toString) && value.toString() === '[object Expression]';\n	}\n	function isExpFunction(value) {\n		if (!isString(value)) {\n			return false;\n		}\n		return !!value.match(regex.func);\n	}\n	function childNodeIsTemplate(node) {\n		return node && node.parent && templates.get(node.element);\n	}\n	function escapeRegExp(str) {\n		return str.replace(regex.escape, '\\\\$&');\n	}\n	function setRegEX(nonEscapedValue, isStartToken) {\n		// sequence: \\{\\{.+?\\}\\}|[^{]+|\\{(?!\\{)[^{]*\n		var unescapedCurrentStartToken = tokens.start().replace(/\\\\/g, '');\n		var endSequence = '';\n		var ts = isStartToken ? nonEscapedValue : unescapedCurrentStartToken;\n		if (ts.length > 1) {\n			endSequence = '|\\\\' + ts.substr(0, 1) + '(?!\\\\' + ts.substr(1, 1) + ')[^' + ts.substr(0, 1) + ']*';\n		}\n		regex.sequence = new RegExp(tokens.start() + '.+?' + tokens.end() + '|[^' + tokens.start() + ']+' + endSequence, 'g');\n		regex.token = new RegExp(tokens.start() + '.*?' + tokens.end(), 'g');\n		regex.expression = new RegExp(tokens.start() + '|' + tokens.end(), 'gm');\n	}\n	function trim(value) {\n		return value.replace(regex.trim, '');\n	}\n	function trimQuotes(value) {\n		if (regex.string.test(value)) {\n			return value.substr(1, value.length-2);\n		}\n		return value;\n	}\n	function trimArray(value) {\n		if (value[0] === '') {\n			value.shift();\n		}\n		if (value[value.length-1] === '') {\n			value.pop();\n		}\n		return value;\n	}\n	function trimTokens(value) {\n		return value.replace(regex.expression, '');\n	}\n	function trimScopeDepth(value) {\n		return value.replace(regex.depth, '');\n	}\n	function insertBefore(referenceNode, newNode) {\n		if (!referenceNode.parentNode) {\n			return;\n		}\n		referenceNode.parentNode.insertBefore(newNode, referenceNode);\n	}\n	function insertAfter(referenceNode, newNode) {\n		if (!referenceNode.parentNode) {\n			return;\n		}\n		referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);\n	}\n	function removeClass(elm, className) {\n		var rmc;\n		if (typeof document === 'object' && document.documentElement.classList) {\n			rmc = function (elm, className) {\n				elm.classList.remove(className);\n			};\n		} else {\n			rmc = function (elm, className) {\n				if (!elm || !elm.className) {\n					return false;\n				}\n				var reg = new RegExp('(^|\\\\s)' + className + '(\\\\s|$)', 'g');\n				elm.className = elm.className.replace(reg, '$2');\n			};\n		}\n		rmc(elm, className);\n	}\n	// jquery contains\n	var contains = typeof document !== 'object' ? function(){} : document.documentElement.contains ?\n		function( a, b ) {\n			var adown = a.nodeType === 9 ? a.documentElement : a,\n				bup = b && b.parentNode;\n			return a === bup || !!( bup && bup.nodeType === 1 && adown.contains && adown.contains(bup) );\n		} :\n		document.documentElement.compareDocumentPosition ?\n			function( a, b ) {\n				return b && !!( a.compareDocumentPosition( b ) & 16 );\n			} :\n			function( a, b ) {\n				while ( (b = b.parentNode) ) {\n					if ( b === a ) {\n						return true;\n					}\n				}\n				return false;\n			};\n\n	function HashMap(id) {\n		var items = {};\n		var count = 0;\n		//var uuid = function(a,b){for(b=a='';a++<36;b+=a*51&52?(a^15?8^Math.random()*(a^20?16:4):4).toString(16):'-');return b;}\n		function uuid() { return ++count + id; }\n		function getKey(target) {\n			if (!target) {\n				return;\n			}\n			if (typeof target !== 'object') {\n				return target;\n			}\n			var result;\n			try {\n				// IE 7-8 needs a try catch, seems like I can't add a property on text nodes\n				result = target[id] ? target[id] : target[id] = uuid();\n			} catch(err){}\n			return result;\n		}\n		this.remove = function(key) {\n			delete items[getKey(key)];\n		};\n		this.get = function(key) {\n			return items[getKey(key)];\n		};\n		this.put = function(key, value) {\n			items[getKey(key)] = value;\n		};\n		this.has = function(key) {\n			return typeof items[getKey(key)] !== 'undefined';\n		};\n		this.getData = function() {\n			return items;\n		};\n		this.dispose = function() {\n			for (var key in items) {\n				if (items.hasOwnProperty(key)) {\n					delete items[key];\n				}\n			}\n			this.length = 0;\n		};\n	}\n\n	function getRepeaterData(repeaterValue, scope) {\n		var parts = repeaterValue.match(regex.repeat);\n		if (!parts) {\n			return;\n		}\n		var source = parts[2];\n		var exp = new Expression(source);\n		return exp.getValue(scope);\n	}\n\n	function updateScopeWithRepeaterData(repeaterValue, scope, data) {\n		var parts = repeaterValue.match(regex.repeat);\n		if (!parts) {\n			return;\n		}\n		var name = parts[1];\n		scope[name] = data;\n	}\n	function getWatcherValue(exp, newValue) {\n		var node = exp.node || exp.attribute.node;\n		var watchers = node.template.watchers;\n		var nodeTarget = node.element;\n		if (!watchers) {\n			return newValue;\n		}\n		var watcherNode = watchers.get(nodeTarget);\n		if (!watcherNode && isTextNode(node.element) && node.parent) {\n			watcherNode = watchers.get(node.parent.element);\n		}\n		var watcher = watcherNode ? watcherNode : watchers.get(exp.pattern);\n		if (isFunction(watcher)) {\n			var watcherValue = watcher(exp.value, newValue, exp.pattern, node.scope, node, exp.attribute);\n			if (isDefined(watcherValue)) {\n				return watcherValue;\n			}\n		}\n		return newValue;\n	}\n\n	function getScopeFromPattern(scope, pattern) {\n		var depth = getScopeDepth(pattern);\n		var scopeTarget = scope;\n		while (depth > 0) {\n			scopeTarget = scopeTarget._parent ? scopeTarget._parent : scopeTarget;\n			depth--;\n		}\n		return scopeTarget;\n	}\n\n	function getValueFromPattern(scope, pattern, context) {\n		var exp = new Expression(pattern);\n		return getValue(scope, exp.pattern, exp.path, exp.params, undefined, undefined, undefined, context);\n	}\n\n	function getValue(scope, pattern, pathString, params, getFunction, getParams, paramsFound, context) {\n		// context\n		if (pattern === vars.element) {\n			return context[vars.element];\n		}\n		if (pattern === vars.parentElement) {\n			return context[vars.parentElement];\n		}\n		if (pattern === vars.attribute) {\n			return context[vars.attribute];\n		}\n		if (pattern === vars.scope) {\n			return context[vars.scope];\n		}\n		// string\n		if (regex.string.test(pattern)) {\n			return trimQuotes(pattern);\n		}\n		else if(!isNaN(pattern)) {\n			return +pattern;\n		}\n		// find params\n		var paramsValues = [];\n		if (!paramsFound && params) {\n			for (var j = 0, jl = params.length; j < jl; j++) {\n				paramsValues.push(getValueFromPattern(scope, params[j], context));\n			}\n		}\n		else {\n			paramsValues = paramsFound;\n		}\n		if (getParams) {\n			return paramsValues;\n		}\n		// find scope\n		var scopeTarget = getScopeFromPattern(scope, pattern);\n		// remove parent string\n		pattern = pattern.replace(/..\\//g, '');\n		pathString = pathString.replace(/..\\//g, '');\n		if (!scopeTarget) {\n			return undefined;\n		}\n		// search path\n		var path = scopeTarget;\n		var pathParts = pathString.split(/\\.|\\[|\\]/g);\n		if (pathParts.length > 0) {\n			for (var i = 0, l = pathParts.length; i < l; i++) {\n				if (pathParts[i] !== '') {\n					path = path[pathParts[i]];\n				}\n				if (!isDefined(path)) {\n					// no path, search in parent\n					if (scopeTarget._parent) {\n						return getValue(scopeTarget._parent, pattern, pathString, params, getFunction, getParams, paramsValues);\n					}\n					else {\n						return undefined;\n					}\n				}\n			}\n		}\n		// return value\n		if (!isFunction(path)) {\n			return path;\n		}\n		else {\n			if (getFunction) {\n				return path;\n			}\n			else {\n				return path.apply(null, paramsValues);\n			}\n		}\n		return undefined;\n	}\n\n	function getExpressionPath(value) {\n		var val = value.split('(')[0];\n		val = trimScopeDepth(val);\n		return val;\n	}\n\n	function getParamsFromString(value) {\n		return trimArray(value.split(regex.params));\n	}\n\n	function getScopeDepth(value) {\n		var val = value.split('(')[0];\n		var matches = val.match(regex.depth);\n		return !matches ? 0 : matches.length;\n	}\n\n	function addAttribute(node, name, value) {\n		var attr;\n		node.attributes = node.attributes || [];\n		if (name === settings.attributes.skip) {\n			node.skip = normalizeBoolean(value);\n		}\n		if (name === settings.attributes.html) {\n			node.html = normalizeBoolean(value);\n		}\n		if (name === settings.attributes.repeat && !node.isRepeaterDescendant) {\n			node.repeater = value;\n		}\n		if (\n			hasInterpolation(name + ':' + value) ||\n				name === settings.attributes.repeat ||\n				name === settings.attributes.skip ||\n				name === settings.attributes.html ||\n				name === settings.attributes.show ||\n				name === settings.attributes.hide ||\n				name === settings.attributes.href ||\n				name === settings.attributes.checked ||\n				name === settings.attributes.disabled ||\n				name === settings.attributes.multiple ||\n				name === settings.attributes.readonly ||\n				name === settings.attributes.selected ||\n				value.indexOf(settings.attributes.cloak) !== -1\n			) {\n			attr = new Attribute(name, value, node);\n			node.attributes.push(attr);\n		}\n		if (events[name]) {\n			attr = new Attribute(name, value, node);\n			node.attributes.push(attr);\n		}\n		return attr;\n	}\n\n	function getNodeFromElement(element, scope) {\n		var node = new Node(element, scope);\n		node.previousSibling = element.previousSibling;\n		node.nextSibling = element.nextSibling;\n		var eventsArray = [];\n		for (var attr, attrs = element.attributes, j = 0, jj = attrs && attrs.length; j < jj; j++) {\n			attr = attrs[j];\n			if (attr.specified || attr.name === 'value') {\n				var newAttr = addAttribute(node, attr.name, attr.value);\n				if (events[attr.name]) {\n					if (events[attr.name] && !node.isRepeaterChild) {\n						eventsArray.push({name:events[attr.name], value:attr.value, attr: newAttr});\n					}\n				}\n			}\n		}\n		for (var a=0, b=eventsArray.length; a<b; a++) {\n			node.addEvent(eventsArray[a].name, eventsArray[a].value, eventsArray[a].attr);\n		}\n		return node;\n	}\n\n	function hasInterpolation(value) {\n		var matches = value.match(regex.token);\n		return matches && matches.length > 0;\n	}\n\n	function hasContent(value) {\n		return regex.content.test(value);\n	}\n\n	function isElementValid(element) {\n		if (!element) {\n			return;\n		}\n		var type = element.nodeType;\n		if (!element || !type) {\n			return false;\n		}\n		// comment\n		if (type === 8) {\n			return false;\n		}\n		// empty text node\n		if (type === 3 && !hasContent(element.nodeValue) && !hasInterpolation(element.nodeValue)) {\n			return false;\n		}\n		// result\n		return true;\n	}\n\n	function compile(template, element, parent, nodeTarget) {\n		if (!isElementValid(element)) {\n			return;\n		}\n		// get node\n		var node;\n		if (!nodeTarget) {\n			node = getNodeFromElement(element, parent ? parent.scope : new Scope(helpersScopeObject)._createChild());\n		}\n		else {\n			node = nodeTarget;\n			node.parent = parent;\n		}\n		if (parent && (parent.repeater || parent.isRepeaterChild)) {\n			node.isRepeaterChild = true;\n		}\n		node.template = template;\n		// children\n		if (node.skip) {\n			return;\n		}\n		var child = element.firstChild;\n		while (child) {\n			var childNode = compile(template, child, node);\n			if (childNode) {\n				childNode.parent = node;\n				node.children.push(childNode);\n			}\n			child = child.nextSibling;\n		}\n		return node;\n	}\n\n	function updateScopeWithData(scope, data) {\n		clearScope(scope);\n		for (var d in data) {\n			if (data.hasOwnProperty(d)) {\n				scope[d] = data[d];\n			}\n		}\n	}\n\n	function clearScope(scope) {\n		for (var key in scope) {\n			if (scope.hasOwnProperty(key)) {\n				if (key.substr(0, 1) !== '_') {\n					scope[key] = null;\n					delete scope[key];\n				}\n			}\n		}\n	}\n\n	function updateNodeChildren(node) {\n		if (node.repeater || !node.children || childNodeIsTemplate(node)) {\n			return;\n		}\n		for (var i = 0, l = node.children.length; i < l; i++) {\n			node.children[i].update();\n		}\n	}\n\n	function renderNodeChildren(node) {\n		if (!node.children || childNodeIsTemplate(node)) {\n			return;\n		}\n		for (var i = 0, l = node.children.length; i < l; i++) {\n			node.children[i].render();\n		}\n	}\n\n	function renderNodeRepeater(node) {\n		var data = getRepeaterData(node.repeater, node.scope);\n		var previousElement;\n		if (isArray(data)) {\n			// process array\n			for (var i = 0, l1 = data.length, l2 = node.childrenRepeater.length, l = l1 > l2 ? l1 : l2; i < l; i++) {\n				if (i < l1) {\n					previousElement = createRepeaterChild(node, i, data[i], vars.index, i, previousElement);\n				}\n				else {\n					node.parent.element.removeChild(node.childrenRepeater[i].element);\n					node.childrenRepeater[i].dispose();\n				}\n			}\n			if (node.childrenRepeater.length > data.length) {\n				node.childrenRepeater.length = data.length;\n			}\n		}\n		else {\n			// process object\n			var count = -1;\n			for (var o in data) {\n				if (data.hasOwnProperty(o)) {\n					count++;\n					previousElement = createRepeaterChild(node, count, data[o], vars.key, o, previousElement);\n				}\n			}\n			var size = count;\n			while (count++ < node.childrenRepeater.length-1) {\n				node.parent.element.removeChild(node.childrenRepeater[count].element);\n				node.childrenRepeater[count].dispose();\n			}\n			node.childrenRepeater.length = size+1;\n		}\n		if (node.element.parentNode) {\n			node.element.parentNode.removeChild(node.element);\n		}\n	}\n\n	function compileClone(node, newNode) {\n		if (!isElementValid(newNode.element)) {\n			return;\n		}\n		// create attribute\n		if (node.attributes) {\n			for (var i= 0, l=node.attributes.length; i<l; i++) {\n				var attr = node.attributes[i];\n				var newAttr = addAttribute(newNode, attr.name, attr.value);\n				if (events[attr.name]) {\n					newNode.addEvent(events[attr.name], attr.value, newAttr);\n				}\n			}\n		}\n		// children\n		var child = node.element.firstChild;\n		var newChild = newNode.element.firstChild;\n		// loop\n		while (child && newChild) {\n			var childNode = node.getNode(child);\n			var newChildNode = new Node(newChild, newNode.scope);\n			newNode.children.push(newChildNode);\n			newChildNode.parent = newNode;\n			newChildNode.template = newNode.template;\n			newChildNode.isRepeaterChild = true;\n			var compiledNode = compileClone(childNode, newChildNode);\n			if (compiledNode) {\n				compiledNode.parent = newChildNode;\n				compiledNode.template = newChildNode.template;\n				newChildNode.children.push(compiledNode);\n			}\n			child = child.nextSibling;\n			newChild = newChild.nextSibling;\n		}\n		return newChildNode;\n	}\n\n	function cloneRepeaterNode(element, node) {\n		var newNode = new Node(element, node.scope._createChild());\n		newNode.template = node.template;\n		newNode.parent = node;\n		newNode.isRepeaterChild = true;\n		newNode.isRepeaterDescendant = true;\n		compileClone(node, newNode);\n		return newNode;\n	}\n\n	function appendRepeaterElement(previousElement, node, newElement) {\n		if (!previousElement) {\n			if (node.element.previousSibling) {\n				insertAfter(node.element.previousSibling, newElement);\n			}\n			else if (node.element.nextSibling) {\n				insertBefore(node.element.nextSibling, newElement);\n			}\n			else {\n				node.parent.element.appendChild(newElement);\n			}\n		}\n		else {\n			insertAfter(previousElement, newElement);\n		}\n	}\n\n	function createRepeaterChild(node, count, data, indexVar, indexVarValue, previousElement) {\n		var existingChild = node.childrenRepeater[count];\n		if (!existingChild) {\n			var newElement = node.element.cloneNode(true);\n			// need to append the cloned element to the DOM\n			// before changing attributes or IE will crash\n			appendRepeaterElement(previousElement, node, newElement);\n			// can't recreate the node with a cloned element on IE7\n			// be cause the attributes are not specified anymore (attribute.specified)\n			//var newNode = getNodeFromElement(newElement, node.scope._createChild(), true);\n			var newNode = cloneRepeaterNode(newElement, node);\n			node.childrenRepeater[count] = newNode;\n			updateScopeWithRepeaterData(node.repeater, newNode.scope, data);\n			newNode.scope[indexVar] = indexVarValue;\n			newNode.update();\n			newNode.render();\n			return newElement;\n		}\n		else {\n			// existing node\n			updateScopeWithRepeaterData(node.repeater, existingChild.scope, data);\n			existingChild.scope[indexVar] = indexVarValue;\n			existingChild.update();\n			existingChild.render();\n			return existingChild.element;\n		}\n	}\n\n	var Scope = function(data) {\n		var self;\n		function createChild(data) {\n			var obj = createObject(data);\n			obj._parent = self;\n			self._children.push(obj);\n			return obj;\n		}\n		function createObject(data) {\n			var obj = data || {};\n			obj._parent = null;\n			obj._children = [];\n			obj._createChild = function() {\n				self = obj;\n				return createChild.apply(obj, arguments);\n			};\n			return obj;\n		}\n		return createObject(data);\n	};\n	var Node = function(element, scope) {\n		this.element = element;\n		this.scope = scope;\n		this.attributes = null;\n		this.value = null;\n		this.interpolation = null;\n		this.invalidate = false;\n		this.skip = false;\n		this.repeater = null;\n		this.isRepeaterDescendant = false;\n		this.isRepeaterChild = false;\n		this.parent = null;\n		this.children = [];\n		this.childrenRepeater = [];\n		this.previousSibling = null;\n		this.nextSibling = null;\n		this.template = null;\n		this.eventHandlers = {};\n		this.html = false;\n\n		if (isTextNode(this.element)) {\n			this.value = this.element.nodeValue;\n			this.interpolation = new Interpolation(this.value, this, undefined);\n		}\n\n	};\n	Node.prototype = {\n		toString: function() {\n			return '[object Node]';\n		},\n		dispose: function() {\n			this.clearEvents();\n			var i, l;\n			if (this.children) {\n				for (i = 0, l = this.children.length; i < l; i++) {\n					this.children[i].dispose();\n				}\n			}\n			if (this.childrenRepeater) {\n				for (i = 0, l = this.childrenRepeater.length; i < l; i++) {\n					this.childrenRepeater[i].dispose();\n				}\n			}\n			if (this.attributes) {\n				for (i = 0, l = this.attributes.length; i < l; i++) {\n					this.attributes[i].dispose();\n				}\n			}\n			if (this.interpolation) {\n				this.interpolation.dispose();\n			}\n			this.element = null;\n			this.scope = null;\n			this.attributes = null;\n			this.value = null;\n			this.interpolation = null;\n			this.repeater = null;\n			this.parent = null;\n			this.children = null;\n			this.childrenRepeater = null;\n			this.previousSibling = null;\n			this.nextSibling = null;\n			this.template = null;\n			this.eventHandlers = null;\n		},\n		getNode: function(element) {\n			var node;\n			if (element === this.element) {\n				return this;\n			}\n			if (this.childrenRepeater.length > 0) {\n				for (var k = 0, kl = this.childrenRepeater.length; k < kl; k++) {\n					node = this.childrenRepeater[k].getNode(element);\n					if (node) {\n						return node;\n					}\n				}\n			}\n			for (var i = 0, l = this.children.length; i < l; i++) {\n				node = this.children[i].getNode(element);\n				if (node) {\n					return node;\n				}\n			}\n			return null;\n		},\n		getAttribute: function(name) {\n			if (this.attributes) {\n				for (var i = 0, l = this.attributes.length; i < l; i++) {\n					var att = this.attributes[i];\n					if (att.interpolationName && att.interpolationName.value === name) {\n						return att;\n					}\n				}\n			}\n		},\n		update: function() {\n			if (childNodeIsTemplate(this)) {\n				return;\n			}\n			if (isDefined(this.interpolation)) {\n				this.interpolation.update();\n			}\n			if (isDefined(this.attributes)) {\n				for (var i = 0, l = this.attributes.length; i < l; i++) {\n					this.attributes[i].update();\n				}\n			}\n			updateNodeChildren(this);\n		},\n		invalidateData: function() {\n			if (childNodeIsTemplate(this)) {\n				return;\n			}\n			this.invalidate = true;\n			var i, l;\n			if (this.attributes) {\n				for (i = 0, l = this.attributes.length; i < l; i++) {\n					this.attributes[i].invalidate = true;\n				}\n			}\n			for (i = 0, l = this.childrenRepeater.length; i < l; i++) {\n				this.childrenRepeater[i].invalidateData();\n			}\n			for (i = 0, l = this.children.length; i < l; i++) {\n				this.children[i].invalidateData();\n			}\n		},\n		addEvent: function(type, pattern, attr) {\n			if (this.repeater) {\n				return;\n			}\n			if (this.eventHandlers[type]) {\n				this.removeEvent(type);\n			}\n			var scope = this.scope;\n			var node = this;\n			var handler = function(event) {\n				var exp = new Expression(pattern, node, attr);\n				var func = exp.getValue(scope, true);\n				var params = exp.getValue(scope, false, true);\n				params.unshift(event);\n				if (func) {\n					func.apply(null, params);\n				}\n			};\n			this.eventHandlers[type] = handler;\n			addEvent(this.element, type, handler);\n		},\n		removeEvent: function(type) {\n			removeEvent(this.element, type, this.eventHandlers[type]);\n			this.eventHandlers[type] = null;\n			delete this.eventHandlers[type];\n		},\n		clearEvents: function() {\n			if (this.eventHandlers) {\n				for (var key in this.eventHandlers) {\n					if (this.eventHandlers.hasOwnProperty(key)) {\n						this.removeEvent(key);\n					}\n				}\n			}\n			if (this.children) {\n				for (var k = 0, kl = this.children.length; k < kl; k++) {\n					this.children[k].clearEvents();\n				}\n			}\n			if (this.childrenRepeater) {\n				for (var f = 0, fl = this.childrenRepeater.length; f < fl; f++) {\n					this.childrenRepeater[f].clearEvents();\n				}\n			}\n		},\n		render: function() {\n			if (childNodeIsTemplate(this)) {\n				return;\n			}\n			if (this.invalidate) {\n				this.invalidate = false;\n				if (isTextNode(this.element)) {\n					if (this.parent && this.parent.html) {\n						this.value = this.parent.element.innerHTML = this.interpolation.render();\n					}\n					else {\n						this.value = this.element.nodeValue = this.interpolation.render();\n					}\n				}\n			}\n			if (this.attributes) {\n				for (var i = 0, l = this.attributes.length; i < l; i++) {\n					this.attributes[i].render();\n				}\n			}\n			if (this.repeater) {\n				renderNodeRepeater(this);\n			}\n			else {\n				renderNodeChildren(this);\n			}\n		}\n	};\n	var Attribute = function(name, value, node) {\n		this.name = name;\n		this.value = value;\n		this.node = node;\n		this.interpolationName = new Interpolation(this.name, null, this);\n		this.interpolationValue = new Interpolation(this.value, null, this);\n		this.invalidate = false;\n	};\n	Attribute.prototype = {\n		toString: function() {\n			return '[object Attribute]';\n		},\n		dispose: function() {\n			if (this.interpolationName) {\n				this.interpolationName.dispose();\n			}\n			if (this.interpolationValue) {\n				this.interpolationValue.dispose();\n			}\n			this.interpolationName = null;\n			this.interpolationValue = null;\n			this.node = null;\n			this.name = null;\n			this.value = null;\n			this.previousName = null;\n		},\n		update: function() {\n			if (this.node.repeater) {\n				return;\n			}\n			this.interpolationName.update();\n			this.interpolationValue.update();\n		},\n		render: function() {\n			if (this.node.repeater) {\n				return;\n			}\n			// normal attribute\n			function renderAttribute(name, value, node) {\n				if (name === 'value' && node.element['value'] !== undefined) {\n					element.value = value;\n				}\n				else if (ie === 7 && name === 'class') {\n					element.className = value;\n				}\n				else {\n					element.setAttribute(name, value);\n				}\n			}\n			// boolean attribute\n			function renderBooleanAttribute(name, value) {\n				element.setAttribute(name, value);\n			}\n			// special attribute\n			function renderSpecialAttribute(value, attrName) {\n				if (normalizeBoolean(value)) {\n					element.setAttribute(attrName, attrName);\n				}\n				else {\n					element.removeAttribute(attrName);\n				}\n			}\n			// src attribute\n			function renderSrc(value) {\n				element.setAttribute('src', value);\n			}\n			// href attribute\n			function renderHref(value) {\n				element.setAttribute('href', value);\n			}\n			var element = this.node.element;\n			if (this.invalidate) {\n				this.invalidate = false;\n				this.previousName = this.name;\n				this.name = isDefined(this.interpolationName.render()) ? this.interpolationName.render() : this.name;\n				this.value = isDefined(this.interpolationValue.render()) ? this.interpolationValue.render() : this.value;\n				if (this.name === attributes.src) {\n					renderSrc(this.value);\n				}\n				else if (this.name === attributes.href) {\n					renderHref(this.value);\n				}\n				else {\n					if (ie !== 7 || (ie === 7 && !this.node.isRepeaterChild)) {\n						this.node.element.removeAttribute(this.interpolationName.value);\n					}\n					if (this.previousName) {\n						if (ie === 7 && this.previousName === 'class') {\n							// iE\n							this.node.element.className = '';\n						}\n						else {\n							if (ie !== 7 || (ie === 7 && !this.node.isRepeaterChild)) {\n								this.node.element.removeAttribute(this.previousName);\n							}\n						}\n					}\n					renderAttribute(this.name, this.value, this.node);\n				}\n			}\n			// cloak\n			if (this.name === 'class' && this.value.indexOf(settings.attributes.cloak) !== -1) {\n				removeClass(this.node.element, settings.attributes.cloak);\n			}\n			// hide\n			if (this.name === attributes.hide) {\n				var bool = normalizeBoolean(this.value);\n				renderAttribute(this.name, bool, this.node);\n				element.style.display = bool ? 'none' : '';\n			}\n			// show\n			if (this.name === attributes.show) {\n				var bool = normalizeBoolean(this.value);\n				renderAttribute(this.name, bool, this.node);\n				element.style.display = bool ? '' : 'none';\n			}\n			// checked\n			if (this.name === attributes.checked) {\n				renderSpecialAttribute(this.value, 'checked');\n				renderAttribute(this.name, normalizeBoolean(this.value) ? true : false, this.node);\n                element.checked = normalizeBoolean(this.value) ? true : false;\n			}\n			// disabled\n			if (this.name === attributes.disabled) {\n				renderSpecialAttribute(this.value, 'disabled');\n				renderAttribute(this.name, normalizeBoolean(this.value) ? true : false, this.node);\n			}\n			// multiple\n			if (this.name === attributes.multiple) {\n				renderSpecialAttribute(this.value, 'multiple');\n				renderAttribute(this.name, normalizeBoolean(this.value) ? true : false, this.node);\n			}\n			// readonly\n			if (this.name === attributes.readonly) {\n				var bool = normalizeBoolean(this.value);\n				if (ie === 7) {\n					element.readOnly = bool ? true : false;\n				}\n				else {\n					renderSpecialAttribute(this.value, 'readonly');\n				}\n				renderAttribute(this.name, bool ? true : false, this.node);\n			}\n			// selected\n			if (this.name === attributes.selected) {\n				renderSpecialAttribute(this.value, 'selected');\n				renderAttribute(this.name, normalizeBoolean(this.value) ? true : false, this.node);\n			}\n		}\n	};\n\n	var Interpolation = function(value, node, attribute) {\n		this.value = node && !isTextNode(node.element) ? trim(value) : value;\n		this.node = node;\n		this.attribute = attribute;\n		this.sequence = [];\n		this.expressions = [];\n		var parts = this.value.match(regex.sequence);\n		if (parts) {\n			for (var i = 0, l = parts.length; i < l; i++) {\n				if (parts[i].match(regex.token)) {\n					var exp = new Expression(trimTokens(parts[i]), this.node, this.attribute);\n					this.sequence.push(exp);\n					this.expressions.push(exp);\n				}\n				else {\n					this.sequence.push(parts[i]);\n				}\n			}\n			trimArray(this.sequence);\n		}\n	};\n	Interpolation.prototype = {\n		toString: function() {\n			return '[object Interpolation]';\n		},\n		dispose: function() {\n			if (this.expressions) {\n				for (var i = 0, l = this.expressions.length; i < l; i++) {\n					this.expressions[i].dispose();\n				}\n			}\n			this.value = null;\n			this.node = null;\n			this.attribute = null;\n			this.sequence = null;\n			this.expressions = null;\n		},\n		update: function() {\n			var i = -1, l = this.expressions.length;\n			while (++i < l) {\n				this.expressions[i].update();\n			}\n		},\n		render: function() {\n			var rendered = '';\n			if (this.sequence) {\n				for (var i = 0, l = this.sequence.length; i < l; i++) {\n					var val = '';\n					if (isExpression(this.sequence[i])) {\n						val = this.sequence[i].value;\n					}\n					else {\n						val = this.sequence[i];\n					}\n					if (!isDefined(val)) {\n						val = '';\n					}\n					rendered += val;\n				}\n			}\n			return rendered;\n		}\n	};\n\n	var Expression = function(pattern, node, attribute) {\n		if (!isDefined(pattern)) {\n			return;\n		}\n		this.pattern = pattern;\n		this.isString = regex.string.test(pattern);\n		this.node = node;\n		this.attribute = attribute;\n		this.value = this.isString ? this.pattern : undefined;\n		if (this.isString) {\n			this.isFunction = false;\n			this.depth = null;\n			this.path = null;\n			this.params = null;\n		}\n		else {\n			this.isFunction = isExpFunction(this.pattern);\n			this.depth = getScopeDepth(this.pattern);\n			this.path = getExpressionPath(this.pattern);\n			this.params = !this.isFunction ? null : getParamsFromString(this.pattern.match(regex.func)[2]);\n		}\n	};\n	Expression.prototype = {\n		toString: function() {\n			return '[object Expression]';\n		},\n		dispose: function() {\n			this.pattern = null;\n			this.node = null;\n			this.attribute = null;\n			this.path = null;\n			this.params = null;\n			this.value = null;\n		},\n		update: function() {\n			var node = this.node;\n			if (!node && this.attribute) {\n				node = this.attribute.node;\n			}\n			if (!node && node.scope) {\n				return;\n			}\n			var newValue = this.getValue(node.scope);\n			newValue = getWatcherValue(this, newValue);\n			if (this.value !== newValue) {\n				this.value = newValue;\n				(this.node || this.attribute).invalidate = true;\n			}\n		},\n		getValue: function(scope, getFunction, getParams) {\n			var node = this.node;\n			if (!node && this.attribute) {\n				node = this.attribute.node;\n			}\n			var context = {};\n			if (node) {\n				context[vars.element] = node.element;\n				if (node.element) {\n					context[vars.parentElement] = node.element.parentNode;\n				}\n			}\n			context[vars.attribute] = this.attribute;\n			context[vars.scope] = scope;\n			return getValue(scope, this.pattern, this.path, this.params, getFunction, getParams, undefined, context);\n		}\n	};\n\n	var templates = new HashMap('st');\n\n	var Template = function(element) {\n		this.watchers = new HashMap('stw');\n		this.node = null;\n		this.scope = null;\n		this.compile(element);\n	};\n	Template.prototype = {\n		toString: function() {\n			return '[object Template]';\n		},\n		compile: function(element) {\n			if (element) {\n				this.element = element;\n			}\n			if (this.node) {\n				this.node.dispose();\n			}\n			this.node = compile(this, this.element);\n			this.node.root = true;\n			this.scope = this.node.scope;\n		},\n		update: function(data) {\n			if (isDefined(data)) {\n				updateScopeWithData(this.node.scope, data);\n			}\n			if (this.node) {\n				this.node.update();\n			}\n		},\n		render: function(data) {\n			this.update(data);\n			if (this.node) {\n				this.node.render();\n			}\n		},\n		invalidate: function() {\n			if (this.node) {\n				this.node.invalidateData();\n			}\n		},\n		watch: function(target, watcher) {\n			if ( (!isString(target) && !isElement(target)) || !isFunction(watcher)) {\n				return;\n			}\n			this.watchers.put(target, watcher);\n		},\n		unwatch: function(target) {\n			this.watchers.remove(target);\n		},\n		clearWatchers: function() {\n			this.watchers.dispose();\n		},\n		clearEvents: function() {\n			this.node.clearEvents();\n		},\n		getNode: function(element) {\n			return this.node.getNode(element);\n		},\n		dispose: function() {\n			templates.remove(this.element);\n			if (this.watchers) {\n				this.watchers.dispose();\n			}\n			if (this.node) {\n				this.node.dispose();\n			}\n			this.element = null;\n			this.watchers = null;\n			this.node = null;\n		}\n	};\n\n	// written by Dean Edwards, 2005\n	// with input from Tino Zijdel, Matthias Miller, Diego Perini\n	// http://dean.edwards.name/weblog/2005/10/add-event/\n	function addEvent(element, type, handler) {\n		if (element.addEventListener) {\n			element.addEventListener(type, handler, false);\n		} else {\n			// assign each event handler a unique ID\n			if (!handler.$$guid) {\n				handler.$$guid = addEvent.guid++;\n			}\n			// create a hash table of event types for the element\n			if (!element.events) {\n				element.events = {};\n			}\n			// create a hash table of event handlers for each element/event pair\n			var handlers = element.events[type];\n			if (!handlers) {\n				handlers = element.events[type] = {};\n				// store the existing event handler (if there is one)\n				if (element['on' + type]) {\n					handlers[0] = element['on' + type];\n				}\n			}\n			// store the event handler in the hash table\n			handlers[handler.$$guid] = handler;\n			// assign a global event handler to do all the work\n			element['on' + type] = function(event) {\n				var returnValue = true;\n				// grab the event object (IE uses a global event object)\n				event = event || fixEvent(((this.ownerDocument || this.document || this).parentWindow || window).event);\n				// get a reference to the hash table of event handlers\n				var handlers = this.events[event.type];\n				// execute each event handler\n				for (var i in handlers) {\n					if (handlers.hasOwnProperty(i)) {\n						this.$$handleEvent = handlers[i];\n						if (this.$$handleEvent(event) === false) {\n							returnValue = false;\n						}\n					}\n				}\n				return returnValue;\n			};\n		}\n	}\n	// a counter used to create unique IDs\n	addEvent.guid = 1;\n	function removeEvent(element, type, handler) {\n		if (element.removeEventListener) {\n			element.removeEventListener(type, handler, false);\n		} else {\n			// delete the event handler from the hash table\n			if (element.events && element.events[type]) {\n				delete element.events[type][handler.$$guid];\n			}\n		}\n	}\n	function fixEvent(event) {\n		// add W3C standard event methods\n		event.preventDefault = fixEvent.preventDefault;\n		event.stopPropagation = fixEvent.stopPropagation;\n		return event;\n	}\n	fixEvent.preventDefault = function() {\n		this.returnValue = false;\n	};\n	fixEvent.stopPropagation = function() {\n		this.cancelBubble = true;\n	};\n\n	var maxDepth;\n	var eventStore = [];\n\n	function parseEvents(element, object, depth) {\n		maxDepth = depth === undefined ? Number.MAX_VALUE : depth;\n		parseNode(element, object, 0, true);\n	}\n\n	function parseNode(element, object, depth, isRoot) {\n		if (!isElement(element)) {\n			throw new Error('Error in soma.template.parseEvents, only a DOM Element can be parsed.');\n		}\n		if (isRoot) {\n			parseAttributes(element, object);\n		}\n		if (maxDepth === 0) {\n			return;\n		}\n		var child = element.firstChild;\n		while (child) {\n			if (child.nodeType === 1) {\n				if (depth < maxDepth) {\n					parseNode(child, object, ++depth);\n					parseAttributes(child, object);\n				}\n			}\n			child = child.nextSibling;\n		}\n	}\n\n	function parseAttributes(element, object) {\n		for (var attr, name, value, attrs = element.attributes, j = 0, jj = attrs && attrs.length; j < jj; j++) {\n			attr = attrs[j];\n			if (attr.specified) {\n				name = attr.name;\n				value = attr.value;\n				if (events[name]) {\n					var handler = getHandlerFromPattern(object, value);\n					if (handler && isFunction(handler)) {\n						addEvent(element, events[name], handler);\n						eventStore.push({element:element, type:events[name], handler:handler});\n					}\n				}\n			}\n		}\n	}\n\n	function getHandlerFromPattern(object, pattern) {\n		var parts = pattern.match(regex.func);\n		if (parts) {\n			var func = parts[1];\n			if (isFunction(object[func])) {\n				return object[func];\n			}\n		}\n	}\n\n	function clearEvents(element) {\n		var i = eventStore.length, l = 0;\n		while (--i >= l) {\n			var item = eventStore[i];\n			if (element === item.element || contains(element, item.element)) {\n				removeEvent(item.element, item.type, item.handler);\n				eventStore.splice(i, 1);\n			}\n		}\n	}\n\n\n\n\n	var ready;\n	if (typeof document === 'object') {\n		// https://github.com/ded/domready\n		var ready=function(){function l(b){for(k=1;b=a.shift();)b()}var b,a=[],c=!1,d=document,e=d.documentElement,f=e.doScroll,g=\"DOMContentLoaded\",h=\"addEventListener\",i=\"onreadystatechange\",j=\"readyState\",k=/^loade|c/.test(d[j]);return d[h]&&d[h](g,b=function(){d.removeEventListener(g,b,c),l()},c),f&&d.attachEvent(i,b=function(){/^c/.test(d[j])&&(d.detachEvent(i,b),l())}),f?function(b){self!=top?k?b():a.push(b):function(){try{e.doScroll(\"left\")}catch(a){return setTimeout(function(){ready(b)},50)}b()}()}:function(b){k?b():a.push(b)}}();\n		if (settings.autocreate) {\n			var parse = function(element) {\n				var child = !element ? document.body : element.firstChild;\n				while (child) {\n					if (child.nodeType === 1) {\n						parse(child);\n						var attrValue = child.getAttribute(attributes.template);\n						if (attrValue) {\n							var getFunction = new Function('return ' + attrValue + ';');\n							try {\n								var f = getFunction();\n								if (isFunction(f)) {\n									soma.template.bootstrap(attrValue, child, f);\n								}\n							} catch(err){}\n						}\n					}\n					child = child.nextSibling;\n				}\n			};\n			ready(parse);\n		}\n	}\n	function bootstrapTemplate(attrValue, element, func) {\n		var tpl = createTemplate(element);\n		func(tpl, tpl.scope, tpl.element, tpl.node);\n	}\n\n	function createTemplate(source, target) {\n		var element;\n		if (isString(source)) {\n			// string template\n			if (!isElement(target)) {\n				throw new Error(soma.template.errors.TEMPLATE_STRING_NO_ELEMENT);\n			}\n			target.innerHTML = source;\n			element = target;\n		}\n		else if (isElement(source)) {\n			if (isElement(target)) {\n				// element template with target\n				target.innerHTML = source.innerHTML;\n				element = target;\n			}\n			else {\n				// element template\n				element = source;\n			}\n		}\n		else {\n			throw new Error(soma.template.errors.TEMPLATE_NO_PARAM);\n		}\n		// existing template\n		if (getTemplate(element)) {\n			getTemplate(element).dispose();\n			templates.remove(element);\n		}\n		// create template\n		var template = new Template(element);\n		templates.put(element, template);\n		return template;\n	}\n\n	function getTemplate(element) {\n		return templates.get(element);\n	}\n\n	function renderAllTemplates() {\n		var data = templates.getData();\n		for (var key in templates.getData()) {\n			if (data.hasOwnProperty(key)) {\n				templates.get(key).render();\n			}\n		}\n	}\n\n	function appendHelpers(obj) {\n		if (obj === null) {\n			helpersObject = {};\n			helpersScopeObject = {};\n		}\n		if (isDefined(obj) && isObject(obj)) {\n			for (var key in obj) {\n				if (obj.hasOwnProperty(key)) {\n					helpersObject[key] = helpersScopeObject[key] = obj[key];\n				}\n			}\n		}\n		return helpersObject;\n	}\n\n	// set regex\n	tokens.start(tokenStart);\n	tokens.end(tokenEnd);\n\n	// plugins\n\n	soma.plugins = soma.plugins || {};\n\n	var TemplatePlugin = function(instance, injector) {\n		instance.constructor.prototype.createTemplate = function(cl, domElement) {\n			if (!cl || typeof cl !== 'function') {\n				throw new Error('Error creating a template, the first parameter must be a function.');\n			}\n			if (domElement && isElement(domElement)) {\n				var template = soma.template.create(domElement);\n				for (var key in template) {\n					if (typeof template[key] === 'function') {\n						cl.prototype[key] = template[key].bind(template);\n					}\n				}\n				cl.prototype.render = template.render.bind(template);\n				var childInjector = injector.createChild();\n				childInjector.mapValue('template', template);\n				childInjector.mapValue('scope', template.scope);\n				childInjector.mapValue('element', template.element);\n				return childInjector.createInstance(cl);\n			}\n			return null;\n		};\n		soma.template.bootstrap = function(attrValue, element, func) {\n			instance.createTemplate(func, element);\n		};\n	};\n	if (soma.plugins && soma.plugins.add) {\n		soma.plugins.add(TemplatePlugin);\n	}\n\n	soma.template.Plugin = TemplatePlugin;\n\n	// exports\n	soma.template.create = createTemplate;\n	soma.template.get = getTemplate;\n	soma.template.renderAll = renderAllTemplates;\n	soma.template.helpers = appendHelpers;\n	soma.template.bootstrap = bootstrapTemplate;\n	soma.template.addEvent = addEvent;\n	soma.template.removeEvent = removeEvent;\n	soma.template.parseEvents = parseEvents;\n	soma.template.clearEvents = clearEvents;\n	soma.template.ready = ready;\n\n	// register for AMD module\n	if (typeof define === 'function' && typeof define.amd !== 'undefined') {\n		define('soma-template', soma.template);\n	}\n\n	// export for node.js\n	if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n		module.exports = soma.template;\n	}\n	if (typeof exports !== 'undefined') {\n		exports = soma.template;\n	}\n\n})(this['soma'] = this['soma'] || {});"
}, function(module) {
    module.exports = "/*\nCopyright (c) | 2013 | infuse.js | Romuald Quantin | www.soundstep.com | romu@soundstep.com\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software\nand associated documentation files (the \"Software\"), to deal in the Software without restriction,\nincluding without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\nand/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial\nportions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT\nLIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n(function(infuse) {\n\n    'use strict';\n\n	infuse.version = '0.7.0';\n\n	// regex from angular JS (https://github.com/angular/angular.js)\n	var FN_ARGS = /^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m;\n	var FN_ARG_SPLIT = /,/;\n	var FN_ARG = /^\\s*(_?)(\\S+?)\\1\\s*$/;\n	var STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n\n	function contains(arr, value) {\n		var i = arr.length;\n		while (i--) {\n			if (arr[i] === value) {\n				return true;\n			}\n		}\n		return false;\n	}\n\n	infuse.InjectorError = {\n		MAPPING_BAD_PROP: '[Error infuse.Injector.mapClass/mapValue] the first parameter is invalid, a string is expected',\n		MAPPING_BAD_VALUE: '[Error infuse.Injector.mapClass/mapValue] the second parameter is invalid, it can\\'t null or undefined, with property: ',\n		MAPPING_BAD_CLASS: '[Error infuse.Injector.mapClass/mapValue] the second parameter is invalid, a function is expected, with property: ',\n		MAPPING_BAD_SINGLETON: '[Error infuse.Injector.mapClass] the third parameter is invalid, a boolean is expected, with property: ',\n		MAPPING_ALREADY_EXISTS: '[Error infuse.Injector.mapClass/mapValue] this mapping already exists, with property: ',\n		CREATE_INSTANCE_INVALID_PARAM: '[Error infuse.Injector.createInstance] invalid parameter, a function is expected',\n		NO_MAPPING_FOUND: '[Error infuse.Injector.getInstance] no mapping found',\n		INJECT_INSTANCE_IN_ITSELF_PROPERTY: '[Error infuse.Injector.getInjectedValue] A matching property has been found in the target, you can\\'t inject an instance in itself',\n		INJECT_INSTANCE_IN_ITSELF_CONSTRUCTOR: '[Error infuse.Injector.getInjectedValue] A matching constructor parameter has been found in the target, you can\\'t inject an instance in itself'\n	};\n\n	var MappingVO = function(prop, value, cl, singleton) {\n		this.prop = prop;\n		this.value = value;\n		this.cl = cl;\n		this.singleton = singleton || false;\n	};\n\n	var validateProp = function(prop) {\n		if (typeof prop !== 'string') {\n			throw new Error(infuse.InjectorError.MAPPING_BAD_PROP);\n		}\n	};\n\n	var validateValue = function(prop, val) {\n		if (val === undefined || val === null) {\n			throw new Error(infuse.InjectorError.MAPPING_BAD_VALUE + prop);\n		}\n	};\n\n	var validateClass = function(prop, val) {\n		if (typeof val !== 'function') {\n			throw new Error(infuse.InjectorError.MAPPING_BAD_CLASS + prop);\n		}\n	};\n\n	var validateBooleanSingleton = function(prop, singleton) {\n		if (typeof singleton !== 'boolean') {\n			throw new Error(infuse.InjectorError.MAPPING_BAD_SINGLETON + prop);\n		}\n	};\n\n	var validateConstructorInjectionLoop = function(name, cl) {\n		var params = infuse.getConstructorParams(cl);\n		if (contains(params, name)) {\n			throw new Error(infuse.InjectorError.INJECT_INSTANCE_IN_ITSELF_CONSTRUCTOR);\n		}\n	};\n\n	var validatePropertyInjectionLoop = function(name, target) {\n		if (target.hasOwnProperty(name)) {\n			throw new Error(infuse.InjectorError.INJECT_INSTANCE_IN_ITSELF_PROPERTY);\n		}\n	};\n\n	infuse.Injector = function() {\n		this.mappings = {};\n		this.parent = null;\n	};\n\n	infuse.getConstructorParams = function(cl) {\n		var args = [],\n		    inject;\n		function extractName(all, underscore, name) {\n			args.push(name);\n		}\n\n		// Override arg name with inject array values if present\n		if( cl.hasOwnProperty('inject') && toString.call(cl.inject) === '[object Array]' && cl.inject.length > 0)\n		  inject = cl.inject;\n\n		var clStr = cl.toString().replace(STRIP_COMMENTS, '');\n		var argsFlat = clStr.match(FN_ARGS);\n		var spl = argsFlat[1].split(FN_ARG_SPLIT);\n		for (var i=0; i<spl.length; i++) {\n		  // Only override arg with non-falsey inject value at same key\n			var arg = (inject && inject[i]) ? inject[i] : spl[i];\n			arg.replace(FN_ARG, extractName);\n		}\n		return args;\n	};\n\n	infuse.Injector.prototype = {\n\n		createChild: function() {\n			var injector = new infuse.Injector();\n			injector.parent = this;\n			return injector;\n		},\n\n		getMappingVo: function(prop) {\n			if (!this.mappings) {\n				return null;\n			}\n			if (this.mappings[prop]) {\n				return this.mappings[prop];\n			}\n			if (this.parent) {\n				return this.parent.getMappingVo(prop);\n			}\n			return null;\n		},\n\n		mapValue: function(prop, val) {\n			if (this.mappings[prop]) {\n				throw new Error(infuse.InjectorError.MAPPING_ALREADY_EXISTS + prop);\n			}\n			validateProp(prop);\n			validateValue(prop, val);\n			this.mappings[prop] = new MappingVO(prop, val, undefined, undefined);\n			return this;\n		},\n\n		mapClass: function(prop, cl, singleton) {\n			if (this.mappings[prop]) {\n				throw new Error(infuse.InjectorError.MAPPING_ALREADY_EXISTS + prop);\n			}\n			validateProp(prop);\n			validateClass(prop, cl);\n			if (singleton) {\n				validateBooleanSingleton(prop, singleton);\n			}\n			this.mappings[prop] = new MappingVO(prop, null, cl, singleton);\n			return this;\n		},\n\n		removeMapping: function(prop) {\n			this.mappings[prop] = null;\n			delete this.mappings[prop];\n			return this;\n		},\n\n		hasMapping: function(prop) {\n			return !!this.mappings[prop];\n		},\n\n		hasInheritedMapping: function(prop) {\n			return !!this.getMappingVo(prop);\n		},\n\n		getMapping: function(value) {\n			for (var name in this.mappings) {\n				if (this.mappings.hasOwnProperty(name)) {\n					var vo = this.mappings[name];\n					if (vo.value === value || vo.cl === value) {\n						return vo.prop;\n					}\n				}\n			}\n			return undefined;\n		},\n\n		getValue: function(prop) {\n			var vo = this.mappings[prop];\n			if (!vo) {\n				if (this.parent) {\n					return this.parent.getValue.apply(this.parent, arguments);\n				}\n				else {\n					throw new Error(infuse.InjectorError.NO_MAPPING_FOUND);\n				}\n			}\n			if (vo.cl) {\n				var args = Array.prototype.slice.call(arguments);\n				args[0] = vo.cl;\n				if (vo.singleton) {\n					if (!vo.value) {\n						vo.value = this.createInstance.apply(this, args);\n					}\n					return vo.value;\n				}\n				else {\n					return this.createInstance.apply(this, args);\n				}\n			}\n			return vo.value;\n		},\n\n		getClass: function(prop) {\n			var vo = this.mappings[prop];\n			if (!vo) {\n				if (this.parent) {\n					return this.parent.getClass(prop);\n				}\n				else {\n					return undefined;\n				}\n			}\n			if (vo.cl) {\n				return vo.cl;\n			}\n			return undefined;\n		},\n\n		instantiate: function(TargetClass) {\n			if (typeof TargetClass !== 'function') {\n				throw new Error(infuse.InjectorError.CREATE_INSTANCE_INVALID_PARAM);\n			}\n			var args = [null];\n			var params = infuse.getConstructorParams(TargetClass);\n			for (var i=0; i<params.length; i++) {\n				if (arguments[i+1] !== undefined && arguments[i+1] !== null) {\n					// argument found\n					args.push(arguments[i+1]);\n				}\n				else {\n					var name = params[i];\n					// no argument found\n					var vo = this.getMappingVo(name);\n					if (!!vo) {\n						// found mapping\n						var val = this.getInjectedValue(vo, name);\n						args.push(val);\n					}\n					else {\n						// no mapping found\n						args.push(undefined);\n					}\n				}\n			}\n			return new (Function.prototype.bind.apply(TargetClass, args))();\n		},\n\n		inject: function (target, isParent) {\n			if (this.parent) {\n				this.parent.inject(target, true);\n			}\n			for (var name in this.mappings) {\n				if (this.mappings.hasOwnProperty(name)) {\n					var vo = this.getMappingVo(name);\n					if (target.hasOwnProperty(vo.prop) || (target.constructor && target.constructor.prototype && target.constructor.prototype.hasOwnProperty(vo.prop)) ) {\n						target[name] = this.getInjectedValue(vo, name);\n					}\n				}\n			}\n			if (typeof target.postConstruct === 'function' && !isParent) {\n				target.postConstruct();\n			}\n			return this;\n		},\n\n		getInjectedValue: function(vo, name) {\n			var val = vo.value;\n			var injectee;\n			if (vo.cl) {\n				if (vo.singleton) {\n					if (!vo.value) {\n						validateConstructorInjectionLoop(name, vo.cl);\n						vo.value = this.instantiate(vo.cl);\n						injectee = vo.value;\n					}\n					val = vo.value;\n				}\n				else {\n					validateConstructorInjectionLoop(name, vo.cl);\n					val = this.instantiate(vo.cl);\n					injectee = val;\n				}\n			}\n			if (injectee) {\n				validatePropertyInjectionLoop(name, injectee);\n				this.inject(injectee);\n			}\n			return val;\n		},\n\n		createInstance: function() {\n			var instance = this.instantiate.apply(this, arguments);\n			this.inject(instance);\n			return instance;\n		},\n\n		getValueFromClass: function(cl) {\n			for (var name in this.mappings) {\n				if (this.mappings.hasOwnProperty(name)) {\n					var vo = this.mappings[name];\n					if (vo.cl === cl) {\n						if (vo.singleton) {\n							if (!vo.value) {\n								vo.value = this.createInstance.apply(this, arguments);\n							}\n							return vo.value;\n						}\n						else {\n							return this.createInstance.apply(this, arguments);\n						}\n					}\n				}\n			}\n			if (this.parent) {\n				return this.parent.getValueFromClass.apply(this.parent, arguments);\n			} else {\n				throw new Error(infuse.InjectorError.NO_MAPPING_FOUND);\n			}\n		},\n\n		dispose: function() {\n			this.mappings = {};\n		}\n\n	};\n\n	if (!Function.prototype.bind) {\n		Function.prototype.bind = function bind(that) {\n			var target = this;\n			if (typeof target !== 'function') {\n				throw new Error('Error, you must bind a function.');\n			}\n			var args = Array.prototype.slice.call(arguments, 1); // for normal call\n			var bound = function () {\n				if (this instanceof bound) {\n					var F = function(){};\n					F.prototype = target.prototype;\n					var self = new F();\n					var result = target.apply(\n						self,\n						args.concat(Array.prototype.slice.call(arguments))\n					);\n					if (Object(result) === result) {\n						return result;\n					}\n					return self;\n				} else {\n					return target.apply(\n						that,\n						args.concat(Array.prototype.slice.call(arguments))\n					);\n				}\n			};\n			return bound;\n		};\n	}\n\n	// register for AMD module\n	if (typeof define === 'function' && typeof define.amd !== 'undefined') {\n		define(\"infuse\", infuse);\n	}\n\n	// export for node.js\n	if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n		module.exports = infuse;\n	}\n	if (typeof exports !== 'undefined') {\n		exports = infuse;\n	}\n\n})(this['infuse'] = this['infuse'] || {});\n/*\nCopyright (c) | 2013 | soma-events | Romuald Quantin | www.soundstep.com\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy,\nmodify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software\nis furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR\nIN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n(function (soma) {\n\n	'use strict';\n\n	soma.events = {};\n	soma.events.version = '0.5.6';\n\n    if (!Function.prototype.bind) {\n        Function.prototype.bind = function bind(that) {\n            var target = this;\n            if (typeof target !== 'function') {\n                throw new Error('Error, you must bind a function.');\n            }\n            var args = Array.prototype.slice.call(arguments, 1); // for normal call\n            var bound = function () {\n                if (this instanceof bound) {\n                    var F = function(){};\n                    F.prototype = target.prototype;\n                    var self = new F();\n                    var result = target.apply(\n                        self,\n                        args.concat(Array.prototype.slice.call(arguments))\n                    );\n                    if (Object(result) === result) {\n                        return result;\n                    }\n                    return self;\n                } else {\n                    return target.apply(\n                        that,\n                        args.concat(Array.prototype.slice.call(arguments))\n                    );\n                }\n            };\n            return bound;\n        };\n    }\n\n	soma.Event = function (type, params, bubbles, cancelable) {\n		var e = soma.Event.createGenericEvent(type, bubbles, cancelable);\n		if (params !== null && params !== undefined) {\n			e.params = params;\n		}\n		e.isCloned = false;\n		e.clone = this.clone.bind(e);\n		e.isIE9orIE10 = this.isIE9orIE10;\n		e.isDefaultPrevented = this.isDefaultPrevented;\n		if (this.isIE9orIE10() || !e.preventDefault || (e.getDefaultPrevented === undefined && e.defaultPrevented === undefined )) {\n			e.preventDefault = this.preventDefault.bind(e);\n		}\n		if (this.isIE9orIE10()) {\n			e.IE9or10PreventDefault = false;\n		}\n		return e;\n	};\n\n	soma.Event.prototype.clone = function () {\n		var e = soma.Event.createGenericEvent(this.type, this.bubbles, this.cancelable);\n		e.params = this.params;\n		e.isCloned = true;\n		e.clone = this.clone;\n		e.isDefaultPrevented = this.isDefaultPrevented;\n		e.isIE9orIE10 = this.isIE9orIE10;\n		if (this.isIE9orIE10()) {\n			e.IE9or10PreventDefault = this.IE9or10PreventDefault;\n		}\n		return e;\n	};\n\n	soma.Event.prototype.preventDefault = function () {\n		if (!this.cancelable) {\n			return false;\n		}\n		if (this.isIE9orIE10()) {\n			this.IE9or10PreventDefault = true;\n		}\n		else {\n			this.defaultPrevented = true;\n		}\n		return this;\n	};\n\n	soma.Event.prototype.isDefaultPrevented = function () {\n		if (!this.cancelable) {\n			return false;\n		}\n		if (this.isIE9orIE10()) {\n			return this.IE9or10PreventDefault;\n		}\n		if (this.defaultPrevented !== undefined) {\n			return this.defaultPrevented;\n		} else if (this.getDefaultPrevented !== undefined) {\n			return this.getDefaultPrevented();\n		}\n		return false;\n	};\n\n	soma.Event.createGenericEvent = function (type, bubbles, cancelable) {\n		var event;\n		bubbles = bubbles !== undefined ? bubbles : true;\n		if (typeof document === 'object' && document.createEvent) {\n			event = document.createEvent('Event');\n			event.initEvent(type, !!bubbles, !!cancelable);\n		} else if (typeof document === 'object' && document.createEventObject) {\n			event = document.createEventObject();\n			event.type = type;\n			event.bubbles = !!bubbles;\n			event.cancelable = !!cancelable;\n		} else {\n			event = new EventObject(type, !!bubbles, !!cancelable);\n		}\n		return event;\n	};\n\n	soma.Event.prototype.isIE9orIE10 = function() {\n        if (typeof document !== 'object') {\n			return false;\n        }\n		return (document.body.style.scrollbar3dLightColor !== undefined && document.body.style.opacity !== undefined) || document.body.style.msTouchAction !== undefined;\n    };\n\n	soma.Event.prototype.toString = function() {\n		return '[soma.Event]';\n	};\n\n	var EventObject = function(type, bubbles, cancelable) {\n		this.type = type;\n		this.bubbles = !!bubbles;\n		this.cancelable = !!cancelable;\n		this.defaultPrevented = false;\n		this.currentTarget = null;\n		this.target = null;\n	};\n\n	soma.EventDispatcher = function () {\n		this.listeners = [];\n	};\n\n	soma.EventDispatcher.prototype.addEventListener = function(type, listener, priority) {\n		if (!this.listeners || !type || !listener) {\n			return;\n		}\n		if (isNaN(priority)) {\n			priority = 0;\n		}\n		for (var i=0; i<this.listeners.length; i++) {\n			var eventObj = this.listeners[i];\n			if (eventObj.type === type && eventObj.listener === listener) {\n				return;\n			}\n		}\n		this.listeners.push({type: type, listener: listener, priority: priority, scope:this});\n	};\n\n	soma.EventDispatcher.prototype.removeEventListener = function(type, listener) {\n		if (!this.listeners || !type || !listener) {\n			return;\n		}\n		var i = this.listeners.length;\n		while(i-- > 0) {\n			var eventObj = this.listeners[i];\n			if (eventObj.type === type && eventObj.listener === listener) {\n				this.listeners.splice(i, 1);\n			}\n		}\n	};\n\n	soma.EventDispatcher.prototype.hasEventListener = function(type) {\n		if (!this.listeners || !type) {\n			return false;\n		}\n		var i = 0;\n		var l = this.listeners.length;\n		for (; i < l; ++i) {\n			var eventObj = this.listeners[i];\n			if (eventObj.type === type) {\n				return true;\n			}\n		}\n		return false;\n	};\n\n	soma.EventDispatcher.prototype.dispatchEvent = function(event) {\n		if (!this.listeners || !event) {\n			throw new Error('Error in EventDispatcher (dispatchEvent), one of the parameters is null or undefined.');\n		}\n		var events = [];\n		var i;\n		for (i = 0; i < this.listeners.length; i++) {\n			var eventObj = this.listeners[i];\n			if (eventObj.type === event.type) {\n				events.push(eventObj);\n			}\n		}\n		events.sort(function(a, b) {\n			return b.priority - a.priority;\n		});\n		for (i = 0; i < events.length; i++) {\n			events[i].listener.apply((event.srcElement) ? event.srcElement : event.currentTarget, [event]);\n		}\n		return !event.isDefaultPrevented();\n	};\n\n	soma.EventDispatcher.prototype.dispatch = function(type, params, bubbles, cancelable) {\n		if (!this.listeners || !type || type === '') {\n			throw new Error('Error in EventDispatcher (dispatch), one of the parameters is null or undefined.');\n		}\n		var event = new soma.Event(type, params, bubbles, cancelable);\n		this.dispatchEvent(event);\n		return event;\n	};\n\n	soma.EventDispatcher.prototype.dispose = function() {\n		this.listeners = null;\n	};\n\n	soma.EventDispatcher.prototype.toString = function() {\n		return '[soma.EventDispatcher]';\n	};\n\n	// register for AMD module\n	if (typeof define === 'function' && typeof define.amd !== 'undefined') {\n		define(\"soma-events\", soma);\n	}\n\n	// export for node.js\n	if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n		module.exports = soma;\n	}\n	if (typeof exports !== 'undefined') {\n		exports = soma;\n	}\n\n})(this['soma'] = this['soma'] || {});\n\n\n(function (soma, infuse) {\n\n	'use strict';\n\n	soma.version = '2.1.1';\n\n	soma.applyProperties = function(target, extension, bindToExtension, list) {\n		if (Object.prototype.toString.apply(list) === '[object Array]') {\n			for (var i = 0, l = list.length; i < l; i++) {\n				if (target[list[i]] === undefined || target[list[i]] === null) {\n					if (bindToExtension && typeof extension[list[i]] === 'function') {\n						target[list[i]] = extension[list[i]].bind(extension);\n					}\n					else {\n						target[list[i]] = extension[list[i]];\n					}\n				}\n			}\n		}\n		else {\n			for (var prop in extension) {\n				if (bindToExtension && typeof extension[prop] === 'function') {\n					target[prop] = extension[prop].bind(extension);\n				}\n				else {\n					target[prop] = extension[prop];\n				}\n			}\n		}\n	};\n\n	soma.augment = function (target, extension, list) {\n		if (!extension.prototype || !target.prototype) {\n			return;\n		}\n		if (Object.prototype.toString.apply(list) === '[object Array]') {\n			for (var i = 0, l = list.length; i < l; i++) {\n				if (!target.prototype[list[i]]) {\n					target.prototype[list[i]] = extension.prototype[list[i]];\n				}\n			}\n		}\n		else {\n			for (var prop in extension.prototype) {\n				if (!target.prototype[prop]) {\n					target.prototype[prop] = extension.prototype[prop];\n				}\n			}\n		}\n	};\n\n	soma.inherit = function (parent, obj) {\n		var Subclass;\n		if (obj && obj.hasOwnProperty('constructor')) {\n			// use constructor if defined\n			Subclass = obj.constructor;\n		} else {\n			// call the super constructor\n			Subclass = function () {\n				return parent.apply(this, arguments);\n			};\n		}\n		// set the prototype chain to inherit from the parent without calling parent's constructor\n		var Chain = function(){};\n		Chain.prototype = parent.prototype;\n		Subclass.prototype = new Chain();\n		// add obj properties\n		if (obj) {\n			soma.applyProperties(Subclass.prototype, obj);\n		}\n		// point constructor to the Subclass\n		Subclass.prototype.constructor = Subclass;\n		// set super class reference\n		Subclass.parent = parent.prototype;\n		// add extend shortcut\n		Subclass.extend = function (obj) {\n			return soma.inherit(Subclass, obj);\n		};\n		return Subclass;\n	};\n\n	soma.extend = function (obj) {\n		return soma.inherit(function () {\n		}, obj);\n	};\n	// plugins\n\n	var plugins = [];\n	soma.plugins = soma.plugins || {};\n	soma.plugins.add = function(plugin) {\n		plugins.push(plugin);\n	};\n	soma.plugins.remove = function(plugin) {\n		for (var i = plugins.length-1, l = 0; i >= l; i--) {\n			if (plugin === plugins[i]) {\n				plugins.splice(i, 1);\n			}\n		}\n	};\n\n	// framework\n	soma.Application = soma.extend({\n		constructor: function() {\n\n			var self = this;\n\n			function setup() {\n				// injector\n				self.injector = new infuse.Injector(self.dispatcher);\n				// dispatcher\n				self.dispatcher = new soma.EventDispatcher();\n				// mapping\n				self.injector.mapValue('injector', self.injector);\n				self.injector.mapValue('instance', self);\n				self.injector.mapValue('dispatcher', self.dispatcher);\n				// mediator\n				self.injector.mapClass('mediators', Mediators, true);\n				self.mediators = self.injector.getValue('mediators');\n				// commands\n				self.injector.mapClass('commands', Commands, true);\n				self.commands = self.injector.getValue('commands');\n				// plugins\n				for (var i = 0, l = plugins.length; i < l; i++) {\n					self.createPlugin(plugins[i]);\n				}\n			}\n\n			setup.bind(this)();\n			this.init();\n			this.start();\n\n		},\n		createPlugin: function() {\n			if (arguments.length === 0 || !arguments[0]) {\n				throw new Error('Error creating a plugin, plugin class is missing.');\n			}\n			var params = infuse.getConstructorParams(arguments[0]);\n			// add plugin function\n			var args = [arguments[0]];\n			// add injection mappings\n			for (var i=0, l=params.length; i < l; i++) {\n				if (this.injector.hasMapping(params[i]) || this.injector.hasInheritedMapping(params[i])) {\n					args.push(this.injector.getValue(params[i]));\n				}\n				else {\n					args.push(undefined);\n				}\n			}\n			// trim array\n			for (var a = args.length-1, b = args.length; a >= 0; a--) {\n				if (typeof args[a] === 'undefined') {\n					args.splice(a, 1);\n				}\n				else {\n					break;\n				}\n			}\n			// add arguments\n			for (var j=1, k=arguments.length; j < k; j++) {\n				args.push(arguments[j]);\n			}\n			return this.injector.createInstance.apply(this.injector, args);\n		},\n		init: function() {\n\n		},\n		start: function() {\n\n		},\n		dispose: function() {\n			// mapping\n			if (this.injector) {\n				this.injector.removeMapping('injector');\n				this.injector.removeMapping('dispatcher');\n				this.injector.removeMapping('mediators');\n				this.injector.removeMapping('commands');\n				this.injector.removeMapping('instance');\n			}\n			// variables\n			if (this.injector) {\n				this.injector.dispose();\n			}\n			if (this.dispatcher) {\n				this.dispatcher.dispose();\n			}\n			if (this.mediators) {\n				this.mediators.dispose();\n			}\n			if (this.commands) {\n				this.commands.dispose();\n			}\n			this.injector = undefined;\n			this.dispatcher = undefined;\n			this.mediators = undefined;\n			this.commands = undefined;\n			this.instance = undefined;\n		}\n	});\n\n	var Mediators = soma.extend({\n		constructor: function() {\n			this.injector = null;\n			this.dispatcher = null;\n		},\n		create: function(cl, target) {\n			if (!cl || typeof cl !== 'function') {\n				throw new Error('Error creating a mediator, the first parameter must be a function.');\n			}\n			if (target === undefined || target === null) {\n				throw new Error('Error creating a mediator, the second parameter cannot be undefined or null.');\n			}\n			var targets = [];\n			var meds = [];\n			if (target.length > 0) {\n				targets = target;\n			}\n			else {\n				targets.push(target);\n			}\n			for (var i= 0, l=targets.length; i<l; i++) {\n				var injector = this.injector.createChild();\n				injector.mapValue('target', targets[i]);\n				var mediator = injector.createInstance(cl);\n				if (targets.length === 1) {\n					return mediator;\n				}\n				meds.push(mediator);\n			}\n			return meds;\n		},\n		dispose: function() {\n			this.injector = undefined;\n			this.dispatcher = undefined;\n		}\n	});\n\n	var Commands = soma.extend({\n		constructor: function() {\n			this.boundHandler = this.handler.bind(this);\n			this.dispatcher = null;\n			this.injector = null;\n			this.list = {};\n		},\n		has: function(commandName) {\n			return this.list[commandName] !== null && this.list[commandName] !== undefined;\n		},\n		get: function(commandName) {\n			if (this.has(commandName)) {\n				return this.list[commandName];\n			}\n			return undefined;\n		},\n		getAll: function() {\n			var copy = {};\n			for (var cmd in this.list) {\n				if (this.list.hasOwnProperty(cmd)) {\n					copy[cmd] = this.list[cmd];\n				}\n			}\n			return copy;\n		},\n		add: function(commandName, command) {\n			if (typeof commandName !== 'string') {\n				throw new Error('Error adding a command, the first parameter must be a string.');\n			}\n			if (typeof command !== 'function') {\n				throw new Error('Error adding a command with the name \"' + command + '\", the second parameter must be a function, and must contain an \"execute\" public method.');\n			}\n			if (this.has(commandName)) {\n				throw new Error('Error adding a command with the name: \"' + commandName + '\", already registered.');\n			}\n			this.list[ commandName ] = command;\n			this.addInterceptor(commandName);\n		},\n		remove: function(commandName) {\n			if (!this.has(commandName)) {\n				return;\n			}\n			this.list[commandName] = undefined;\n			delete this.list[commandName];\n			this.removeInterceptor(commandName);\n		},\n		addInterceptor: function(commandName) {\n			this.dispatcher.addEventListener(commandName, this.boundHandler, -Number.MAX_VALUE);\n		},\n		removeInterceptor: function(commandName) {\n			this.dispatcher.removeEventListener(commandName, this.boundHandler);\n		},\n		handler: function(event) {\n			if (event.isDefaultPrevented && !event.isDefaultPrevented()) {\n				this.executeCommand(event);\n			}\n		},\n		executeCommand: function(event) {\n			var commandName = event.type;\n			if (this.has(commandName)) {\n				var command = this.injector.createInstance(this.list[commandName]);\n				if (!command.hasOwnProperty('execute') && command['execute'] === 'function') {\n					throw new Error('Error in ' + this + ' Command ' + command + ' must contain an execute public method.');\n				}\n				command.execute(event);\n			}\n		},\n		dispose: function() {\n			for (var cmd in this.list) {\n				if (this.list.hasOwnProperty(cmd)) {\n					this.remove(cmd);\n				}\n			}\n			this.boundHandler = undefined;\n			this.dispatcher = undefined;\n			this.injector = undefined;\n			this.list = undefined;\n		}\n	});\n\n	// event extend utils\n\n	soma.EventDispatcher.extend = function (obj) {\n		return soma.inherit(soma.EventDispatcher, obj);\n	};\n\n	soma.Event.extend = function (obj) {\n		return soma.inherit(soma.Event, obj);\n	};\n\n	infuse.Injector.extend = function(obj) {\n		return soma.inherit(infuse.Injector, obj);\n	};\n\n\n	// register for AMD module\n	/* globals define:false */\n	if (typeof define === 'function' && typeof define.amd !== 'undefined') {\n		define('soma', soma);\n	}\n\n	// export for node.js\n	if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n		module.exports = soma;\n	}\n	else {\n		window.soma = soma;\n	}\n\n})(this['soma'] = this['soma'] || {}, this['infuse']);"
}, function(module) {
    module.exports = '/*\\\n |*|\n |*|    JXON framework - Copyleft 2011 by Mozilla Developer Network\n |*|\n |*|    https://developer.mozilla.org/en-US/docs/JXON\n |*|\n |*|    This framework is released under the GNU Public License, version 3 or later.\n |*|    http://www.gnu.org/licenses/gpl-3.0-standalone.html\n |*|\n \\*/\n\nvar JXON = new (function () {\n\n  var\n    sValProp = "keyValue", sAttrProp = "keyAttributes", sAttrsPref = "@", /* you can customize these values */\n    aCache = [], rIsNull = /^\\s*$/, rIsBool = /^(?:true|false)$/i;\n\n  function parseText (sValue) {\n    if (rIsNull.test(sValue)) { return null; }\n    if (rIsBool.test(sValue)) { return sValue.toLowerCase() === "true"; }\n    if (isFinite(sValue)) { return parseFloat(sValue); }\n    if (isFinite(Date.parse(sValue))) { return new Date(sValue); }\n    return sValue;\n  }\n\n  function EmptyTree () {}\n\n  EmptyTree.prototype.toString = function () { return "null"; };\n\n  EmptyTree.prototype.valueOf = function () { return null; };\n\n  function objectify (vVal) {\n    return vVal === null ? new EmptyTree() : vVal instanceof Object ? vVal : new vVal.constructor(vVal);\n  }\n\n  function createObjTree (oParentNode, nVerb, bFreeze, bNesteAttr) {\n\n    var\n      nLevelStart = aCache.length, bChildren = oParentNode.hasChildNodes(),\n      bAttributes = oParentNode.attributes ? true : false, bHighVerb = Boolean(nVerb & 2);\n\n    var\n      sProp, vContent, nLength = 0, sCollectedTxt = "",\n      vResult = bHighVerb ? {} : /* put here the default value for empty nodes: */ true;\n\n    if (bChildren) {\n      for (var oNode, nItem = 0; nItem < oParentNode.childNodes.length; nItem++) {\n        oNode = oParentNode.childNodes.item(nItem);\n        if (oNode.nodeType === 4) { sCollectedTxt += oNode.nodeValue; } /* nodeType is "CDATASection" (4) */\n        else if (oNode.nodeType === 3) { sCollectedTxt += oNode.nodeValue.trim(); } /* nodeType is "Text" (3) */\n        else if (oNode.nodeType === 1) { aCache.push(oNode); } /* nodeType is "Element" (1) */\n      }\n    }\n\n    var nLevelEnd = aCache.length, vBuiltVal = parseText(sCollectedTxt);\n\n    if (!bHighVerb && (bChildren || bAttributes)) { vResult = nVerb === 0 ? objectify(vBuiltVal) : {}; }\n\n    for (var nElId = nLevelStart; nElId < nLevelEnd; nElId++) {\n      sProp = aCache[nElId].nodeName;\n      vContent = createObjTree(aCache[nElId], nVerb, bFreeze, bNesteAttr);\n      if (vResult.hasOwnProperty(sProp)) {\n        if (vResult[sProp].constructor !== Array) { vResult[sProp] = [vResult[sProp]]; }\n        vResult[sProp].push(vContent);\n      } else {\n        vResult[sProp] = vContent;\n        nLength++;\n      }\n    }\n\n    if (bAttributes) {\n\n      var \n        nAttrLen = oParentNode.attributes.length,\n        sAPrefix = bNesteAttr ? "" : sAttrsPref, oAttrParent = bNesteAttr ? {} : vResult;\n\n      for (var oAttrib, nAttrib = 0; nAttrib < nAttrLen; nLength++, nAttrib++) {\n        oAttrib = oParentNode.attributes.item(nAttrib);\n        oAttrParent[sAPrefix + oAttrib.name] = parseText(oAttrib.value.trim());\n      }\n\n      if (bNesteAttr) {\n        if (bFreeze) { Object.freeze(oAttrParent); }\n        vResult[sAttrProp] = oAttrParent;\n        nLength -= nAttrLen - 1;\n      }\n\n    }\n\n    if (nVerb === 3 || (nVerb === 2 || nVerb === 1 && nLength > 0) && sCollectedTxt) {\n      vResult[sValProp] = vBuiltVal;\n    } else if (!bHighVerb && nLength === 0 && sCollectedTxt) {\n      vResult = vBuiltVal;\n    }\n\n    if (bFreeze && (bHighVerb || nLength > 0)) { Object.freeze(vResult); }\n\n    aCache.length = nLevelStart;\n\n    return vResult;\n\n  }\n\n  function loadObjTree (oXMLDoc, oParentEl, oParentObj) {\n\n    var vValue, oChild;\n\n    if (oParentObj instanceof String || oParentObj instanceof Number || oParentObj instanceof Boolean) {\n      oParentEl.appendChild(oXMLDoc.createTextNode(oParentObj.toString())); /* verbosity level is 0 */\n    } else if (oParentObj.constructor === Date) {\n      oParentEl.appendChild(oXMLDoc.createTextNode(oParentObj.toGMTString()));\n    }\n\n    for (var sName in oParentObj) {\n      vValue = oParentObj[sName];\n      if (isFinite(sName) || vValue instanceof Function) { continue; } /* verbosity level is 0 */\n      if (sName === sValProp) {\n        if (vValue !== null && vValue !== true) { oParentEl.appendChild(oXMLDoc.createTextNode(vValue.constructor === Date ? vValue.toGMTString() : String(vValue))); }\n      } else if (sName === sAttrProp) { /* verbosity level is 3 */\n        for (var sAttrib in vValue) { oParentEl.setAttribute(sAttrib, vValue[sAttrib]); }\n      } else if (sName.charAt(0) === sAttrsPref) {\n        oParentEl.setAttribute(sName.slice(1), vValue);\n      } else if (vValue.constructor === Array) {\n        for (var nItem = 0; nItem < vValue.length; nItem++) {\n          oChild = oXMLDoc.createElement(sName);\n          loadObjTree(oXMLDoc, oChild, vValue[nItem]);\n          oParentEl.appendChild(oChild);\n        }\n      } else {\n        oChild = oXMLDoc.createElement(sName);\n        if (vValue instanceof Object) {\n          loadObjTree(oXMLDoc, oChild, vValue);\n        } else if (vValue !== null && vValue !== true) {\n          oChild.appendChild(oXMLDoc.createTextNode(vValue.toString()));\n        }\n        oParentEl.appendChild(oChild);\n      }\n    }\n\n  }\n\n  this.build = function (oXMLParent, nVerbosity /* optional */, bFreeze /* optional */, bNesteAttributes /* optional */) {\n    var nVerbMask = arguments.length > 1 && typeof nVerbosity === "number" ? nVerbosity & 3 : /* put here the default verbosity level: */ 1;\n    return createObjTree(oXMLParent, nVerbMask, bFreeze || false, arguments.length > 3 ? bNesteAttributes : nVerbMask === 3);\n  };\n\n  this.unbuild = function (oObjTree) {\n    var oNewDoc = document.implementation.createDocument("", "", null);\n    loadObjTree(oNewDoc, oNewDoc, oObjTree);\n    return oNewDoc;\n  };\n\n})();'
}, function(module) {
    module.exports = '/*!\n * VERSION: 1.14.2\n * DATE: 2014-10-29\n * UPDATES AND DOCS AT: http://www.greensock.com\n * \n * Includes all of the following: TweenLite, TweenMax, TimelineLite, TimelineMax, EasePack, CSSPlugin, RoundPropsPlugin, BezierPlugin, AttrPlugin, DirectionalRotationPlugin\n *\n * @license Copyright (c) 2008-2014, GreenSock. All rights reserved.\n * This work is subject to the terms at http://www.greensock.com/terms_of_use.html or for\n * Club GreenSock members, the software agreement that was issued with your membership.\n * \n * @author: Jack Doyle, jack@greensock.com\n **/\nvar _gsScope="undefined"!=typeof module&&module.exports&&"undefined"!=typeof global?global:this||window;(_gsScope._gsQueue||(_gsScope._gsQueue=[])).push(function(){"use strict";_gsScope._gsDefine("TweenMax",["core.Animation","core.SimpleTimeline","TweenLite"],function(t,e,i){var s=function(t){var e,i=[],s=t.length;for(e=0;e!==s;i.push(t[e++]));return i},r=function(t,e,s){i.call(this,t,e,s),this._cycle=0,this._yoyo=this.vars.yoyo===!0,this._repeat=this.vars.repeat||0,this._repeatDelay=this.vars.repeatDelay||0,this._dirty=!0,this.render=r.prototype.render},n=1e-10,a=i._internals,o=a.isSelector,h=a.isArray,l=r.prototype=i.to({},.1,{}),_=[];r.version="1.14.2",l.constructor=r,l.kill()._gc=!1,r.killTweensOf=r.killDelayedCallsTo=i.killTweensOf,r.getTweensOf=i.getTweensOf,r.lagSmoothing=i.lagSmoothing,r.ticker=i.ticker,r.render=i.render,l.invalidate=function(){return this._yoyo=this.vars.yoyo===!0,this._repeat=this.vars.repeat||0,this._repeatDelay=this.vars.repeatDelay||0,this._uncache(!0),i.prototype.invalidate.call(this)},l.updateTo=function(t,e){var s,r=this.ratio,n=this.vars.immediateRender||t.immediateRender;e&&this._startTime<this._timeline._time&&(this._startTime=this._timeline._time,this._uncache(!1),this._gc?this._enabled(!0,!1):this._timeline.insert(this,this._startTime-this._delay));for(s in t)this.vars[s]=t[s];if(this._initted||n)if(e)this._initted=!1;else if(this._gc&&this._enabled(!0,!1),this._notifyPluginsOfEnabled&&this._firstPT&&i._onPluginEvent("_onDisable",this),this._time/this._duration>.998){var a=this._time;this.render(0,!0,!1),this._initted=!1,this.render(a,!0,!1)}else if(this._time>0||n){this._initted=!1,this._init();for(var o,h=1/(1-r),l=this._firstPT;l;)o=l.s+l.c,l.c*=h,l.s=o-l.c,l=l._next}return this},l.render=function(t,e,i){this._initted||0===this._duration&&this.vars.repeat&&this.invalidate();var s,r,o,h,l,u,p,c,f=this._dirty?this.totalDuration():this._totalDuration,m=this._time,d=this._totalTime,g=this._cycle,v=this._duration,y=this._rawPrevTime;if(t>=f?(this._totalTime=f,this._cycle=this._repeat,this._yoyo&&0!==(1&this._cycle)?(this._time=0,this.ratio=this._ease._calcEnd?this._ease.getRatio(0):0):(this._time=v,this.ratio=this._ease._calcEnd?this._ease.getRatio(1):1),this._reversed||(s=!0,r="onComplete"),0===v&&(this._initted||!this.vars.lazy||i)&&(this._startTime===this._timeline._duration&&(t=0),(0===t||0>y||y===n)&&y!==t&&(i=!0,y>n&&(r="onReverseComplete")),this._rawPrevTime=c=!e||t||y===t?t:n)):1e-7>t?(this._totalTime=this._time=this._cycle=0,this.ratio=this._ease._calcEnd?this._ease.getRatio(0):0,(0!==d||0===v&&y>0&&y!==n)&&(r="onReverseComplete",s=this._reversed),0>t&&(this._active=!1,0===v&&(this._initted||!this.vars.lazy||i)&&(y>=0&&(i=!0),this._rawPrevTime=c=!e||t||y===t?t:n)),this._initted||(i=!0)):(this._totalTime=this._time=t,0!==this._repeat&&(h=v+this._repeatDelay,this._cycle=this._totalTime/h>>0,0!==this._cycle&&this._cycle===this._totalTime/h&&this._cycle--,this._time=this._totalTime-this._cycle*h,this._yoyo&&0!==(1&this._cycle)&&(this._time=v-this._time),this._time>v?this._time=v:0>this._time&&(this._time=0)),this._easeType?(l=this._time/v,u=this._easeType,p=this._easePower,(1===u||3===u&&l>=.5)&&(l=1-l),3===u&&(l*=2),1===p?l*=l:2===p?l*=l*l:3===p?l*=l*l*l:4===p&&(l*=l*l*l*l),this.ratio=1===u?1-l:2===u?l:.5>this._time/v?l/2:1-l/2):this.ratio=this._ease.getRatio(this._time/v)),m===this._time&&!i&&g===this._cycle)return d!==this._totalTime&&this._onUpdate&&(e||this._onUpdate.apply(this.vars.onUpdateScope||this,this.vars.onUpdateParams||_)),void 0;if(!this._initted){if(this._init(),!this._initted||this._gc)return;if(!i&&this._firstPT&&(this.vars.lazy!==!1&&this._duration||this.vars.lazy&&!this._duration))return this._time=m,this._totalTime=d,this._rawPrevTime=y,this._cycle=g,a.lazyTweens.push(this),this._lazy=[t,e],void 0;this._time&&!s?this.ratio=this._ease.getRatio(this._time/v):s&&this._ease._calcEnd&&(this.ratio=this._ease.getRatio(0===this._time?0:1))}for(this._lazy!==!1&&(this._lazy=!1),this._active||!this._paused&&this._time!==m&&t>=0&&(this._active=!0),0===d&&(2===this._initted&&t>0&&this._init(),this._startAt&&(t>=0?this._startAt.render(t,e,i):r||(r="_dummyGS")),this.vars.onStart&&(0!==this._totalTime||0===v)&&(e||this.vars.onStart.apply(this.vars.onStartScope||this,this.vars.onStartParams||_))),o=this._firstPT;o;)o.f?o.t[o.p](o.c*this.ratio+o.s):o.t[o.p]=o.c*this.ratio+o.s,o=o._next;this._onUpdate&&(0>t&&this._startAt&&this._startTime&&this._startAt.render(t,e,i),e||(this._totalTime!==d||s)&&this._onUpdate.apply(this.vars.onUpdateScope||this,this.vars.onUpdateParams||_)),this._cycle!==g&&(e||this._gc||this.vars.onRepeat&&this.vars.onRepeat.apply(this.vars.onRepeatScope||this,this.vars.onRepeatParams||_)),r&&(!this._gc||i)&&(0>t&&this._startAt&&!this._onUpdate&&this._startTime&&this._startAt.render(t,e,i),s&&(this._timeline.autoRemoveChildren&&this._enabled(!1,!1),this._active=!1),!e&&this.vars[r]&&this.vars[r].apply(this.vars[r+"Scope"]||this,this.vars[r+"Params"]||_),0===v&&this._rawPrevTime===n&&c!==n&&(this._rawPrevTime=0))},r.to=function(t,e,i){return new r(t,e,i)},r.from=function(t,e,i){return i.runBackwards=!0,i.immediateRender=0!=i.immediateRender,new r(t,e,i)},r.fromTo=function(t,e,i,s){return s.startAt=i,s.immediateRender=0!=s.immediateRender&&0!=i.immediateRender,new r(t,e,s)},r.staggerTo=r.allTo=function(t,e,n,a,l,u,p){a=a||0;var c,f,m,d,g=n.delay||0,v=[],y=function(){n.onComplete&&n.onComplete.apply(n.onCompleteScope||this,arguments),l.apply(p||this,u||_)};for(h(t)||("string"==typeof t&&(t=i.selector(t)||t),o(t)&&(t=s(t))),t=t||[],0>a&&(t=s(t),t.reverse(),a*=-1),c=t.length-1,m=0;c>=m;m++){f={};for(d in n)f[d]=n[d];f.delay=g,m===c&&l&&(f.onComplete=y),v[m]=new r(t[m],e,f),g+=a}return v},r.staggerFrom=r.allFrom=function(t,e,i,s,n,a,o){return i.runBackwards=!0,i.immediateRender=0!=i.immediateRender,r.staggerTo(t,e,i,s,n,a,o)},r.staggerFromTo=r.allFromTo=function(t,e,i,s,n,a,o,h){return s.startAt=i,s.immediateRender=0!=s.immediateRender&&0!=i.immediateRender,r.staggerTo(t,e,s,n,a,o,h)},r.delayedCall=function(t,e,i,s,n){return new r(e,0,{delay:t,onComplete:e,onCompleteParams:i,onCompleteScope:s,onReverseComplete:e,onReverseCompleteParams:i,onReverseCompleteScope:s,immediateRender:!1,useFrames:n,overwrite:0})},r.set=function(t,e){return new r(t,0,e)},r.isTweening=function(t){return i.getTweensOf(t,!0).length>0};var u=function(t,e){for(var s=[],r=0,n=t._first;n;)n instanceof i?s[r++]=n:(e&&(s[r++]=n),s=s.concat(u(n,e)),r=s.length),n=n._next;return s},p=r.getAllTweens=function(e){return u(t._rootTimeline,e).concat(u(t._rootFramesTimeline,e))};r.killAll=function(t,i,s,r){null==i&&(i=!0),null==s&&(s=!0);var n,a,o,h=p(0!=r),l=h.length,_=i&&s&&r;for(o=0;l>o;o++)a=h[o],(_||a instanceof e||(n=a.target===a.vars.onComplete)&&s||i&&!n)&&(t?a.totalTime(a._reversed?0:a.totalDuration()):a._enabled(!1,!1))},r.killChildTweensOf=function(t,e){if(null!=t){var n,l,_,u,p,c=a.tweenLookup;if("string"==typeof t&&(t=i.selector(t)||t),o(t)&&(t=s(t)),h(t))for(u=t.length;--u>-1;)r.killChildTweensOf(t[u],e);else{n=[];for(_ in c)for(l=c[_].target.parentNode;l;)l===t&&(n=n.concat(c[_].tweens)),l=l.parentNode;for(p=n.length,u=0;p>u;u++)e&&n[u].totalTime(n[u].totalDuration()),n[u]._enabled(!1,!1)}}};var c=function(t,i,s,r){i=i!==!1,s=s!==!1,r=r!==!1;for(var n,a,o=p(r),h=i&&s&&r,l=o.length;--l>-1;)a=o[l],(h||a instanceof e||(n=a.target===a.vars.onComplete)&&s||i&&!n)&&a.paused(t)};return r.pauseAll=function(t,e,i){c(!0,t,e,i)},r.resumeAll=function(t,e,i){c(!1,t,e,i)},r.globalTimeScale=function(e){var s=t._rootTimeline,r=i.ticker.time;return arguments.length?(e=e||n,s._startTime=r-(r-s._startTime)*s._timeScale/e,s=t._rootFramesTimeline,r=i.ticker.frame,s._startTime=r-(r-s._startTime)*s._timeScale/e,s._timeScale=t._rootTimeline._timeScale=e,e):s._timeScale},l.progress=function(t){return arguments.length?this.totalTime(this.duration()*(this._yoyo&&0!==(1&this._cycle)?1-t:t)+this._cycle*(this._duration+this._repeatDelay),!1):this._time/this.duration()},l.totalProgress=function(t){return arguments.length?this.totalTime(this.totalDuration()*t,!1):this._totalTime/this.totalDuration()},l.time=function(t,e){return arguments.length?(this._dirty&&this.totalDuration(),t>this._duration&&(t=this._duration),this._yoyo&&0!==(1&this._cycle)?t=this._duration-t+this._cycle*(this._duration+this._repeatDelay):0!==this._repeat&&(t+=this._cycle*(this._duration+this._repeatDelay)),this.totalTime(t,e)):this._time},l.duration=function(e){return arguments.length?t.prototype.duration.call(this,e):this._duration},l.totalDuration=function(t){return arguments.length?-1===this._repeat?this:this.duration((t-this._repeat*this._repeatDelay)/(this._repeat+1)):(this._dirty&&(this._totalDuration=-1===this._repeat?999999999999:this._duration*(this._repeat+1)+this._repeatDelay*this._repeat,this._dirty=!1),this._totalDuration)},l.repeat=function(t){return arguments.length?(this._repeat=t,this._uncache(!0)):this._repeat},l.repeatDelay=function(t){return arguments.length?(this._repeatDelay=t,this._uncache(!0)):this._repeatDelay},l.yoyo=function(t){return arguments.length?(this._yoyo=t,this):this._yoyo},r},!0),_gsScope._gsDefine("TimelineLite",["core.Animation","core.SimpleTimeline","TweenLite"],function(t,e,i){var s=function(t){e.call(this,t),this._labels={},this.autoRemoveChildren=this.vars.autoRemoveChildren===!0,this.smoothChildTiming=this.vars.smoothChildTiming===!0,this._sortChildren=!0,this._onUpdate=this.vars.onUpdate;var i,s,r=this.vars;for(s in r)i=r[s],o(i)&&-1!==i.join("").indexOf("{self}")&&(r[s]=this._swapSelfInParams(i));o(r.tweens)&&this.add(r.tweens,0,r.align,r.stagger)},r=1e-10,n=i._internals,a=n.isSelector,o=n.isArray,h=n.lazyTweens,l=n.lazyRender,_=[],u=_gsScope._gsDefine.globals,p=function(t){var e,i={};for(e in t)i[e]=t[e];return i},c=function(t,e,i,s){var r=t._timeline._totalTime;(e||!this._forcingPlayhead)&&(t._timeline.pause(t._startTime),e&&e.apply(s||t._timeline,i||_),this._forcingPlayhead&&t._timeline.seek(r))},f=function(t){var e,i=[],s=t.length;for(e=0;e!==s;i.push(t[e++]));return i},m=s.prototype=new e;return s.version="1.14.2",m.constructor=s,m.kill()._gc=m._forcingPlayhead=!1,m.to=function(t,e,s,r){var n=s.repeat&&u.TweenMax||i;return e?this.add(new n(t,e,s),r):this.set(t,s,r)},m.from=function(t,e,s,r){return this.add((s.repeat&&u.TweenMax||i).from(t,e,s),r)},m.fromTo=function(t,e,s,r,n){var a=r.repeat&&u.TweenMax||i;return e?this.add(a.fromTo(t,e,s,r),n):this.set(t,r,n)},m.staggerTo=function(t,e,r,n,o,h,l,_){var u,c=new s({onComplete:h,onCompleteParams:l,onCompleteScope:_,smoothChildTiming:this.smoothChildTiming});for("string"==typeof t&&(t=i.selector(t)||t),t=t||[],a(t)&&(t=f(t)),n=n||0,0>n&&(t=f(t),t.reverse(),n*=-1),u=0;t.length>u;u++)r.startAt&&(r.startAt=p(r.startAt)),c.to(t[u],e,p(r),u*n);return this.add(c,o)},m.staggerFrom=function(t,e,i,s,r,n,a,o){return i.immediateRender=0!=i.immediateRender,i.runBackwards=!0,this.staggerTo(t,e,i,s,r,n,a,o)},m.staggerFromTo=function(t,e,i,s,r,n,a,o,h){return s.startAt=i,s.immediateRender=0!=s.immediateRender&&0!=i.immediateRender,this.staggerTo(t,e,s,r,n,a,o,h)},m.call=function(t,e,s,r){return this.add(i.delayedCall(0,t,e,s),r)},m.set=function(t,e,s){return s=this._parseTimeOrLabel(s,0,!0),null==e.immediateRender&&(e.immediateRender=s===this._time&&!this._paused),this.add(new i(t,0,e),s)},s.exportRoot=function(t,e){t=t||{},null==t.smoothChildTiming&&(t.smoothChildTiming=!0);var r,n,a=new s(t),o=a._timeline;for(null==e&&(e=!0),o._remove(a,!0),a._startTime=0,a._rawPrevTime=a._time=a._totalTime=o._time,r=o._first;r;)n=r._next,e&&r instanceof i&&r.target===r.vars.onComplete||a.add(r,r._startTime-r._delay),r=n;return o.add(a,0),a},m.add=function(r,n,a,h){var l,_,u,p,c,f;if("number"!=typeof n&&(n=this._parseTimeOrLabel(n,0,!0,r)),!(r instanceof t)){if(r instanceof Array||r&&r.push&&o(r)){for(a=a||"normal",h=h||0,l=n,_=r.length,u=0;_>u;u++)o(p=r[u])&&(p=new s({tweens:p})),this.add(p,l),"string"!=typeof p&&"function"!=typeof p&&("sequence"===a?l=p._startTime+p.totalDuration()/p._timeScale:"start"===a&&(p._startTime-=p.delay())),l+=h;return this._uncache(!0)}if("string"==typeof r)return this.addLabel(r,n);if("function"!=typeof r)throw"Cannot add "+r+" into the timeline; it is not a tween, timeline, function, or string.";r=i.delayedCall(0,r)}if(e.prototype.add.call(this,r,n),(this._gc||this._time===this._duration)&&!this._paused&&this._duration<this.duration())for(c=this,f=c.rawTime()>r._startTime;c._timeline;)f&&c._timeline.smoothChildTiming?c.totalTime(c._totalTime,!0):c._gc&&c._enabled(!0,!1),c=c._timeline;return this},m.remove=function(e){if(e instanceof t)return this._remove(e,!1);if(e instanceof Array||e&&e.push&&o(e)){for(var i=e.length;--i>-1;)this.remove(e[i]);return this}return"string"==typeof e?this.removeLabel(e):this.kill(null,e)},m._remove=function(t,i){e.prototype._remove.call(this,t,i);var s=this._last;return s?this._time>s._startTime+s._totalDuration/s._timeScale&&(this._time=this.duration(),this._totalTime=this._totalDuration):this._time=this._totalTime=this._duration=this._totalDuration=0,this},m.append=function(t,e){return this.add(t,this._parseTimeOrLabel(null,e,!0,t))},m.insert=m.insertMultiple=function(t,e,i,s){return this.add(t,e||0,i,s)},m.appendMultiple=function(t,e,i,s){return this.add(t,this._parseTimeOrLabel(null,e,!0,t),i,s)},m.addLabel=function(t,e){return this._labels[t]=this._parseTimeOrLabel(e),this},m.addPause=function(t,e,i,s){return this.call(c,["{self}",e,i,s],this,t)},m.removeLabel=function(t){return delete this._labels[t],this},m.getLabelTime=function(t){return null!=this._labels[t]?this._labels[t]:-1},m._parseTimeOrLabel=function(e,i,s,r){var n;if(r instanceof t&&r.timeline===this)this.remove(r);else if(r&&(r instanceof Array||r.push&&o(r)))for(n=r.length;--n>-1;)r[n]instanceof t&&r[n].timeline===this&&this.remove(r[n]);if("string"==typeof i)return this._parseTimeOrLabel(i,s&&"number"==typeof e&&null==this._labels[i]?e-this.duration():0,s);if(i=i||0,"string"!=typeof e||!isNaN(e)&&null==this._labels[e])null==e&&(e=this.duration());else{if(n=e.indexOf("="),-1===n)return null==this._labels[e]?s?this._labels[e]=this.duration()+i:i:this._labels[e]+i;i=parseInt(e.charAt(n-1)+"1",10)*Number(e.substr(n+1)),e=n>1?this._parseTimeOrLabel(e.substr(0,n-1),0,s):this.duration()}return Number(e)+i},m.seek=function(t,e){return this.totalTime("number"==typeof t?t:this._parseTimeOrLabel(t),e!==!1)},m.stop=function(){return this.paused(!0)},m.gotoAndPlay=function(t,e){return this.play(t,e)},m.gotoAndStop=function(t,e){return this.pause(t,e)},m.render=function(t,e,i){this._gc&&this._enabled(!0,!1);var s,n,a,o,u,p=this._dirty?this.totalDuration():this._totalDuration,c=this._time,f=this._startTime,m=this._timeScale,d=this._paused;if(t>=p?(this._totalTime=this._time=p,this._reversed||this._hasPausedChild()||(n=!0,o="onComplete",0===this._duration&&(0===t||0>this._rawPrevTime||this._rawPrevTime===r)&&this._rawPrevTime!==t&&this._first&&(u=!0,this._rawPrevTime>r&&(o="onReverseComplete"))),this._rawPrevTime=this._duration||!e||t||this._rawPrevTime===t?t:r,t=p+1e-4):1e-7>t?(this._totalTime=this._time=0,(0!==c||0===this._duration&&this._rawPrevTime!==r&&(this._rawPrevTime>0||0>t&&this._rawPrevTime>=0))&&(o="onReverseComplete",n=this._reversed),0>t?(this._active=!1,this._rawPrevTime>=0&&this._first&&(u=!0),this._rawPrevTime=t):(this._rawPrevTime=this._duration||!e||t||this._rawPrevTime===t?t:r,t=0,this._initted||(u=!0))):this._totalTime=this._time=this._rawPrevTime=t,this._time!==c&&this._first||i||u){if(this._initted||(this._initted=!0),this._active||!this._paused&&this._time!==c&&t>0&&(this._active=!0),0===c&&this.vars.onStart&&0!==this._time&&(e||this.vars.onStart.apply(this.vars.onStartScope||this,this.vars.onStartParams||_)),this._time>=c)for(s=this._first;s&&(a=s._next,!this._paused||d);)(s._active||s._startTime<=this._time&&!s._paused&&!s._gc)&&(s._reversed?s.render((s._dirty?s.totalDuration():s._totalDuration)-(t-s._startTime)*s._timeScale,e,i):s.render((t-s._startTime)*s._timeScale,e,i)),s=a;else for(s=this._last;s&&(a=s._prev,!this._paused||d);)(s._active||c>=s._startTime&&!s._paused&&!s._gc)&&(s._reversed?s.render((s._dirty?s.totalDuration():s._totalDuration)-(t-s._startTime)*s._timeScale,e,i):s.render((t-s._startTime)*s._timeScale,e,i)),s=a;this._onUpdate&&(e||(h.length&&l(),this._onUpdate.apply(this.vars.onUpdateScope||this,this.vars.onUpdateParams||_))),o&&(this._gc||(f===this._startTime||m!==this._timeScale)&&(0===this._time||p>=this.totalDuration())&&(n&&(h.length&&l(),this._timeline.autoRemoveChildren&&this._enabled(!1,!1),this._active=!1),!e&&this.vars[o]&&this.vars[o].apply(this.vars[o+"Scope"]||this,this.vars[o+"Params"]||_)))}},m._hasPausedChild=function(){for(var t=this._first;t;){if(t._paused||t instanceof s&&t._hasPausedChild())return!0;t=t._next}return!1},m.getChildren=function(t,e,s,r){r=r||-9999999999;for(var n=[],a=this._first,o=0;a;)r>a._startTime||(a instanceof i?e!==!1&&(n[o++]=a):(s!==!1&&(n[o++]=a),t!==!1&&(n=n.concat(a.getChildren(!0,e,s)),o=n.length))),a=a._next;return n},m.getTweensOf=function(t,e){var s,r,n=this._gc,a=[],o=0;for(n&&this._enabled(!0,!0),s=i.getTweensOf(t),r=s.length;--r>-1;)(s[r].timeline===this||e&&this._contains(s[r]))&&(a[o++]=s[r]);return n&&this._enabled(!1,!0),a},m.recent=function(){return this._recent},m._contains=function(t){for(var e=t.timeline;e;){if(e===this)return!0;e=e.timeline}return!1},m.shiftChildren=function(t,e,i){i=i||0;for(var s,r=this._first,n=this._labels;r;)r._startTime>=i&&(r._startTime+=t),r=r._next;if(e)for(s in n)n[s]>=i&&(n[s]+=t);return this._uncache(!0)},m._kill=function(t,e){if(!t&&!e)return this._enabled(!1,!1);for(var i=e?this.getTweensOf(e):this.getChildren(!0,!0,!1),s=i.length,r=!1;--s>-1;)i[s]._kill(t,e)&&(r=!0);return r},m.clear=function(t){var e=this.getChildren(!1,!0,!0),i=e.length;for(this._time=this._totalTime=0;--i>-1;)e[i]._enabled(!1,!1);return t!==!1&&(this._labels={}),this._uncache(!0)},m.invalidate=function(){for(var e=this._first;e;)e.invalidate(),e=e._next;return t.prototype.invalidate.call(this)},m._enabled=function(t,i){if(t===this._gc)for(var s=this._first;s;)s._enabled(t,!0),s=s._next;return e.prototype._enabled.call(this,t,i)},m.totalTime=function(){this._forcingPlayhead=!0;var e=t.prototype.totalTime.apply(this,arguments);return this._forcingPlayhead=!1,e},m.duration=function(t){return arguments.length?(0!==this.duration()&&0!==t&&this.timeScale(this._duration/t),this):(this._dirty&&this.totalDuration(),this._duration)},m.totalDuration=function(t){if(!arguments.length){if(this._dirty){for(var e,i,s=0,r=this._last,n=999999999999;r;)e=r._prev,r._dirty&&r.totalDuration(),r._startTime>n&&this._sortChildren&&!r._paused?this.add(r,r._startTime-r._delay):n=r._startTime,0>r._startTime&&!r._paused&&(s-=r._startTime,this._timeline.smoothChildTiming&&(this._startTime+=r._startTime/this._timeScale),this.shiftChildren(-r._startTime,!1,-9999999999),n=0),i=r._startTime+r._totalDuration/r._timeScale,i>s&&(s=i),r=e;this._duration=this._totalDuration=s,this._dirty=!1}return this._totalDuration}return 0!==this.totalDuration()&&0!==t&&this.timeScale(this._totalDuration/t),this},m.usesFrames=function(){for(var e=this._timeline;e._timeline;)e=e._timeline;return e===t._rootFramesTimeline},m.rawTime=function(){return this._paused?this._totalTime:(this._timeline.rawTime()-this._startTime)*this._timeScale},s},!0),_gsScope._gsDefine("TimelineMax",["TimelineLite","TweenLite","easing.Ease"],function(t,e,i){var s=function(e){t.call(this,e),this._repeat=this.vars.repeat||0,this._repeatDelay=this.vars.repeatDelay||0,this._cycle=0,this._yoyo=this.vars.yoyo===!0,this._dirty=!0},r=1e-10,n=[],a=e._internals,o=a.lazyTweens,h=a.lazyRender,l=new i(null,null,1,0),_=s.prototype=new t;return _.constructor=s,_.kill()._gc=!1,s.version="1.14.2",_.invalidate=function(){return this._yoyo=this.vars.yoyo===!0,this._repeat=this.vars.repeat||0,this._repeatDelay=this.vars.repeatDelay||0,this._uncache(!0),t.prototype.invalidate.call(this)},_.addCallback=function(t,i,s,r){return this.add(e.delayedCall(0,t,s,r),i)},_.removeCallback=function(t,e){if(t)if(null==e)this._kill(null,t);else for(var i=this.getTweensOf(t,!1),s=i.length,r=this._parseTimeOrLabel(e);--s>-1;)i[s]._startTime===r&&i[s]._enabled(!1,!1);return this},_.tweenTo=function(t,i){i=i||{};var s,r,a,o={ease:l,overwrite:i.delay?2:1,useFrames:this.usesFrames(),immediateRender:!1};for(r in i)o[r]=i[r];return o.time=this._parseTimeOrLabel(t),s=Math.abs(Number(o.time)-this._time)/this._timeScale||.001,a=new e(this,s,o),o.onStart=function(){a.target.paused(!0),a.vars.time!==a.target.time()&&s===a.duration()&&a.duration(Math.abs(a.vars.time-a.target.time())/a.target._timeScale),i.onStart&&i.onStart.apply(i.onStartScope||a,i.onStartParams||n)},a},_.tweenFromTo=function(t,e,i){i=i||{},t=this._parseTimeOrLabel(t),i.startAt={onComplete:this.seek,onCompleteParams:[t],onCompleteScope:this},i.immediateRender=i.immediateRender!==!1;var s=this.tweenTo(e,i);return s.duration(Math.abs(s.vars.time-t)/this._timeScale||.001)},_.render=function(t,e,i){this._gc&&this._enabled(!0,!1);var s,a,l,_,u,p,c=this._dirty?this.totalDuration():this._totalDuration,f=this._duration,m=this._time,d=this._totalTime,g=this._startTime,v=this._timeScale,y=this._rawPrevTime,T=this._paused,w=this._cycle;if(t>=c?(this._locked||(this._totalTime=c,this._cycle=this._repeat),this._reversed||this._hasPausedChild()||(a=!0,_="onComplete",0===this._duration&&(0===t||0>y||y===r)&&y!==t&&this._first&&(u=!0,y>r&&(_="onReverseComplete"))),this._rawPrevTime=this._duration||!e||t||this._rawPrevTime===t?t:r,this._yoyo&&0!==(1&this._cycle)?this._time=t=0:(this._time=f,t=f+1e-4)):1e-7>t?(this._locked||(this._totalTime=this._cycle=0),this._time=0,(0!==m||0===f&&y!==r&&(y>0||0>t&&y>=0)&&!this._locked)&&(_="onReverseComplete",a=this._reversed),0>t?(this._active=!1,y>=0&&this._first&&(u=!0),this._rawPrevTime=t):(this._rawPrevTime=f||!e||t||this._rawPrevTime===t?t:r,t=0,this._initted||(u=!0))):(0===f&&0>y&&(u=!0),this._time=this._rawPrevTime=t,this._locked||(this._totalTime=t,0!==this._repeat&&(p=f+this._repeatDelay,this._cycle=this._totalTime/p>>0,0!==this._cycle&&this._cycle===this._totalTime/p&&this._cycle--,this._time=this._totalTime-this._cycle*p,this._yoyo&&0!==(1&this._cycle)&&(this._time=f-this._time),this._time>f?(this._time=f,t=f+1e-4):0>this._time?this._time=t=0:t=this._time))),this._cycle!==w&&!this._locked){var x=this._yoyo&&0!==(1&w),b=x===(this._yoyo&&0!==(1&this._cycle)),P=this._totalTime,S=this._cycle,k=this._rawPrevTime,R=this._time;if(this._totalTime=w*f,w>this._cycle?x=!x:this._totalTime+=f,this._time=m,this._rawPrevTime=0===f?y-1e-4:y,this._cycle=w,this._locked=!0,m=x?0:f,this.render(m,e,0===f),e||this._gc||this.vars.onRepeat&&this.vars.onRepeat.apply(this.vars.onRepeatScope||this,this.vars.onRepeatParams||n),b&&(m=x?f+1e-4:-1e-4,this.render(m,!0,!1)),this._locked=!1,this._paused&&!T)return;this._time=R,this._totalTime=P,this._cycle=S,this._rawPrevTime=k}if(!(this._time!==m&&this._first||i||u))return d!==this._totalTime&&this._onUpdate&&(e||this._onUpdate.apply(this.vars.onUpdateScope||this,this.vars.onUpdateParams||n)),void 0;if(this._initted||(this._initted=!0),this._active||!this._paused&&this._totalTime!==d&&t>0&&(this._active=!0),0===d&&this.vars.onStart&&0!==this._totalTime&&(e||this.vars.onStart.apply(this.vars.onStartScope||this,this.vars.onStartParams||n)),this._time>=m)for(s=this._first;s&&(l=s._next,!this._paused||T);)(s._active||s._startTime<=this._time&&!s._paused&&!s._gc)&&(s._reversed?s.render((s._dirty?s.totalDuration():s._totalDuration)-(t-s._startTime)*s._timeScale,e,i):s.render((t-s._startTime)*s._timeScale,e,i)),s=l;else for(s=this._last;s&&(l=s._prev,!this._paused||T);)(s._active||m>=s._startTime&&!s._paused&&!s._gc)&&(s._reversed?s.render((s._dirty?s.totalDuration():s._totalDuration)-(t-s._startTime)*s._timeScale,e,i):s.render((t-s._startTime)*s._timeScale,e,i)),s=l;this._onUpdate&&(e||(o.length&&h(),this._onUpdate.apply(this.vars.onUpdateScope||this,this.vars.onUpdateParams||n))),_&&(this._locked||this._gc||(g===this._startTime||v!==this._timeScale)&&(0===this._time||c>=this.totalDuration())&&(a&&(o.length&&h(),this._timeline.autoRemoveChildren&&this._enabled(!1,!1),this._active=!1),!e&&this.vars[_]&&this.vars[_].apply(this.vars[_+"Scope"]||this,this.vars[_+"Params"]||n)))},_.getActive=function(t,e,i){null==t&&(t=!0),null==e&&(e=!0),null==i&&(i=!1);var s,r,n=[],a=this.getChildren(t,e,i),o=0,h=a.length;for(s=0;h>s;s++)r=a[s],r.isActive()&&(n[o++]=r);return n},_.getLabelAfter=function(t){t||0!==t&&(t=this._time);var e,i=this.getLabelsArray(),s=i.length;for(e=0;s>e;e++)if(i[e].time>t)return i[e].name;return null},_.getLabelBefore=function(t){null==t&&(t=this._time);for(var e=this.getLabelsArray(),i=e.length;--i>-1;)if(t>e[i].time)return e[i].name;return null},_.getLabelsArray=function(){var t,e=[],i=0;for(t in this._labels)e[i++]={time:this._labels[t],name:t};return e.sort(function(t,e){return t.time-e.time}),e},_.progress=function(t,e){return arguments.length?this.totalTime(this.duration()*(this._yoyo&&0!==(1&this._cycle)?1-t:t)+this._cycle*(this._duration+this._repeatDelay),e):this._time/this.duration()},_.totalProgress=function(t,e){return arguments.length?this.totalTime(this.totalDuration()*t,e):this._totalTime/this.totalDuration()},_.totalDuration=function(e){return arguments.length?-1===this._repeat?this:this.duration((e-this._repeat*this._repeatDelay)/(this._repeat+1)):(this._dirty&&(t.prototype.totalDuration.call(this),this._totalDuration=-1===this._repeat?999999999999:this._duration*(this._repeat+1)+this._repeatDelay*this._repeat),this._totalDuration)},_.time=function(t,e){return arguments.length?(this._dirty&&this.totalDuration(),t>this._duration&&(t=this._duration),this._yoyo&&0!==(1&this._cycle)?t=this._duration-t+this._cycle*(this._duration+this._repeatDelay):0!==this._repeat&&(t+=this._cycle*(this._duration+this._repeatDelay)),this.totalTime(t,e)):this._time},_.repeat=function(t){return arguments.length?(this._repeat=t,this._uncache(!0)):this._repeat},_.repeatDelay=function(t){return arguments.length?(this._repeatDelay=t,this._uncache(!0)):this._repeatDelay},_.yoyo=function(t){return arguments.length?(this._yoyo=t,this):this._yoyo},_.currentLabel=function(t){return arguments.length?this.seek(t,!0):this.getLabelBefore(this._time+1e-8)},s},!0),function(){var t=180/Math.PI,e=[],i=[],s=[],r={},n=function(t,e,i,s){this.a=t,this.b=e,this.c=i,this.d=s,this.da=s-t,this.ca=i-t,this.ba=e-t},a=",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",o=function(t,e,i,s){var r={a:t},n={},a={},o={c:s},h=(t+e)/2,l=(e+i)/2,_=(i+s)/2,u=(h+l)/2,p=(l+_)/2,c=(p-u)/8;return r.b=h+(t-h)/4,n.b=u+c,r.c=n.a=(r.b+n.b)/2,n.c=a.a=(u+p)/2,a.b=p-c,o.b=_+(s-_)/4,a.c=o.a=(a.b+o.b)/2,[r,n,a,o]},h=function(t,r,n,a,h){var l,_,u,p,c,f,m,d,g,v,y,T,w,x=t.length-1,b=0,P=t[0].a;for(l=0;x>l;l++)c=t[b],_=c.a,u=c.d,p=t[b+1].d,h?(y=e[l],T=i[l],w=.25*(T+y)*r/(a?.5:s[l]||.5),f=u-(u-_)*(a?.5*r:0!==y?w/y:0),m=u+(p-u)*(a?.5*r:0!==T?w/T:0),d=u-(f+((m-f)*(3*y/(y+T)+.5)/4||0))):(f=u-.5*(u-_)*r,m=u+.5*(p-u)*r,d=u-(f+m)/2),f+=d,m+=d,c.c=g=f,c.b=0!==l?P:P=c.a+.6*(c.c-c.a),c.da=u-_,c.ca=g-_,c.ba=P-_,n?(v=o(_,P,g,u),t.splice(b,1,v[0],v[1],v[2],v[3]),b+=4):b++,P=m;c=t[b],c.b=P,c.c=P+.4*(c.d-P),c.da=c.d-c.a,c.ca=c.c-c.a,c.ba=P-c.a,n&&(v=o(c.a,P,c.c,c.d),t.splice(b,1,v[0],v[1],v[2],v[3]))},l=function(t,s,r,a){var o,h,l,_,u,p,c=[];if(a)for(t=[a].concat(t),h=t.length;--h>-1;)"string"==typeof(p=t[h][s])&&"="===p.charAt(1)&&(t[h][s]=a[s]+Number(p.charAt(0)+p.substr(2)));if(o=t.length-2,0>o)return c[0]=new n(t[0][s],0,0,t[-1>o?0:1][s]),c;for(h=0;o>h;h++)l=t[h][s],_=t[h+1][s],c[h]=new n(l,0,0,_),r&&(u=t[h+2][s],e[h]=(e[h]||0)+(_-l)*(_-l),i[h]=(i[h]||0)+(u-_)*(u-_));return c[h]=new n(t[h][s],0,0,t[h+1][s]),c},_=function(t,n,o,_,u,p){var c,f,m,d,g,v,y,T,w={},x=[],b=p||t[0];u="string"==typeof u?","+u+",":a,null==n&&(n=1);for(f in t[0])x.push(f);if(t.length>1){for(T=t[t.length-1],y=!0,c=x.length;--c>-1;)if(f=x[c],Math.abs(b[f]-T[f])>.05){y=!1;break}y&&(t=t.concat(),p&&t.unshift(p),t.push(t[1]),p=t[t.length-3])}for(e.length=i.length=s.length=0,c=x.length;--c>-1;)f=x[c],r[f]=-1!==u.indexOf(","+f+","),w[f]=l(t,f,r[f],p);for(c=e.length;--c>-1;)e[c]=Math.sqrt(e[c]),i[c]=Math.sqrt(i[c]);if(!_){for(c=x.length;--c>-1;)if(r[f])for(m=w[x[c]],v=m.length-1,d=0;v>d;d++)g=m[d+1].da/i[d]+m[d].da/e[d],s[d]=(s[d]||0)+g*g;for(c=s.length;--c>-1;)s[c]=Math.sqrt(s[c])}for(c=x.length,d=o?4:1;--c>-1;)f=x[c],m=w[f],h(m,n,o,_,r[f]),y&&(m.splice(0,d),m.splice(m.length-d,d));return w},u=function(t,e,i){e=e||"soft";var s,r,a,o,h,l,_,u,p,c,f,m={},d="cubic"===e?3:2,g="soft"===e,v=[];if(g&&i&&(t=[i].concat(t)),null==t||d+1>t.length)throw"invalid Bezier data";for(p in t[0])v.push(p);for(l=v.length;--l>-1;){for(p=v[l],m[p]=h=[],c=0,u=t.length,_=0;u>_;_++)s=null==i?t[_][p]:"string"==typeof(f=t[_][p])&&"="===f.charAt(1)?i[p]+Number(f.charAt(0)+f.substr(2)):Number(f),g&&_>1&&u-1>_&&(h[c++]=(s+h[c-2])/2),h[c++]=s;for(u=c-d+1,c=0,_=0;u>_;_+=d)s=h[_],r=h[_+1],a=h[_+2],o=2===d?0:h[_+3],h[c++]=f=3===d?new n(s,r,a,o):new n(s,(2*r+s)/3,(2*r+a)/3,a);h.length=c}return m},p=function(t,e,i){for(var s,r,n,a,o,h,l,_,u,p,c,f=1/i,m=t.length;--m>-1;)for(p=t[m],n=p.a,a=p.d-n,o=p.c-n,h=p.b-n,s=r=0,_=1;i>=_;_++)l=f*_,u=1-l,s=r-(r=(l*l*a+3*u*(l*o+u*h))*l),c=m*i+_-1,e[c]=(e[c]||0)+s*s},c=function(t,e){e=e>>0||6;var i,s,r,n,a=[],o=[],h=0,l=0,_=e-1,u=[],c=[];for(i in t)p(t[i],a,e);for(r=a.length,s=0;r>s;s++)h+=Math.sqrt(a[s]),n=s%e,c[n]=h,n===_&&(l+=h,n=s/e>>0,u[n]=c,o[n]=l,h=0,c=[]);return{length:l,lengths:o,segments:u}},f=_gsScope._gsDefine.plugin({propName:"bezier",priority:-1,version:"1.3.3",API:2,global:!0,init:function(t,e,i){this._target=t,e instanceof Array&&(e={values:e}),this._func={},this._round={},this._props=[],this._timeRes=null==e.timeResolution?6:parseInt(e.timeResolution,10);var s,r,n,a,o,h=e.values||[],l={},p=h[0],f=e.autoRotate||i.vars.orientToBezier;this._autoRotate=f?f instanceof Array?f:[["x","y","rotation",f===!0?0:Number(f)||0]]:null;for(s in p)this._props.push(s);for(n=this._props.length;--n>-1;)s=this._props[n],this._overwriteProps.push(s),r=this._func[s]="function"==typeof t[s],l[s]=r?t[s.indexOf("set")||"function"!=typeof t["get"+s.substr(3)]?s:"get"+s.substr(3)]():parseFloat(t[s]),o||l[s]!==h[0][s]&&(o=l);if(this._beziers="cubic"!==e.type&&"quadratic"!==e.type&&"soft"!==e.type?_(h,isNaN(e.curviness)?1:e.curviness,!1,"thruBasic"===e.type,e.correlate,o):u(h,e.type,l),this._segCount=this._beziers[s].length,this._timeRes){var m=c(this._beziers,this._timeRes);this._length=m.length,this._lengths=m.lengths,this._segments=m.segments,this._l1=this._li=this._s1=this._si=0,this._l2=this._lengths[0],this._curSeg=this._segments[0],this._s2=this._curSeg[0],this._prec=1/this._curSeg.length}if(f=this._autoRotate)for(this._initialRotations=[],f[0]instanceof Array||(this._autoRotate=f=[f]),n=f.length;--n>-1;){for(a=0;3>a;a++)s=f[n][a],this._func[s]="function"==typeof t[s]?t[s.indexOf("set")||"function"!=typeof t["get"+s.substr(3)]?s:"get"+s.substr(3)]:!1;s=f[n][2],this._initialRotations[n]=this._func[s]?this._func[s].call(this._target):this._target[s]}return this._startRatio=i.vars.runBackwards?1:0,!0},set:function(e){var i,s,r,n,a,o,h,l,_,u,p=this._segCount,c=this._func,f=this._target,m=e!==this._startRatio;if(this._timeRes){if(_=this._lengths,u=this._curSeg,e*=this._length,r=this._li,e>this._l2&&p-1>r){for(l=p-1;l>r&&e>=(this._l2=_[++r]););this._l1=_[r-1],this._li=r,this._curSeg=u=this._segments[r],this._s2=u[this._s1=this._si=0]}else if(this._l1>e&&r>0){for(;r>0&&(this._l1=_[--r])>=e;);0===r&&this._l1>e?this._l1=0:r++,this._l2=_[r],this._li=r,this._curSeg=u=this._segments[r],this._s1=u[(this._si=u.length-1)-1]||0,this._s2=u[this._si]}if(i=r,e-=this._l1,r=this._si,e>this._s2&&u.length-1>r){for(l=u.length-1;l>r&&e>=(this._s2=u[++r]););this._s1=u[r-1],this._si=r\n}else if(this._s1>e&&r>0){for(;r>0&&(this._s1=u[--r])>=e;);0===r&&this._s1>e?this._s1=0:r++,this._s2=u[r],this._si=r}o=(r+(e-this._s1)/(this._s2-this._s1))*this._prec}else i=0>e?0:e>=1?p-1:p*e>>0,o=(e-i*(1/p))*p;for(s=1-o,r=this._props.length;--r>-1;)n=this._props[r],a=this._beziers[n][i],h=(o*o*a.da+3*s*(o*a.ca+s*a.ba))*o+a.a,this._round[n]&&(h=Math.round(h)),c[n]?f[n](h):f[n]=h;if(this._autoRotate){var d,g,v,y,T,w,x,b=this._autoRotate;for(r=b.length;--r>-1;)n=b[r][2],w=b[r][3]||0,x=b[r][4]===!0?1:t,a=this._beziers[b[r][0]],d=this._beziers[b[r][1]],a&&d&&(a=a[i],d=d[i],g=a.a+(a.b-a.a)*o,y=a.b+(a.c-a.b)*o,g+=(y-g)*o,y+=(a.c+(a.d-a.c)*o-y)*o,v=d.a+(d.b-d.a)*o,T=d.b+(d.c-d.b)*o,v+=(T-v)*o,T+=(d.c+(d.d-d.c)*o-T)*o,h=m?Math.atan2(T-v,y-g)*x+w:this._initialRotations[r],c[n]?f[n](h):f[n]=h)}}}),m=f.prototype;f.bezierThrough=_,f.cubicToQuadratic=o,f._autoCSS=!0,f.quadraticToCubic=function(t,e,i){return new n(t,(2*e+t)/3,(2*e+i)/3,i)},f._cssRegister=function(){var t=_gsScope._gsDefine.globals.CSSPlugin;if(t){var e=t._internals,i=e._parseToProxy,s=e._setPluginRatio,r=e.CSSPropTween;e._registerComplexSpecialProp("bezier",{parser:function(t,e,n,a,o,h){e instanceof Array&&(e={values:e}),h=new f;var l,_,u,p=e.values,c=p.length-1,m=[],d={};if(0>c)return o;for(l=0;c>=l;l++)u=i(t,p[l],a,o,h,c!==l),m[l]=u.end;for(_ in e)d[_]=e[_];return d.values=m,o=new r(t,"bezier",0,0,u.pt,2),o.data=u,o.plugin=h,o.setRatio=s,0===d.autoRotate&&(d.autoRotate=!0),!d.autoRotate||d.autoRotate instanceof Array||(l=d.autoRotate===!0?0:Number(d.autoRotate),d.autoRotate=null!=u.end.left?[["left","top","rotation",l,!1]]:null!=u.end.x?[["x","y","rotation",l,!1]]:!1),d.autoRotate&&(a._transform||a._enableTransforms(!1),u.autoRotate=a._target._gsTransform),h._onInitTween(u.proxy,d,a._tween),o}})}},m._roundProps=function(t,e){for(var i=this._overwriteProps,s=i.length;--s>-1;)(t[i[s]]||t.bezier||t.bezierThrough)&&(this._round[i[s]]=e)},m._kill=function(t){var e,i,s=this._props;for(e in this._beziers)if(e in t)for(delete this._beziers[e],delete this._func[e],i=s.length;--i>-1;)s[i]===e&&s.splice(i,1);return this._super._kill.call(this,t)}}(),_gsScope._gsDefine("plugins.CSSPlugin",["plugins.TweenPlugin","TweenLite"],function(t,e){var i,s,r,n,a=function(){t.call(this,"css"),this._overwriteProps.length=0,this.setRatio=a.prototype.setRatio},o={},h=a.prototype=new t("css");h.constructor=a,a.version="1.14.2",a.API=2,a.defaultTransformPerspective=0,a.defaultSkewType="compensated",h="px",a.suffixMap={top:h,right:h,bottom:h,left:h,width:h,height:h,fontSize:h,padding:h,margin:h,perspective:h,lineHeight:""};var l,_,u,p,c,f,m=/(?:\\d|\\-\\d|\\.\\d|\\-\\.\\d)+/g,d=/(?:\\d|\\-\\d|\\.\\d|\\-\\.\\d|\\+=\\d|\\-=\\d|\\+=.\\d|\\-=\\.\\d)+/g,g=/(?:\\+=|\\-=|\\-|\\b)[\\d\\-\\.]+[a-zA-Z0-9]*(?:%|\\b)/gi,v=/(?![+-]?\\d*\\.?\\d+|e[+-]\\d+)[^0-9]/g,y=/(?:\\d|\\-|\\+|=|#|\\.)*/g,T=/opacity *= *([^)]*)/i,w=/opacity:([^;]*)/i,x=/alpha\\(opacity *=.+?\\)/i,b=/^(rgb|hsl)/,P=/([A-Z])/g,S=/-([a-z])/gi,k=/(^(?:url\\(\\"|url\\())|(?:(\\"\\))$|\\)$)/gi,R=function(t,e){return e.toUpperCase()},A=/(?:Left|Right|Width)/i,C=/(M11|M12|M21|M22)=[\\d\\-\\.e]+/gi,O=/progid\\:DXImageTransform\\.Microsoft\\.Matrix\\(.+?\\)/i,D=/,(?=[^\\)]*(?:\\(|$))/gi,M=Math.PI/180,z=180/Math.PI,I={},E=document,F=E.createElement("div"),L=E.createElement("img"),N=a._internals={_specialProps:o},X=navigator.userAgent,U=function(){var t,e=X.indexOf("Android"),i=E.createElement("div");return u=-1!==X.indexOf("Safari")&&-1===X.indexOf("Chrome")&&(-1===e||Number(X.substr(e+8,1))>3),c=u&&6>Number(X.substr(X.indexOf("Version/")+8,1)),p=-1!==X.indexOf("Firefox"),(/MSIE ([0-9]{1,}[\\.0-9]{0,})/.exec(X)||/Trident\\/.*rv:([0-9]{1,}[\\.0-9]{0,})/.exec(X))&&(f=parseFloat(RegExp.$1)),i.innerHTML="<a style=\'top:1px;opacity:.55;\'>a</a>",t=i.getElementsByTagName("a")[0],t?/^0.55/.test(t.style.opacity):!1}(),Y=function(t){return T.test("string"==typeof t?t:(t.currentStyle?t.currentStyle.filter:t.style.filter)||"")?parseFloat(RegExp.$1)/100:1},j=function(t){window.console&&console.log(t)},B="",q="",V=function(t,e){e=e||F;var i,s,r=e.style;if(void 0!==r[t])return t;for(t=t.charAt(0).toUpperCase()+t.substr(1),i=["O","Moz","ms","Ms","Webkit"],s=5;--s>-1&&void 0===r[i[s]+t];);return s>=0?(q=3===s?"ms":i[s],B="-"+q.toLowerCase()+"-",q+t):null},G=E.defaultView?E.defaultView.getComputedStyle:function(){},W=a.getStyle=function(t,e,i,s,r){var n;return U||"opacity"!==e?(!s&&t.style[e]?n=t.style[e]:(i=i||G(t))?n=i[e]||i.getPropertyValue(e)||i.getPropertyValue(e.replace(P,"-$1").toLowerCase()):t.currentStyle&&(n=t.currentStyle[e]),null==r||n&&"none"!==n&&"auto"!==n&&"auto auto"!==n?n:r):Y(t)},Z=N.convertToPixels=function(t,i,s,r,n){if("px"===r||!r)return s;if("auto"===r||!s)return 0;var o,h,l,_=A.test(i),u=t,p=F.style,c=0>s;if(c&&(s=-s),"%"===r&&-1!==i.indexOf("border"))o=s/100*(_?t.clientWidth:t.clientHeight);else{if(p.cssText="border:0 solid red;position:"+W(t,"position")+";line-height:0;","%"!==r&&u.appendChild)p[_?"borderLeftWidth":"borderTopWidth"]=s+r;else{if(u=t.parentNode||E.body,h=u._gsCache,l=e.ticker.frame,h&&_&&h.time===l)return h.width*s/100;p[_?"width":"height"]=s+r}u.appendChild(F),o=parseFloat(F[_?"offsetWidth":"offsetHeight"]),u.removeChild(F),_&&"%"===r&&a.cacheWidths!==!1&&(h=u._gsCache=u._gsCache||{},h.time=l,h.width=100*(o/s)),0!==o||n||(o=Z(t,i,s,r,!0))}return c?-o:o},Q=N.calculateOffset=function(t,e,i){if("absolute"!==W(t,"position",i))return 0;var s="left"===e?"Left":"Top",r=W(t,"margin"+s,i);return t["offset"+s]-(Z(t,e,parseFloat(r),r.replace(y,""))||0)},$=function(t,e){var i,s,r={};if(e=e||G(t,null))if(i=e.length)for(;--i>-1;)r[e[i].replace(S,R)]=e.getPropertyValue(e[i]);else for(i in e)r[i]=e[i];else if(e=t.currentStyle||t.style)for(i in e)"string"==typeof i&&void 0===r[i]&&(r[i.replace(S,R)]=e[i]);return U||(r.opacity=Y(t)),s=Oe(t,e,!1),r.rotation=s.rotation,r.skewX=s.skewX,r.scaleX=s.scaleX,r.scaleY=s.scaleY,r.x=s.x,r.y=s.y,be&&(r.z=s.z,r.rotationX=s.rotationX,r.rotationY=s.rotationY,r.scaleZ=s.scaleZ),r.filters&&delete r.filters,r},H=function(t,e,i,s,r){var n,a,o,h={},l=t.style;for(a in i)"cssText"!==a&&"length"!==a&&isNaN(a)&&(e[a]!==(n=i[a])||r&&r[a])&&-1===a.indexOf("Origin")&&("number"==typeof n||"string"==typeof n)&&(h[a]="auto"!==n||"left"!==a&&"top"!==a?""!==n&&"auto"!==n&&"none"!==n||"string"!=typeof e[a]||""===e[a].replace(v,"")?n:0:Q(t,a),void 0!==l[a]&&(o=new ue(l,a,l[a],o)));if(s)for(a in s)"className"!==a&&(h[a]=s[a]);return{difs:h,firstMPT:o}},K={width:["Left","Right"],height:["Top","Bottom"]},J=["marginLeft","marginRight","marginTop","marginBottom"],te=function(t,e,i){var s=parseFloat("width"===e?t.offsetWidth:t.offsetHeight),r=K[e],n=r.length;for(i=i||G(t,null);--n>-1;)s-=parseFloat(W(t,"padding"+r[n],i,!0))||0,s-=parseFloat(W(t,"border"+r[n]+"Width",i,!0))||0;return s},ee=function(t,e){(null==t||""===t||"auto"===t||"auto auto"===t)&&(t="0 0");var i=t.split(" "),s=-1!==t.indexOf("left")?"0%":-1!==t.indexOf("right")?"100%":i[0],r=-1!==t.indexOf("top")?"0%":-1!==t.indexOf("bottom")?"100%":i[1];return null==r?r="0":"center"===r&&(r="50%"),("center"===s||isNaN(parseFloat(s))&&-1===(s+"").indexOf("="))&&(s="50%"),e&&(e.oxp=-1!==s.indexOf("%"),e.oyp=-1!==r.indexOf("%"),e.oxr="="===s.charAt(1),e.oyr="="===r.charAt(1),e.ox=parseFloat(s.replace(v,"")),e.oy=parseFloat(r.replace(v,""))),s+" "+r+(i.length>2?" "+i[2]:"")},ie=function(t,e){return"string"==typeof t&&"="===t.charAt(1)?parseInt(t.charAt(0)+"1",10)*parseFloat(t.substr(2)):parseFloat(t)-parseFloat(e)},se=function(t,e){return null==t?e:"string"==typeof t&&"="===t.charAt(1)?parseInt(t.charAt(0)+"1",10)*parseFloat(t.substr(2))+e:parseFloat(t)},re=function(t,e,i,s){var r,n,a,o,h=1e-6;return null==t?o=e:"number"==typeof t?o=t:(r=360,n=t.split("_"),a=Number(n[0].replace(v,""))*(-1===t.indexOf("rad")?1:z)-("="===t.charAt(1)?0:e),n.length&&(s&&(s[i]=e+a),-1!==t.indexOf("short")&&(a%=r,a!==a%(r/2)&&(a=0>a?a+r:a-r)),-1!==t.indexOf("_cw")&&0>a?a=(a+9999999999*r)%r-(0|a/r)*r:-1!==t.indexOf("ccw")&&a>0&&(a=(a-9999999999*r)%r-(0|a/r)*r)),o=e+a),h>o&&o>-h&&(o=0),o},ne={aqua:[0,255,255],lime:[0,255,0],silver:[192,192,192],black:[0,0,0],maroon:[128,0,0],teal:[0,128,128],blue:[0,0,255],navy:[0,0,128],white:[255,255,255],fuchsia:[255,0,255],olive:[128,128,0],yellow:[255,255,0],orange:[255,165,0],gray:[128,128,128],purple:[128,0,128],green:[0,128,0],red:[255,0,0],pink:[255,192,203],cyan:[0,255,255],transparent:[255,255,255,0]},ae=function(t,e,i){return t=0>t?t+1:t>1?t-1:t,0|255*(1>6*t?e+6*(i-e)*t:.5>t?i:2>3*t?e+6*(i-e)*(2/3-t):e)+.5},oe=a.parseColor=function(t){var e,i,s,r,n,a;return t&&""!==t?"number"==typeof t?[t>>16,255&t>>8,255&t]:(","===t.charAt(t.length-1)&&(t=t.substr(0,t.length-1)),ne[t]?ne[t]:"#"===t.charAt(0)?(4===t.length&&(e=t.charAt(1),i=t.charAt(2),s=t.charAt(3),t="#"+e+e+i+i+s+s),t=parseInt(t.substr(1),16),[t>>16,255&t>>8,255&t]):"hsl"===t.substr(0,3)?(t=t.match(m),r=Number(t[0])%360/360,n=Number(t[1])/100,a=Number(t[2])/100,i=.5>=a?a*(n+1):a+n-a*n,e=2*a-i,t.length>3&&(t[3]=Number(t[3])),t[0]=ae(r+1/3,e,i),t[1]=ae(r,e,i),t[2]=ae(r-1/3,e,i),t):(t=t.match(m)||ne.transparent,t[0]=Number(t[0]),t[1]=Number(t[1]),t[2]=Number(t[2]),t.length>3&&(t[3]=Number(t[3])),t)):ne.black},he="(?:\\\\b(?:(?:rgb|rgba|hsl|hsla)\\\\(.+?\\\\))|\\\\B#.+?\\\\b";for(h in ne)he+="|"+h+"\\\\b";he=RegExp(he+")","gi");var le=function(t,e,i,s){if(null==t)return function(t){return t};var r,n=e?(t.match(he)||[""])[0]:"",a=t.split(n).join("").match(g)||[],o=t.substr(0,t.indexOf(a[0])),h=")"===t.charAt(t.length-1)?")":"",l=-1!==t.indexOf(" ")?" ":",",_=a.length,u=_>0?a[0].replace(m,""):"";return _?r=e?function(t){var e,p,c,f;if("number"==typeof t)t+=u;else if(s&&D.test(t)){for(f=t.replace(D,"|").split("|"),c=0;f.length>c;c++)f[c]=r(f[c]);return f.join(",")}if(e=(t.match(he)||[n])[0],p=t.split(e).join("").match(g)||[],c=p.length,_>c--)for(;_>++c;)p[c]=i?p[0|(c-1)/2]:a[c];return o+p.join(l)+l+e+h+(-1!==t.indexOf("inset")?" inset":"")}:function(t){var e,n,p;if("number"==typeof t)t+=u;else if(s&&D.test(t)){for(n=t.replace(D,"|").split("|"),p=0;n.length>p;p++)n[p]=r(n[p]);return n.join(",")}if(e=t.match(g)||[],p=e.length,_>p--)for(;_>++p;)e[p]=i?e[0|(p-1)/2]:a[p];return o+e.join(l)+h}:function(t){return t}},_e=function(t){return t=t.split(","),function(e,i,s,r,n,a,o){var h,l=(i+"").split(" ");for(o={},h=0;4>h;h++)o[t[h]]=l[h]=l[h]||l[(h-1)/2>>0];return r.parse(e,o,n,a)}},ue=(N._setPluginRatio=function(t){this.plugin.setRatio(t);for(var e,i,s,r,n=this.data,a=n.proxy,o=n.firstMPT,h=1e-6;o;)e=a[o.v],o.r?e=Math.round(e):h>e&&e>-h&&(e=0),o.t[o.p]=e,o=o._next;if(n.autoRotate&&(n.autoRotate.rotation=a.rotation),1===t)for(o=n.firstMPT;o;){if(i=o.t,i.type){if(1===i.type){for(r=i.xs0+i.s+i.xs1,s=1;i.l>s;s++)r+=i["xn"+s]+i["xs"+(s+1)];i.e=r}}else i.e=i.s+i.xs0;o=o._next}},function(t,e,i,s,r){this.t=t,this.p=e,this.v=i,this.r=r,s&&(s._prev=this,this._next=s)}),pe=(N._parseToProxy=function(t,e,i,s,r,n){var a,o,h,l,_,u=s,p={},c={},f=i._transform,m=I;for(i._transform=null,I=e,s=_=i.parse(t,e,s,r),I=m,n&&(i._transform=f,u&&(u._prev=null,u._prev&&(u._prev._next=null)));s&&s!==u;){if(1>=s.type&&(o=s.p,c[o]=s.s+s.c,p[o]=s.s,n||(l=new ue(s,"s",o,l,s.r),s.c=0),1===s.type))for(a=s.l;--a>0;)h="xn"+a,o=s.p+"_"+h,c[o]=s.data[h],p[o]=s[h],n||(l=new ue(s,h,o,l,s.rxp[h]));s=s._next}return{proxy:p,end:c,firstMPT:l,pt:_}},N.CSSPropTween=function(t,e,s,r,a,o,h,l,_,u,p){this.t=t,this.p=e,this.s=s,this.c=r,this.n=h||e,t instanceof pe||n.push(this.n),this.r=l,this.type=o||0,_&&(this.pr=_,i=!0),this.b=void 0===u?s:u,this.e=void 0===p?s+r:p,a&&(this._next=a,a._prev=this)}),ce=a.parseComplex=function(t,e,i,s,r,n,a,o,h,_){i=i||n||"",a=new pe(t,e,0,0,a,_?2:1,null,!1,o,i,s),s+="";var u,p,c,f,g,v,y,T,w,x,P,S,k=i.split(", ").join(",").split(" "),R=s.split(", ").join(",").split(" "),A=k.length,C=l!==!1;for((-1!==s.indexOf(",")||-1!==i.indexOf(","))&&(k=k.join(" ").replace(D,", ").split(" "),R=R.join(" ").replace(D,", ").split(" "),A=k.length),A!==R.length&&(k=(n||"").split(" "),A=k.length),a.plugin=h,a.setRatio=_,u=0;A>u;u++)if(f=k[u],g=R[u],T=parseFloat(f),T||0===T)a.appendXtra("",T,ie(g,T),g.replace(d,""),C&&-1!==g.indexOf("px"),!0);else if(r&&("#"===f.charAt(0)||ne[f]||b.test(f)))S=","===g.charAt(g.length-1)?"),":")",f=oe(f),g=oe(g),w=f.length+g.length>6,w&&!U&&0===g[3]?(a["xs"+a.l]+=a.l?" transparent":"transparent",a.e=a.e.split(R[u]).join("transparent")):(U||(w=!1),a.appendXtra(w?"rgba(":"rgb(",f[0],g[0]-f[0],",",!0,!0).appendXtra("",f[1],g[1]-f[1],",",!0).appendXtra("",f[2],g[2]-f[2],w?",":S,!0),w&&(f=4>f.length?1:f[3],a.appendXtra("",f,(4>g.length?1:g[3])-f,S,!1)));else if(v=f.match(m)){if(y=g.match(d),!y||y.length!==v.length)return a;for(c=0,p=0;v.length>p;p++)P=v[p],x=f.indexOf(P,c),a.appendXtra(f.substr(c,x-c),Number(P),ie(y[p],P),"",C&&"px"===f.substr(x+P.length,2),0===p),c=x+P.length;a["xs"+a.l]+=f.substr(c)}else a["xs"+a.l]+=a.l?" "+f:f;if(-1!==s.indexOf("=")&&a.data){for(S=a.xs0+a.data.s,u=1;a.l>u;u++)S+=a["xs"+u]+a.data["xn"+u];a.e=S+a["xs"+u]}return a.l||(a.type=-1,a.xs0=a.e),a.xfirst||a},fe=9;for(h=pe.prototype,h.l=h.pr=0;--fe>0;)h["xn"+fe]=0,h["xs"+fe]="";h.xs0="",h._next=h._prev=h.xfirst=h.data=h.plugin=h.setRatio=h.rxp=null,h.appendXtra=function(t,e,i,s,r,n){var a=this,o=a.l;return a["xs"+o]+=n&&o?" "+t:t||"",i||0===o||a.plugin?(a.l++,a.type=a.setRatio?2:1,a["xs"+a.l]=s||"",o>0?(a.data["xn"+o]=e+i,a.rxp["xn"+o]=r,a["xn"+o]=e,a.plugin||(a.xfirst=new pe(a,"xn"+o,e,i,a.xfirst||a,0,a.n,r,a.pr),a.xfirst.xs0=0),a):(a.data={s:e+i},a.rxp={},a.s=e,a.c=i,a.r=r,a)):(a["xs"+o]+=e+(s||""),a)};var me=function(t,e){e=e||{},this.p=e.prefix?V(t)||t:t,o[t]=o[this.p]=this,this.format=e.formatter||le(e.defaultValue,e.color,e.collapsible,e.multi),e.parser&&(this.parse=e.parser),this.clrs=e.color,this.multi=e.multi,this.keyword=e.keyword,this.dflt=e.defaultValue,this.pr=e.priority||0},de=N._registerComplexSpecialProp=function(t,e,i){"object"!=typeof e&&(e={parser:i});var s,r,n=t.split(","),a=e.defaultValue;for(i=i||[a],s=0;n.length>s;s++)e.prefix=0===s&&e.prefix,e.defaultValue=i[s]||a,r=new me(n[s],e)},ge=function(t){if(!o[t]){var e=t.charAt(0).toUpperCase()+t.substr(1)+"Plugin";de(t,{parser:function(t,i,s,r,n,a,h){var l=(_gsScope.GreenSockGlobals||_gsScope).com.greensock.plugins[e];return l?(l._cssRegister(),o[s].parse(t,i,s,r,n,a,h)):(j("Error: "+e+" js file not loaded."),n)}})}};h=me.prototype,h.parseComplex=function(t,e,i,s,r,n){var a,o,h,l,_,u,p=this.keyword;if(this.multi&&(D.test(i)||D.test(e)?(o=e.replace(D,"|").split("|"),h=i.replace(D,"|").split("|")):p&&(o=[e],h=[i])),h){for(l=h.length>o.length?h.length:o.length,a=0;l>a;a++)e=o[a]=o[a]||this.dflt,i=h[a]=h[a]||this.dflt,p&&(_=e.indexOf(p),u=i.indexOf(p),_!==u&&(i=-1===u?h:o,i[a]+=" "+p));e=o.join(", "),i=h.join(", ")}return ce(t,this.p,e,i,this.clrs,this.dflt,s,this.pr,r,n)},h.parse=function(t,e,i,s,n,a){return this.parseComplex(t.style,this.format(W(t,this.p,r,!1,this.dflt)),this.format(e),n,a)},a.registerSpecialProp=function(t,e,i){de(t,{parser:function(t,s,r,n,a,o){var h=new pe(t,r,0,0,a,2,r,!1,i);return h.plugin=o,h.setRatio=e(t,s,n._tween,r),h},priority:i})};var ve,ye="scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),Te=V("transform"),we=B+"transform",xe=V("transformOrigin"),be=null!==V("perspective"),Pe=N.Transform=function(){this.skewY=0},Se=window.SVGElement,ke=function(t,e,i){var s,r=E.createElementNS("http://www.w3.org/2000/svg",t),n=/([a-z])([A-Z])/g;for(s in i)r.setAttributeNS(null,s.replace(n,"$1-$2").toLowerCase(),i[s]);return e.appendChild(r),r},Re=document.documentElement,Ae=function(){var t,e,i,s=f||/Android/i.test(X)&&!window.chrome;return E.createElementNS&&!s&&(t=ke("svg",Re),e=ke("rect",t,{width:100,height:50,x:100}),i=e.getBoundingClientRect().left,e.style[xe]="50% 50%",e.style[Te]="scale(0.5,0.5)",s=i===e.getBoundingClientRect().left,Re.removeChild(t)),s}(),Ce=function(t,e,i){var s=t.getBBox();e=ee(e).split(" "),i.xOrigin=(-1!==e[0].indexOf("%")?parseFloat(e[0])/100*s.width:parseFloat(e[0]))+s.x,i.yOrigin=(-1!==e[1].indexOf("%")?parseFloat(e[1])/100*s.height:parseFloat(e[1]))+s.y},Oe=N.getTransform=function(t,e,i,s){if(t._gsTransform&&i&&!s)return t._gsTransform;var n,o,h,l,_,u,p,c,f,m,d,g,v,y=i?t._gsTransform||new Pe:new Pe,T=0>y.scaleX,w=2e-5,x=1e5,b=179.99,P=b*M,S=be?parseFloat(W(t,xe,e,!1,"0 0 0").split(" ")[2])||y.zOrigin||0:0,k=parseFloat(a.defaultTransformPerspective)||0;if(Te?n=W(t,we,e,!0):t.currentStyle&&(n=t.currentStyle.filter.match(C),n=n&&4===n.length?[n[0].substr(4),Number(n[2].substr(4)),Number(n[1].substr(4)),n[3].substr(4),y.x||0,y.y||0].join(","):""),n&&"none"!==n&&"matrix(1, 0, 0, 1, 0, 0)"!==n){for(o=(n||"").match(/(?:\\-|\\b)[\\d\\-\\.e]+\\b/gi)||[],h=o.length;--h>-1;)l=Number(o[h]),o[h]=(_=l-(l|=0))?(0|_*x+(0>_?-.5:.5))/x+l:l;if(16===o.length){var R=o[8],A=o[9],O=o[10],D=o[12],I=o[13],E=o[14];if(y.zOrigin&&(E=-y.zOrigin,D=R*E-o[12],I=A*E-o[13],E=O*E+y.zOrigin-o[14]),!i||s||null==y.rotationX){var F,L,N,X,U,Y,j,B=o[0],q=o[1],V=o[2],G=o[3],Z=o[4],Q=o[5],$=o[6],H=o[7],K=o[11],J=Math.atan2($,O),te=-P>J||J>P;y.rotationX=J*z,J&&(X=Math.cos(-J),U=Math.sin(-J),F=Z*X+R*U,L=Q*X+A*U,N=$*X+O*U,R=Z*-U+R*X,A=Q*-U+A*X,O=$*-U+O*X,K=H*-U+K*X,Z=F,Q=L,$=N),J=Math.atan2(R,B),y.rotationY=J*z,J&&(Y=-P>J||J>P,X=Math.cos(-J),U=Math.sin(-J),F=B*X-R*U,L=q*X-A*U,N=V*X-O*U,A=q*U+A*X,O=V*U+O*X,K=G*U+K*X,B=F,q=L,V=N),J=Math.atan2(q,Q),y.rotation=J*z,J&&(j=-P>J||J>P,X=Math.cos(-J),U=Math.sin(-J),B=B*X+Z*U,L=q*X+Q*U,Q=q*-U+Q*X,$=V*-U+$*X,q=L),j&&te?y.rotation=y.rotationX=0:j&&Y?y.rotation=y.rotationY=0:Y&&te&&(y.rotationY=y.rotationX=0),y.scaleX=(0|Math.sqrt(B*B+q*q)*x+.5)/x,y.scaleY=(0|Math.sqrt(Q*Q+A*A)*x+.5)/x,y.scaleZ=(0|Math.sqrt($*$+O*O)*x+.5)/x,y.skewX=0,y.perspective=K?1/(0>K?-K:K):0,y.x=D,y.y=I,y.z=E}}else if(!(be&&!s&&o.length&&y.x===o[4]&&y.y===o[5]&&(y.rotationX||y.rotationY)||void 0!==y.x&&"none"===W(t,"display",e))){var ee=o.length>=6,ie=ee?o[0]:1,se=o[1]||0,re=o[2]||0,ne=ee?o[3]:1;y.x=o[4]||0,y.y=o[5]||0,u=Math.sqrt(ie*ie+se*se),p=Math.sqrt(ne*ne+re*re),c=ie||se?Math.atan2(se,ie)*z:y.rotation||0,f=re||ne?Math.atan2(re,ne)*z+c:y.skewX||0,m=u-Math.abs(y.scaleX||0),d=p-Math.abs(y.scaleY||0),Math.abs(f)>90&&270>Math.abs(f)&&(T?(u*=-1,f+=0>=c?180:-180,c+=0>=c?180:-180):(p*=-1,f+=0>=f?180:-180)),g=(c-y.rotation)%180,v=(f-y.skewX)%180,(void 0===y.skewX||m>w||-w>m||d>w||-w>d||g>-b&&b>g&&false|g*x||v>-b&&b>v&&false|v*x)&&(y.scaleX=u,y.scaleY=p,y.rotation=c,y.skewX=f),be&&(y.rotationX=y.rotationY=y.z=0,y.perspective=k,y.scaleZ=1)}y.zOrigin=S;for(h in y)w>y[h]&&y[h]>-w&&(y[h]=0)}else y={x:0,y:0,z:0,scaleX:1,scaleY:1,scaleZ:1,skewX:0,skewY:0,perspective:k,rotation:0,rotationX:0,rotationY:0,zOrigin:0};return i&&(t._gsTransform=y),y.svg=Se&&t instanceof Se&&t.parentNode instanceof Se,y.svg&&(Ce(t,W(t,xe,r,!1,"50% 50%")+"",y),ve=a.useSVGTransformAttr||Ae),y.xPercent=y.yPercent=0,y},De=function(t){var e,i,s=this.data,r=-s.rotation*M,n=r+s.skewX*M,a=1e5,o=(0|Math.cos(r)*s.scaleX*a)/a,h=(0|Math.sin(r)*s.scaleX*a)/a,l=(0|Math.sin(n)*-s.scaleY*a)/a,_=(0|Math.cos(n)*s.scaleY*a)/a,u=this.t.style,p=this.t.currentStyle;if(p){i=h,h=-l,l=-i,e=p.filter,u.filter="";var c,m,d=this.t.offsetWidth,g=this.t.offsetHeight,v="absolute"!==p.position,w="progid:DXImageTransform.Microsoft.Matrix(M11="+o+", M12="+h+", M21="+l+", M22="+_,x=s.x+d*s.xPercent/100,b=s.y+g*s.yPercent/100;if(null!=s.ox&&(c=(s.oxp?.01*d*s.ox:s.ox)-d/2,m=(s.oyp?.01*g*s.oy:s.oy)-g/2,x+=c-(c*o+m*h),b+=m-(c*l+m*_)),v?(c=d/2,m=g/2,w+=", Dx="+(c-(c*o+m*h)+x)+", Dy="+(m-(c*l+m*_)+b)+")"):w+=", sizingMethod=\'auto expand\')",u.filter=-1!==e.indexOf("DXImageTransform.Microsoft.Matrix(")?e.replace(O,w):w+" "+e,(0===t||1===t)&&1===o&&0===h&&0===l&&1===_&&(v&&-1===w.indexOf("Dx=0, Dy=0")||T.test(e)&&100!==parseFloat(RegExp.$1)||-1===e.indexOf("gradient("&&e.indexOf("Alpha"))&&u.removeAttribute("filter")),!v){var P,S,k,R=8>f?1:-1;for(c=s.ieOffsetX||0,m=s.ieOffsetY||0,s.ieOffsetX=Math.round((d-((0>o?-o:o)*d+(0>h?-h:h)*g))/2+x),s.ieOffsetY=Math.round((g-((0>_?-_:_)*g+(0>l?-l:l)*d))/2+b),fe=0;4>fe;fe++)S=J[fe],P=p[S],i=-1!==P.indexOf("px")?parseFloat(P):Z(this.t,S,parseFloat(P),P.replace(y,""))||0,k=i!==s[S]?2>fe?-s.ieOffsetX:-s.ieOffsetY:2>fe?c-s.ieOffsetX:m-s.ieOffsetY,u[S]=(s[S]=Math.round(i-k*(0===fe||2===fe?1:R)))+"px"}}},Me=N.set3DTransformRatio=function(t){var e,i,s,r,n,a,o,h,l,_,u,c,f,m,d,g,v,y,T,w,x,b,P,S=this.data,k=this.t.style,R=S.rotation*M,A=S.scaleX,C=S.scaleY,O=S.scaleZ,D=S.x,z=S.y,I=S.z,E=S.perspective;if(!(1!==t&&0!==t||"auto"!==S.force3D||S.rotationY||S.rotationX||1!==O||E||I))return ze.call(this,t),void 0;if(p){var F=1e-4;F>A&&A>-F&&(A=O=2e-5),F>C&&C>-F&&(C=O=2e-5),!E||S.z||S.rotationX||S.rotationY||(E=0)}if(R||S.skewX)y=Math.cos(R),T=Math.sin(R),e=y,n=T,S.skewX&&(R-=S.skewX*M,y=Math.cos(R),T=Math.sin(R),"simple"===S.skewType&&(w=Math.tan(S.skewX*M),w=Math.sqrt(1+w*w),y*=w,T*=w)),i=-T,a=y;else{if(!(S.rotationY||S.rotationX||1!==O||E||S.svg))return k[Te]=(S.xPercent||S.yPercent?"translate("+S.xPercent+"%,"+S.yPercent+"%) translate3d(":"translate3d(")+D+"px,"+z+"px,"+I+"px)"+(1!==A||1!==C?" scale("+A+","+C+")":""),void 0;e=a=1,i=n=0}u=1,s=r=o=h=l=_=c=f=m=0,d=E?-1/E:0,g=S.zOrigin,v=1e5,R=S.rotationY*M,R&&(y=Math.cos(R),T=Math.sin(R),l=u*-T,f=d*-T,s=e*T,o=n*T,u*=y,d*=y,e*=y,n*=y),R=S.rotationX*M,R&&(y=Math.cos(R),T=Math.sin(R),w=i*y+s*T,x=a*y+o*T,b=_*y+u*T,P=m*y+d*T,s=i*-T+s*y,o=a*-T+o*y,u=_*-T+u*y,d=m*-T+d*y,i=w,a=x,_=b,m=P),1!==O&&(s*=O,o*=O,u*=O,d*=O),1!==C&&(i*=C,a*=C,_*=C,m*=C),1!==A&&(e*=A,n*=A,l*=A,f*=A),g&&(c-=g,r=s*c,h=o*c,c=u*c+g),S.svg&&(r+=S.xOrigin-(S.xOrigin*e+S.yOrigin*i),h+=S.yOrigin-(S.xOrigin*n+S.yOrigin*a)),r=(w=(r+=D)-(r|=0))?(0|w*v+(0>w?-.5:.5))/v+r:r,h=(w=(h+=z)-(h|=0))?(0|w*v+(0>w?-.5:.5))/v+h:h,c=(w=(c+=I)-(c|=0))?(0|w*v+(0>w?-.5:.5))/v+c:c,k[Te]=(S.xPercent||S.yPercent?"translate("+S.xPercent+"%,"+S.yPercent+"%) matrix3d(":"matrix3d(")+[(0|e*v)/v,(0|n*v)/v,(0|l*v)/v,(0|f*v)/v,(0|i*v)/v,(0|a*v)/v,(0|_*v)/v,(0|m*v)/v,(0|s*v)/v,(0|o*v)/v,(0|u*v)/v,(0|d*v)/v,r,h,c,E?1+-c/E:1].join(",")+")"},ze=N.set2DTransformRatio=function(t){var e,i,s,r,n,a,o,h,l,_,u,p=this.data,c=this.t,f=c.style,m=p.x,d=p.y;return!(p.rotationX||p.rotationY||p.z||p.force3D===!0||"auto"===p.force3D&&1!==t&&0!==t)||p.svg&&ve||!be?(r=p.scaleX,n=p.scaleY,p.rotation||p.skewX||p.svg?(e=p.rotation*M,i=e-p.skewX*M,s=1e5,a=Math.cos(e)*r,o=Math.sin(e)*r,h=Math.sin(i)*-n,l=Math.cos(i)*n,p.svg&&(m+=p.xOrigin-(p.xOrigin*a+p.yOrigin*h),d+=p.yOrigin-(p.xOrigin*o+p.yOrigin*l),u=1e-6,u>m&&m>-u&&(m=0),u>d&&d>-u&&(d=0)),_=(0|a*s)/s+","+(0|o*s)/s+","+(0|h*s)/s+","+(0|l*s)/s+","+m+","+d+")",p.svg&&ve?c.setAttribute("transform","matrix("+_):f[Te]=(p.xPercent||p.yPercent?"translate("+p.xPercent+"%,"+p.yPercent+"%) matrix(":"matrix(")+_):f[Te]=(p.xPercent||p.yPercent?"translate("+p.xPercent+"%,"+p.yPercent+"%) matrix(":"matrix(")+r+",0,0,"+n+","+m+","+d+")",void 0):(this.setRatio=Me,Me.call(this,t),void 0)};de("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent",{parser:function(t,e,i,s,n,o,h){if(s._transform)return n;var l,_,u,p,c,f,m,d=s._transform=Oe(t,r,!0,h.parseTransform),g=t.style,v=1e-6,y=ye.length,T=h,w={};if("string"==typeof T.transform&&Te)u=F.style,u[Te]=T.transform,u.display="block",u.position="absolute",E.body.appendChild(F),l=Oe(F,null,!1),E.body.removeChild(F);else if("object"==typeof T){if(l={scaleX:se(null!=T.scaleX?T.scaleX:T.scale,d.scaleX),scaleY:se(null!=T.scaleY?T.scaleY:T.scale,d.scaleY),scaleZ:se(T.scaleZ,d.scaleZ),x:se(T.x,d.x),y:se(T.y,d.y),z:se(T.z,d.z),xPercent:se(T.xPercent,d.xPercent),yPercent:se(T.yPercent,d.yPercent),perspective:se(T.transformPerspective,d.perspective)},m=T.directionalRotation,null!=m)if("object"==typeof m)for(u in m)T[u]=m[u];else T.rotation=m;"string"==typeof T.x&&-1!==T.x.indexOf("%")&&(l.x=0,l.xPercent=se(T.x,d.xPercent)),"string"==typeof T.y&&-1!==T.y.indexOf("%")&&(l.y=0,l.yPercent=se(T.y,d.yPercent)),l.rotation=re("rotation"in T?T.rotation:"shortRotation"in T?T.shortRotation+"_short":"rotationZ"in T?T.rotationZ:d.rotation,d.rotation,"rotation",w),be&&(l.rotationX=re("rotationX"in T?T.rotationX:"shortRotationX"in T?T.shortRotationX+"_short":d.rotationX||0,d.rotationX,"rotationX",w),l.rotationY=re("rotationY"in T?T.rotationY:"shortRotationY"in T?T.shortRotationY+"_short":d.rotationY||0,d.rotationY,"rotationY",w)),l.skewX=null==T.skewX?d.skewX:re(T.skewX,d.skewX),l.skewY=null==T.skewY?d.skewY:re(T.skewY,d.skewY),(_=l.skewY-d.skewY)&&(l.skewX+=_,l.rotation+=_)}for(be&&null!=T.force3D&&(d.force3D=T.force3D,f=!0),d.skewType=T.skewType||d.skewType||a.defaultSkewType,c=d.force3D||d.z||d.rotationX||d.rotationY||l.z||l.rotationX||l.rotationY||l.perspective,c||null==T.scale||(l.scaleZ=1);--y>-1;)i=ye[y],p=l[i]-d[i],(p>v||-v>p||null!=T[i]||null!=I[i])&&(f=!0,n=new pe(d,i,d[i],p,n),i in w&&(n.e=w[i]),n.xs0=0,n.plugin=o,s._overwriteProps.push(n.n));return p=T.transformOrigin,p&&d.svg&&(Ce(t,p,l),n=new pe(d,"xOrigin",d.xOrigin,l.xOrigin-d.xOrigin,n,-1,"transformOrigin"),n.b=d.xOrigin,n.e=n.xs0=l.xOrigin,n=new pe(d,"yOrigin",d.yOrigin,l.yOrigin-d.yOrigin,n,-1,"transformOrigin"),n.b=d.yOrigin,n.e=n.xs0=l.yOrigin,p="0px 0px"),(p||be&&c&&d.zOrigin)&&(Te?(f=!0,i=xe,p=(p||W(t,i,r,!1,"50% 50%"))+"",n=new pe(g,i,0,0,n,-1,"transformOrigin"),n.b=g[i],n.plugin=o,be?(u=d.zOrigin,p=p.split(" "),d.zOrigin=(p.length>2&&(0===u||"0px"!==p[2])?parseFloat(p[2]):u)||0,n.xs0=n.e=p[0]+" "+(p[1]||"50%")+" 0px",n=new pe(d,"zOrigin",0,0,n,-1,n.n),n.b=u,n.xs0=n.e=d.zOrigin):n.xs0=n.e=p):ee(p+"",d)),f&&(s._transformType=d.svg&&ve||!c&&3!==this._transformType?2:3),n},prefix:!0}),de("boxShadow",{defaultValue:"0px 0px 0px 0px #999",prefix:!0,color:!0,multi:!0,keyword:"inset"}),de("borderRadius",{defaultValue:"0px",parser:function(t,e,i,n,a){e=this.format(e);var o,h,l,_,u,p,c,f,m,d,g,v,y,T,w,x,b=["borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius"],P=t.style;for(m=parseFloat(t.offsetWidth),d=parseFloat(t.offsetHeight),o=e.split(" "),h=0;b.length>h;h++)this.p.indexOf("border")&&(b[h]=V(b[h])),u=_=W(t,b[h],r,!1,"0px"),-1!==u.indexOf(" ")&&(_=u.split(" "),u=_[0],_=_[1]),p=l=o[h],c=parseFloat(u),v=u.substr((c+"").length),y="="===p.charAt(1),y?(f=parseInt(p.charAt(0)+"1",10),p=p.substr(2),f*=parseFloat(p),g=p.substr((f+"").length-(0>f?1:0))||""):(f=parseFloat(p),g=p.substr((f+"").length)),""===g&&(g=s[i]||v),g!==v&&(T=Z(t,"borderLeft",c,v),w=Z(t,"borderTop",c,v),"%"===g?(u=100*(T/m)+"%",_=100*(w/d)+"%"):"em"===g?(x=Z(t,"borderLeft",1,"em"),u=T/x+"em",_=w/x+"em"):(u=T+"px",_=w+"px"),y&&(p=parseFloat(u)+f+g,l=parseFloat(_)+f+g)),a=ce(P,b[h],u+" "+_,p+" "+l,!1,"0px",a);return a},prefix:!0,formatter:le("0px 0px 0px 0px",!1,!0)}),de("backgroundPosition",{defaultValue:"0 0",parser:function(t,e,i,s,n,a){var o,h,l,_,u,p,c="background-position",m=r||G(t,null),d=this.format((m?f?m.getPropertyValue(c+"-x")+" "+m.getPropertyValue(c+"-y"):m.getPropertyValue(c):t.currentStyle.backgroundPositionX+" "+t.currentStyle.backgroundPositionY)||"0 0"),g=this.format(e);if(-1!==d.indexOf("%")!=(-1!==g.indexOf("%"))&&(p=W(t,"backgroundImage").replace(k,""),p&&"none"!==p)){for(o=d.split(" "),h=g.split(" "),L.setAttribute("src",p),l=2;--l>-1;)d=o[l],_=-1!==d.indexOf("%"),_!==(-1!==h[l].indexOf("%"))&&(u=0===l?t.offsetWidth-L.width:t.offsetHeight-L.height,o[l]=_?parseFloat(d)/100*u+"px":100*(parseFloat(d)/u)+"%");d=o.join(" ")}return this.parseComplex(t.style,d,g,n,a)},formatter:ee}),de("backgroundSize",{defaultValue:"0 0",formatter:ee}),de("perspective",{defaultValue:"0px",prefix:!0}),de("perspectiveOrigin",{defaultValue:"50% 50%",prefix:!0}),de("transformStyle",{prefix:!0}),de("backfaceVisibility",{prefix:!0}),de("userSelect",{prefix:!0}),de("margin",{parser:_e("marginTop,marginRight,marginBottom,marginLeft")}),de("padding",{parser:_e("paddingTop,paddingRight,paddingBottom,paddingLeft")}),de("clip",{defaultValue:"rect(0px,0px,0px,0px)",parser:function(t,e,i,s,n,a){var o,h,l;return 9>f?(h=t.currentStyle,l=8>f?" ":",",o="rect("+h.clipTop+l+h.clipRight+l+h.clipBottom+l+h.clipLeft+")",e=this.format(e).split(",").join(l)):(o=this.format(W(t,this.p,r,!1,this.dflt)),e=this.format(e)),this.parseComplex(t.style,o,e,n,a)}}),de("textShadow",{defaultValue:"0px 0px 0px #999",color:!0,multi:!0}),de("autoRound,strictUnits",{parser:function(t,e,i,s,r){return r}}),de("border",{defaultValue:"0px solid #000",parser:function(t,e,i,s,n,a){return this.parseComplex(t.style,this.format(W(t,"borderTopWidth",r,!1,"0px")+" "+W(t,"borderTopStyle",r,!1,"solid")+" "+W(t,"borderTopColor",r,!1,"#000")),this.format(e),n,a)},color:!0,formatter:function(t){var e=t.split(" ");return e[0]+" "+(e[1]||"solid")+" "+(t.match(he)||["#000"])[0]}}),de("borderWidth",{parser:_e("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")}),de("float,cssFloat,styleFloat",{parser:function(t,e,i,s,r){var n=t.style,a="cssFloat"in n?"cssFloat":"styleFloat";return new pe(n,a,0,0,r,-1,i,!1,0,n[a],e)}});var Ie=function(t){var e,i=this.t,s=i.filter||W(this.data,"filter")||"",r=0|this.s+this.c*t;100===r&&(-1===s.indexOf("atrix(")&&-1===s.indexOf("radient(")&&-1===s.indexOf("oader(")?(i.removeAttribute("filter"),e=!W(this.data,"filter")):(i.filter=s.replace(x,""),e=!0)),e||(this.xn1&&(i.filter=s=s||"alpha(opacity="+r+")"),-1===s.indexOf("pacity")?0===r&&this.xn1||(i.filter=s+" alpha(opacity="+r+")"):i.filter=s.replace(T,"opacity="+r))};de("opacity,alpha,autoAlpha",{defaultValue:"1",parser:function(t,e,i,s,n,a){var o=parseFloat(W(t,"opacity",r,!1,"1")),h=t.style,l="autoAlpha"===i;return"string"==typeof e&&"="===e.charAt(1)&&(e=("-"===e.charAt(0)?-1:1)*parseFloat(e.substr(2))+o),l&&1===o&&"hidden"===W(t,"visibility",r)&&0!==e&&(o=0),U?n=new pe(h,"opacity",o,e-o,n):(n=new pe(h,"opacity",100*o,100*(e-o),n),n.xn1=l?1:0,h.zoom=1,n.type=2,n.b="alpha(opacity="+n.s+")",n.e="alpha(opacity="+(n.s+n.c)+")",n.data=t,n.plugin=a,n.setRatio=Ie),l&&(n=new pe(h,"visibility",0,0,n,-1,null,!1,0,0!==o?"inherit":"hidden",0===e?"hidden":"inherit"),n.xs0="inherit",s._overwriteProps.push(n.n),s._overwriteProps.push(i)),n}});var Ee=function(t,e){e&&(t.removeProperty?("ms"===e.substr(0,2)&&(e="M"+e.substr(1)),t.removeProperty(e.replace(P,"-$1").toLowerCase())):t.removeAttribute(e))},Fe=function(t){if(this.t._gsClassPT=this,1===t||0===t){this.t.setAttribute("class",0===t?this.b:this.e);for(var e=this.data,i=this.t.style;e;)e.v?i[e.p]=e.v:Ee(i,e.p),e=e._next;1===t&&this.t._gsClassPT===this&&(this.t._gsClassPT=null)}else this.t.getAttribute("class")!==this.e&&this.t.setAttribute("class",this.e)};de("className",{parser:function(t,e,s,n,a,o,h){var l,_,u,p,c,f=t.getAttribute("class")||"",m=t.style.cssText;if(a=n._classNamePT=new pe(t,s,0,0,a,2),a.setRatio=Fe,a.pr=-11,i=!0,a.b=f,_=$(t,r),u=t._gsClassPT){for(p={},c=u.data;c;)p[c.p]=1,c=c._next;u.setRatio(1)}return t._gsClassPT=a,a.e="="!==e.charAt(1)?e:f.replace(RegExp("\\\\s*\\\\b"+e.substr(2)+"\\\\b"),"")+("+"===e.charAt(0)?" "+e.substr(2):""),n._tween._duration&&(t.setAttribute("class",a.e),l=H(t,_,$(t),h,p),t.setAttribute("class",f),a.data=l.firstMPT,t.style.cssText=m,a=a.xfirst=n.parse(t,l.difs,a,o)),a}});var Le=function(t){if((1===t||0===t)&&this.data._totalTime===this.data._totalDuration&&"isFromStart"!==this.data.data){var e,i,s,r,n=this.t.style,a=o.transform.parse;if("all"===this.e)n.cssText="",r=!0;else for(e=this.e.split(" ").join("").split(","),s=e.length;--s>-1;)i=e[s],o[i]&&(o[i].parse===a?r=!0:i="transformOrigin"===i?xe:o[i].p),Ee(n,i);r&&(Ee(n,Te),this.t._gsTransform&&delete this.t._gsTransform)}};for(de("clearProps",{parser:function(t,e,s,r,n){return n=new pe(t,s,0,0,n,2),n.setRatio=Le,n.e=e,n.pr=-10,n.data=r._tween,i=!0,n}}),h="bezier,throwProps,physicsProps,physics2D".split(","),fe=h.length;fe--;)ge(h[fe]);h=a.prototype,h._firstPT=null,h._onInitTween=function(t,e,o){if(!t.nodeType)return!1;this._target=t,this._tween=o,this._vars=e,l=e.autoRound,i=!1,s=e.suffixMap||a.suffixMap,r=G(t,""),n=this._overwriteProps;var h,p,f,m,d,g,v,y,T,x=t.style;\nif(_&&""===x.zIndex&&(h=W(t,"zIndex",r),("auto"===h||""===h)&&this._addLazySet(x,"zIndex",0)),"string"==typeof e&&(m=x.cssText,h=$(t,r),x.cssText=m+";"+e,h=H(t,h,$(t)).difs,!U&&w.test(e)&&(h.opacity=parseFloat(RegExp.$1)),e=h,x.cssText=m),this._firstPT=p=this.parse(t,e,null),this._transformType){for(T=3===this._transformType,Te?u&&(_=!0,""===x.zIndex&&(v=W(t,"zIndex",r),("auto"===v||""===v)&&this._addLazySet(x,"zIndex",0)),c&&this._addLazySet(x,"WebkitBackfaceVisibility",this._vars.WebkitBackfaceVisibility||(T?"visible":"hidden"))):x.zoom=1,f=p;f&&f._next;)f=f._next;y=new pe(t,"transform",0,0,null,2),this._linkCSSP(y,null,f),y.setRatio=T&&be?Me:Te?ze:De,y.data=this._transform||Oe(t,r,!0),n.pop()}if(i){for(;p;){for(g=p._next,f=m;f&&f.pr>p.pr;)f=f._next;(p._prev=f?f._prev:d)?p._prev._next=p:m=p,(p._next=f)?f._prev=p:d=p,p=g}this._firstPT=m}return!0},h.parse=function(t,e,i,n){var a,h,_,u,p,c,f,m,d,g,v=t.style;for(a in e)c=e[a],h=o[a],h?i=h.parse(t,c,a,this,i,n,e):(p=W(t,a,r)+"",d="string"==typeof c,"color"===a||"fill"===a||"stroke"===a||-1!==a.indexOf("Color")||d&&b.test(c)?(d||(c=oe(c),c=(c.length>3?"rgba(":"rgb(")+c.join(",")+")"),i=ce(v,a,p,c,!0,"transparent",i,0,n)):!d||-1===c.indexOf(" ")&&-1===c.indexOf(",")?(_=parseFloat(p),f=_||0===_?p.substr((_+"").length):"",(""===p||"auto"===p)&&("width"===a||"height"===a?(_=te(t,a,r),f="px"):"left"===a||"top"===a?(_=Q(t,a,r),f="px"):(_="opacity"!==a?0:1,f="")),g=d&&"="===c.charAt(1),g?(u=parseInt(c.charAt(0)+"1",10),c=c.substr(2),u*=parseFloat(c),m=c.replace(y,"")):(u=parseFloat(c),m=d?c.substr((u+"").length)||"":""),""===m&&(m=a in s?s[a]:f),c=u||0===u?(g?u+_:u)+m:e[a],f!==m&&""!==m&&(u||0===u)&&_&&(_=Z(t,a,_,f),"%"===m?(_/=Z(t,a,100,"%")/100,e.strictUnits!==!0&&(p=_+"%")):"em"===m?_/=Z(t,a,1,"em"):"px"!==m&&(u=Z(t,a,u,m),m="px"),g&&(u||0===u)&&(c=u+_+m)),g&&(u+=_),!_&&0!==_||!u&&0!==u?void 0!==v[a]&&(c||"NaN"!=c+""&&null!=c)?(i=new pe(v,a,u||_||0,0,i,-1,a,!1,0,p,c),i.xs0="none"!==c||"display"!==a&&-1===a.indexOf("Style")?c:p):j("invalid "+a+" tween value: "+e[a]):(i=new pe(v,a,_,u-_,i,0,a,l!==!1&&("px"===m||"zIndex"===a),0,p,c),i.xs0=m)):i=ce(v,a,p,c,!0,null,i,0,n)),n&&i&&!i.plugin&&(i.plugin=n);return i},h.setRatio=function(t){var e,i,s,r=this._firstPT,n=1e-6;if(1!==t||this._tween._time!==this._tween._duration&&0!==this._tween._time)if(t||this._tween._time!==this._tween._duration&&0!==this._tween._time||this._tween._rawPrevTime===-1e-6)for(;r;){if(e=r.c*t+r.s,r.r?e=Math.round(e):n>e&&e>-n&&(e=0),r.type)if(1===r.type)if(s=r.l,2===s)r.t[r.p]=r.xs0+e+r.xs1+r.xn1+r.xs2;else if(3===s)r.t[r.p]=r.xs0+e+r.xs1+r.xn1+r.xs2+r.xn2+r.xs3;else if(4===s)r.t[r.p]=r.xs0+e+r.xs1+r.xn1+r.xs2+r.xn2+r.xs3+r.xn3+r.xs4;else if(5===s)r.t[r.p]=r.xs0+e+r.xs1+r.xn1+r.xs2+r.xn2+r.xs3+r.xn3+r.xs4+r.xn4+r.xs5;else{for(i=r.xs0+e+r.xs1,s=1;r.l>s;s++)i+=r["xn"+s]+r["xs"+(s+1)];r.t[r.p]=i}else-1===r.type?r.t[r.p]=r.xs0:r.setRatio&&r.setRatio(t);else r.t[r.p]=e+r.xs0;r=r._next}else for(;r;)2!==r.type?r.t[r.p]=r.b:r.setRatio(t),r=r._next;else for(;r;)2!==r.type?r.t[r.p]=r.e:r.setRatio(t),r=r._next},h._enableTransforms=function(t){this._transform=this._transform||Oe(this._target,r,!0),this._transformType=this._transform.svg&&ve||!t&&3!==this._transformType?2:3};var Ne=function(){this.t[this.p]=this.e,this.data._linkCSSP(this,this._next,null,!0)};h._addLazySet=function(t,e,i){var s=this._firstPT=new pe(t,e,0,0,this._firstPT,2);s.e=i,s.setRatio=Ne,s.data=this},h._linkCSSP=function(t,e,i,s){return t&&(e&&(e._prev=t),t._next&&(t._next._prev=t._prev),t._prev?t._prev._next=t._next:this._firstPT===t&&(this._firstPT=t._next,s=!0),i?i._next=t:s||null!==this._firstPT||(this._firstPT=t),t._next=e,t._prev=i),t},h._kill=function(e){var i,s,r,n=e;if(e.autoAlpha||e.alpha){n={};for(s in e)n[s]=e[s];n.opacity=1,n.autoAlpha&&(n.visibility=1)}return e.className&&(i=this._classNamePT)&&(r=i.xfirst,r&&r._prev?this._linkCSSP(r._prev,i._next,r._prev._prev):r===this._firstPT&&(this._firstPT=i._next),i._next&&this._linkCSSP(i._next,i._next._next,r._prev),this._classNamePT=null),t.prototype._kill.call(this,n)};var Xe=function(t,e,i){var s,r,n,a;if(t.slice)for(r=t.length;--r>-1;)Xe(t[r],e,i);else for(s=t.childNodes,r=s.length;--r>-1;)n=s[r],a=n.type,n.style&&(e.push($(n)),i&&i.push(n)),1!==a&&9!==a&&11!==a||!n.childNodes.length||Xe(n,e,i)};return a.cascadeTo=function(t,i,s){var r,n,a,o=e.to(t,i,s),h=[o],l=[],_=[],u=[],p=e._internals.reservedProps;for(t=o._targets||o.target,Xe(t,l,u),o.render(i,!0),Xe(t,_),o.render(0,!0),o._enabled(!0),r=u.length;--r>-1;)if(n=H(u[r],l[r],_[r]),n.firstMPT){n=n.difs;for(a in s)p[a]&&(n[a]=s[a]);h.push(e.to(u[r],i,n))}return h},t.activate([a]),a},!0),function(){var t=_gsScope._gsDefine.plugin({propName:"roundProps",priority:-1,API:2,init:function(t,e,i){return this._tween=i,!0}}),e=t.prototype;e._onInitAllProps=function(){for(var t,e,i,s=this._tween,r=s.vars.roundProps instanceof Array?s.vars.roundProps:s.vars.roundProps.split(","),n=r.length,a={},o=s._propLookup.roundProps;--n>-1;)a[r[n]]=1;for(n=r.length;--n>-1;)for(t=r[n],e=s._firstPT;e;)i=e._next,e.pg?e.t._roundProps(a,!0):e.n===t&&(this._add(e.t,t,e.s,e.c),i&&(i._prev=e._prev),e._prev?e._prev._next=i:s._firstPT===e&&(s._firstPT=i),e._next=e._prev=null,s._propLookup[t]=o),e=i;return!1},e._add=function(t,e,i,s){this._addTween(t,e,i,i+s,e,!0),this._overwriteProps.push(e)}}(),_gsScope._gsDefine.plugin({propName:"attr",API:2,version:"0.3.3",init:function(t,e){var i,s,r;if("function"!=typeof t.setAttribute)return!1;this._target=t,this._proxy={},this._start={},this._end={};for(i in e)this._start[i]=this._proxy[i]=s=t.getAttribute(i),r=this._addTween(this._proxy,i,parseFloat(s),e[i],i),this._end[i]=r?r.s+r.c:e[i],this._overwriteProps.push(i);return!0},set:function(t){this._super.setRatio.call(this,t);for(var e,i=this._overwriteProps,s=i.length,r=1===t?this._end:t?this._proxy:this._start;--s>-1;)e=i[s],this._target.setAttribute(e,r[e]+"")}}),_gsScope._gsDefine.plugin({propName:"directionalRotation",version:"0.2.1",API:2,init:function(t,e){"object"!=typeof e&&(e={rotation:e}),this.finals={};var i,s,r,n,a,o,h=e.useRadians===!0?2*Math.PI:360,l=1e-6;for(i in e)"useRadians"!==i&&(o=(e[i]+"").split("_"),s=o[0],r=parseFloat("function"!=typeof t[i]?t[i]:t[i.indexOf("set")||"function"!=typeof t["get"+i.substr(3)]?i:"get"+i.substr(3)]()),n=this.finals[i]="string"==typeof s&&"="===s.charAt(1)?r+parseInt(s.charAt(0)+"1",10)*Number(s.substr(2)):Number(s)||0,a=n-r,o.length&&(s=o.join("_"),-1!==s.indexOf("short")&&(a%=h,a!==a%(h/2)&&(a=0>a?a+h:a-h)),-1!==s.indexOf("_cw")&&0>a?a=(a+9999999999*h)%h-(0|a/h)*h:-1!==s.indexOf("ccw")&&a>0&&(a=(a-9999999999*h)%h-(0|a/h)*h)),(a>l||-l>a)&&(this._addTween(t,i,r,r+a,i),this._overwriteProps.push(i)));return!0},set:function(t){var e;if(1!==t)this._super.setRatio.call(this,t);else for(e=this._firstPT;e;)e.f?e.t[e.p](this.finals[e.p]):e.t[e.p]=this.finals[e.p],e=e._next}})._autoCSS=!0,_gsScope._gsDefine("easing.Back",["easing.Ease"],function(t){var e,i,s,r=_gsScope.GreenSockGlobals||_gsScope,n=r.com.greensock,a=2*Math.PI,o=Math.PI/2,h=n._class,l=function(e,i){var s=h("easing."+e,function(){},!0),r=s.prototype=new t;return r.constructor=s,r.getRatio=i,s},_=t.register||function(){},u=function(t,e,i,s){var r=h("easing."+t,{easeOut:new e,easeIn:new i,easeInOut:new s},!0);return _(r,t),r},p=function(t,e,i){this.t=t,this.v=e,i&&(this.next=i,i.prev=this,this.c=i.v-e,this.gap=i.t-t)},c=function(e,i){var s=h("easing."+e,function(t){this._p1=t||0===t?t:1.70158,this._p2=1.525*this._p1},!0),r=s.prototype=new t;return r.constructor=s,r.getRatio=i,r.config=function(t){return new s(t)},s},f=u("Back",c("BackOut",function(t){return(t-=1)*t*((this._p1+1)*t+this._p1)+1}),c("BackIn",function(t){return t*t*((this._p1+1)*t-this._p1)}),c("BackInOut",function(t){return 1>(t*=2)?.5*t*t*((this._p2+1)*t-this._p2):.5*((t-=2)*t*((this._p2+1)*t+this._p2)+2)})),m=h("easing.SlowMo",function(t,e,i){e=e||0===e?e:.7,null==t?t=.7:t>1&&(t=1),this._p=1!==t?e:0,this._p1=(1-t)/2,this._p2=t,this._p3=this._p1+this._p2,this._calcEnd=i===!0},!0),d=m.prototype=new t;return d.constructor=m,d.getRatio=function(t){var e=t+(.5-t)*this._p;return this._p1>t?this._calcEnd?1-(t=1-t/this._p1)*t:e-(t=1-t/this._p1)*t*t*t*e:t>this._p3?this._calcEnd?1-(t=(t-this._p3)/this._p1)*t:e+(t-e)*(t=(t-this._p3)/this._p1)*t*t*t:this._calcEnd?1:e},m.ease=new m(.7,.7),d.config=m.config=function(t,e,i){return new m(t,e,i)},e=h("easing.SteppedEase",function(t){t=t||1,this._p1=1/t,this._p2=t+1},!0),d=e.prototype=new t,d.constructor=e,d.getRatio=function(t){return 0>t?t=0:t>=1&&(t=.999999999),(this._p2*t>>0)*this._p1},d.config=e.config=function(t){return new e(t)},i=h("easing.RoughEase",function(e){e=e||{};for(var i,s,r,n,a,o,h=e.taper||"none",l=[],_=0,u=0|(e.points||20),c=u,f=e.randomize!==!1,m=e.clamp===!0,d=e.template instanceof t?e.template:null,g="number"==typeof e.strength?.4*e.strength:.4;--c>-1;)i=f?Math.random():1/u*c,s=d?d.getRatio(i):i,"none"===h?r=g:"out"===h?(n=1-i,r=n*n*g):"in"===h?r=i*i*g:.5>i?(n=2*i,r=.5*n*n*g):(n=2*(1-i),r=.5*n*n*g),f?s+=Math.random()*r-.5*r:c%2?s+=.5*r:s-=.5*r,m&&(s>1?s=1:0>s&&(s=0)),l[_++]={x:i,y:s};for(l.sort(function(t,e){return t.x-e.x}),o=new p(1,1,null),c=u;--c>-1;)a=l[c],o=new p(a.x,a.y,o);this._prev=new p(0,0,0!==o.t?o:o.next)},!0),d=i.prototype=new t,d.constructor=i,d.getRatio=function(t){var e=this._prev;if(t>e.t){for(;e.next&&t>=e.t;)e=e.next;e=e.prev}else for(;e.prev&&e.t>=t;)e=e.prev;return this._prev=e,e.v+(t-e.t)/e.gap*e.c},d.config=function(t){return new i(t)},i.ease=new i,u("Bounce",l("BounceOut",function(t){return 1/2.75>t?7.5625*t*t:2/2.75>t?7.5625*(t-=1.5/2.75)*t+.75:2.5/2.75>t?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375}),l("BounceIn",function(t){return 1/2.75>(t=1-t)?1-7.5625*t*t:2/2.75>t?1-(7.5625*(t-=1.5/2.75)*t+.75):2.5/2.75>t?1-(7.5625*(t-=2.25/2.75)*t+.9375):1-(7.5625*(t-=2.625/2.75)*t+.984375)}),l("BounceInOut",function(t){var e=.5>t;return t=e?1-2*t:2*t-1,t=1/2.75>t?7.5625*t*t:2/2.75>t?7.5625*(t-=1.5/2.75)*t+.75:2.5/2.75>t?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375,e?.5*(1-t):.5*t+.5})),u("Circ",l("CircOut",function(t){return Math.sqrt(1-(t-=1)*t)}),l("CircIn",function(t){return-(Math.sqrt(1-t*t)-1)}),l("CircInOut",function(t){return 1>(t*=2)?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1)})),s=function(e,i,s){var r=h("easing."+e,function(t,e){this._p1=t||1,this._p2=e||s,this._p3=this._p2/a*(Math.asin(1/this._p1)||0)},!0),n=r.prototype=new t;return n.constructor=r,n.getRatio=i,n.config=function(t,e){return new r(t,e)},r},u("Elastic",s("ElasticOut",function(t){return this._p1*Math.pow(2,-10*t)*Math.sin((t-this._p3)*a/this._p2)+1},.3),s("ElasticIn",function(t){return-(this._p1*Math.pow(2,10*(t-=1))*Math.sin((t-this._p3)*a/this._p2))},.3),s("ElasticInOut",function(t){return 1>(t*=2)?-.5*this._p1*Math.pow(2,10*(t-=1))*Math.sin((t-this._p3)*a/this._p2):.5*this._p1*Math.pow(2,-10*(t-=1))*Math.sin((t-this._p3)*a/this._p2)+1},.45)),u("Expo",l("ExpoOut",function(t){return 1-Math.pow(2,-10*t)}),l("ExpoIn",function(t){return Math.pow(2,10*(t-1))-.001}),l("ExpoInOut",function(t){return 1>(t*=2)?.5*Math.pow(2,10*(t-1)):.5*(2-Math.pow(2,-10*(t-1)))})),u("Sine",l("SineOut",function(t){return Math.sin(t*o)}),l("SineIn",function(t){return-Math.cos(t*o)+1}),l("SineInOut",function(t){return-.5*(Math.cos(Math.PI*t)-1)})),h("easing.EaseLookup",{find:function(e){return t.map[e]}},!0),_(r.SlowMo,"SlowMo","ease,"),_(i,"RoughEase","ease,"),_(e,"SteppedEase","ease,"),f},!0)}),_gsScope._gsDefine&&_gsScope._gsQueue.pop()(),function(t,e){"use strict";var i=t.GreenSockGlobals=t.GreenSockGlobals||t;if(!i.TweenLite){var s,r,n,a,o,h=function(t){var e,s=t.split("."),r=i;for(e=0;s.length>e;e++)r[s[e]]=r=r[s[e]]||{};return r},l=h("com.greensock"),_=1e-10,u=function(t){var e,i=[],s=t.length;for(e=0;e!==s;i.push(t[e++]));return i},p=function(){},c=function(){var t=Object.prototype.toString,e=t.call([]);return function(i){return null!=i&&(i instanceof Array||"object"==typeof i&&!!i.push&&t.call(i)===e)}}(),f={},m=function(s,r,n,a){this.sc=f[s]?f[s].sc:[],f[s]=this,this.gsClass=null,this.func=n;var o=[];this.check=function(l){for(var _,u,p,c,d=r.length,g=d;--d>-1;)(_=f[r[d]]||new m(r[d],[])).gsClass?(o[d]=_.gsClass,g--):l&&_.sc.push(this);if(0===g&&n)for(u=("com.greensock."+s).split("."),p=u.pop(),c=h(u.join("."))[p]=this.gsClass=n.apply(n,o),a&&(i[p]=c,"function"==typeof define&&define.amd?define((t.GreenSockAMDPath?t.GreenSockAMDPath+"/":"")+s.split(".").pop(),[],function(){return c}):s===e&&"undefined"!=typeof module&&module.exports&&(module.exports=c)),d=0;this.sc.length>d;d++)this.sc[d].check()},this.check(!0)},d=t._gsDefine=function(t,e,i,s){return new m(t,e,i,s)},g=l._class=function(t,e,i){return e=e||function(){},d(t,[],function(){return e},i),e};d.globals=i;var v=[0,0,1,1],y=[],T=g("easing.Ease",function(t,e,i,s){this._func=t,this._type=i||0,this._power=s||0,this._params=e?v.concat(e):v},!0),w=T.map={},x=T.register=function(t,e,i,s){for(var r,n,a,o,h=e.split(","),_=h.length,u=(i||"easeIn,easeOut,easeInOut").split(",");--_>-1;)for(n=h[_],r=s?g("easing."+n,null,!0):l.easing[n]||{},a=u.length;--a>-1;)o=u[a],w[n+"."+o]=w[o+n]=r[o]=t.getRatio?t:t[o]||new t};for(n=T.prototype,n._calcEnd=!1,n.getRatio=function(t){if(this._func)return this._params[0]=t,this._func.apply(null,this._params);var e=this._type,i=this._power,s=1===e?1-t:2===e?t:.5>t?2*t:2*(1-t);return 1===i?s*=s:2===i?s*=s*s:3===i?s*=s*s*s:4===i&&(s*=s*s*s*s),1===e?1-s:2===e?s:.5>t?s/2:1-s/2},s=["Linear","Quad","Cubic","Quart","Quint,Strong"],r=s.length;--r>-1;)n=s[r]+",Power"+r,x(new T(null,null,1,r),n,"easeOut",!0),x(new T(null,null,2,r),n,"easeIn"+(0===r?",easeNone":"")),x(new T(null,null,3,r),n,"easeInOut");w.linear=l.easing.Linear.easeIn,w.swing=l.easing.Quad.easeInOut;var b=g("events.EventDispatcher",function(t){this._listeners={},this._eventTarget=t||this});n=b.prototype,n.addEventListener=function(t,e,i,s,r){r=r||0;var n,h,l=this._listeners[t],_=0;for(null==l&&(this._listeners[t]=l=[]),h=l.length;--h>-1;)n=l[h],n.c===e&&n.s===i?l.splice(h,1):0===_&&r>n.pr&&(_=h+1);l.splice(_,0,{c:e,s:i,up:s,pr:r}),this!==a||o||a.wake()},n.removeEventListener=function(t,e){var i,s=this._listeners[t];if(s)for(i=s.length;--i>-1;)if(s[i].c===e)return s.splice(i,1),void 0},n.dispatchEvent=function(t){var e,i,s,r=this._listeners[t];if(r)for(e=r.length,i=this._eventTarget;--e>-1;)s=r[e],s&&(s.up?s.c.call(s.s||i,{type:t,target:i}):s.c.call(s.s||i))};var P=t.requestAnimationFrame,S=t.cancelAnimationFrame,k=Date.now||function(){return(new Date).getTime()},R=k();for(s=["ms","moz","webkit","o"],r=s.length;--r>-1&&!P;)P=t[s[r]+"RequestAnimationFrame"],S=t[s[r]+"CancelAnimationFrame"]||t[s[r]+"CancelRequestAnimationFrame"];g("Ticker",function(t,e){var i,s,r,n,h,l=this,u=k(),c=e!==!1&&P,f=500,m=33,d=function(t){var e,a,o=k()-R;o>f&&(u+=o-m),R+=o,l.time=(R-u)/1e3,e=l.time-h,(!i||e>0||t===!0)&&(l.frame++,h+=e+(e>=n?.004:n-e),a=!0),t!==!0&&(r=s(d)),a&&l.dispatchEvent("tick")};b.call(l),l.time=l.frame=0,l.tick=function(){d(!0)},l.lagSmoothing=function(t,e){f=t||1/_,m=Math.min(e,f,0)},l.sleep=function(){null!=r&&(c&&S?S(r):clearTimeout(r),s=p,r=null,l===a&&(o=!1))},l.wake=function(){null!==r?l.sleep():l.frame>10&&(R=k()-f+5),s=0===i?p:c&&P?P:function(t){return setTimeout(t,0|1e3*(h-l.time)+1)},l===a&&(o=!0),d(2)},l.fps=function(t){return arguments.length?(i=t,n=1/(i||60),h=this.time+n,l.wake(),void 0):i},l.useRAF=function(t){return arguments.length?(l.sleep(),c=t,l.fps(i),void 0):c},l.fps(t),setTimeout(function(){c&&(!r||5>l.frame)&&l.useRAF(!1)},1500)}),n=l.Ticker.prototype=new l.events.EventDispatcher,n.constructor=l.Ticker;var A=g("core.Animation",function(t,e){if(this.vars=e=e||{},this._duration=this._totalDuration=t||0,this._delay=Number(e.delay)||0,this._timeScale=1,this._active=e.immediateRender===!0,this.data=e.data,this._reversed=e.reversed===!0,B){o||a.wake();var i=this.vars.useFrames?j:B;i.add(this,i._time),this.vars.paused&&this.paused(!0)}});a=A.ticker=new l.Ticker,n=A.prototype,n._dirty=n._gc=n._initted=n._paused=!1,n._totalTime=n._time=0,n._rawPrevTime=-1,n._next=n._last=n._onUpdate=n._timeline=n.timeline=null,n._paused=!1;var C=function(){o&&k()-R>2e3&&a.wake(),setTimeout(C,2e3)};C(),n.play=function(t,e){return null!=t&&this.seek(t,e),this.reversed(!1).paused(!1)},n.pause=function(t,e){return null!=t&&this.seek(t,e),this.paused(!0)},n.resume=function(t,e){return null!=t&&this.seek(t,e),this.paused(!1)},n.seek=function(t,e){return this.totalTime(Number(t),e!==!1)},n.restart=function(t,e){return this.reversed(!1).paused(!1).totalTime(t?-this._delay:0,e!==!1,!0)},n.reverse=function(t,e){return null!=t&&this.seek(t||this.totalDuration(),e),this.reversed(!0).paused(!1)},n.render=function(){},n.invalidate=function(){return this._time=this._totalTime=0,this._initted=this._gc=!1,this._rawPrevTime=-1,(this._gc||!this.timeline)&&this._enabled(!0),this},n.isActive=function(){var t,e=this._timeline,i=this._startTime;return!e||!this._gc&&!this._paused&&e.isActive()&&(t=e.rawTime())>=i&&i+this.totalDuration()/this._timeScale>t},n._enabled=function(t,e){return o||a.wake(),this._gc=!t,this._active=this.isActive(),e!==!0&&(t&&!this.timeline?this._timeline.add(this,this._startTime-this._delay):!t&&this.timeline&&this._timeline._remove(this,!0)),!1},n._kill=function(){return this._enabled(!1,!1)},n.kill=function(t,e){return this._kill(t,e),this},n._uncache=function(t){for(var e=t?this:this.timeline;e;)e._dirty=!0,e=e.timeline;return this},n._swapSelfInParams=function(t){for(var e=t.length,i=t.concat();--e>-1;)"{self}"===t[e]&&(i[e]=this);return i},n.eventCallback=function(t,e,i,s){if("on"===(t||"").substr(0,2)){var r=this.vars;if(1===arguments.length)return r[t];null==e?delete r[t]:(r[t]=e,r[t+"Params"]=c(i)&&-1!==i.join("").indexOf("{self}")?this._swapSelfInParams(i):i,r[t+"Scope"]=s),"onUpdate"===t&&(this._onUpdate=e)}return this},n.delay=function(t){return arguments.length?(this._timeline.smoothChildTiming&&this.startTime(this._startTime+t-this._delay),this._delay=t,this):this._delay},n.duration=function(t){return arguments.length?(this._duration=this._totalDuration=t,this._uncache(!0),this._timeline.smoothChildTiming&&this._time>0&&this._time<this._duration&&0!==t&&this.totalTime(this._totalTime*(t/this._duration),!0),this):(this._dirty=!1,this._duration)},n.totalDuration=function(t){return this._dirty=!1,arguments.length?this.duration(t):this._totalDuration},n.time=function(t,e){return arguments.length?(this._dirty&&this.totalDuration(),this.totalTime(t>this._duration?this._duration:t,e)):this._time},n.totalTime=function(t,e,i){if(o||a.wake(),!arguments.length)return this._totalTime;if(this._timeline){if(0>t&&!i&&(t+=this.totalDuration()),this._timeline.smoothChildTiming){this._dirty&&this.totalDuration();var s=this._totalDuration,r=this._timeline;if(t>s&&!i&&(t=s),this._startTime=(this._paused?this._pauseTime:r._time)-(this._reversed?s-t:t)/this._timeScale,r._dirty||this._uncache(!1),r._timeline)for(;r._timeline;)r._timeline._time!==(r._startTime+r._totalTime)/r._timeScale&&r.totalTime(r._totalTime,!0),r=r._timeline}this._gc&&this._enabled(!0,!1),(this._totalTime!==t||0===this._duration)&&(this.render(t,e,!1),I.length&&q())}return this},n.progress=n.totalProgress=function(t,e){return arguments.length?this.totalTime(this.duration()*t,e):this._time/this.duration()},n.startTime=function(t){return arguments.length?(t!==this._startTime&&(this._startTime=t,this.timeline&&this.timeline._sortChildren&&this.timeline.add(this,t-this._delay)),this):this._startTime},n.endTime=function(t){return this._startTime+(0!=t?this.totalDuration():this.duration())/this._timeScale},n.timeScale=function(t){if(!arguments.length)return this._timeScale;if(t=t||_,this._timeline&&this._timeline.smoothChildTiming){var e=this._pauseTime,i=e||0===e?e:this._timeline.totalTime();this._startTime=i-(i-this._startTime)*this._timeScale/t}return this._timeScale=t,this._uncache(!1)},n.reversed=function(t){return arguments.length?(t!=this._reversed&&(this._reversed=t,this.totalTime(this._timeline&&!this._timeline.smoothChildTiming?this.totalDuration()-this._totalTime:this._totalTime,!0)),this):this._reversed},n.paused=function(t){if(!arguments.length)return this._paused;if(t!=this._paused&&this._timeline){o||t||a.wake();var e=this._timeline,i=e.rawTime(),s=i-this._pauseTime;!t&&e.smoothChildTiming&&(this._startTime+=s,this._uncache(!1)),this._pauseTime=t?i:null,this._paused=t,this._active=this.isActive(),!t&&0!==s&&this._initted&&this.duration()&&this.render(e.smoothChildTiming?this._totalTime:(i-this._startTime)/this._timeScale,!0,!0)}return this._gc&&!t&&this._enabled(!0,!1),this};var O=g("core.SimpleTimeline",function(t){A.call(this,0,t),this.autoRemoveChildren=this.smoothChildTiming=!0});n=O.prototype=new A,n.constructor=O,n.kill()._gc=!1,n._first=n._last=n._recent=null,n._sortChildren=!1,n.add=n.insert=function(t,e){var i,s;if(t._startTime=Number(e||0)+t._delay,t._paused&&this!==t._timeline&&(t._pauseTime=t._startTime+(this.rawTime()-t._startTime)/t._timeScale),t.timeline&&t.timeline._remove(t,!0),t.timeline=t._timeline=this,t._gc&&t._enabled(!0,!0),i=this._last,this._sortChildren)for(s=t._startTime;i&&i._startTime>s;)i=i._prev;return i?(t._next=i._next,i._next=t):(t._next=this._first,this._first=t),t._next?t._next._prev=t:this._last=t,t._prev=i,this._recent=t,this._timeline&&this._uncache(!0),this},n._remove=function(t,e){return t.timeline===this&&(e||t._enabled(!1,!0),t._prev?t._prev._next=t._next:this._first===t&&(this._first=t._next),t._next?t._next._prev=t._prev:this._last===t&&(this._last=t._prev),t._next=t._prev=t.timeline=null,t===this._recent&&(this._recent=this._last),this._timeline&&this._uncache(!0)),this},n.render=function(t,e,i){var s,r=this._first;for(this._totalTime=this._time=this._rawPrevTime=t;r;)s=r._next,(r._active||t>=r._startTime&&!r._paused)&&(r._reversed?r.render((r._dirty?r.totalDuration():r._totalDuration)-(t-r._startTime)*r._timeScale,e,i):r.render((t-r._startTime)*r._timeScale,e,i)),r=s},n.rawTime=function(){return o||a.wake(),this._totalTime};var D=g("TweenLite",function(e,i,s){if(A.call(this,i,s),this.render=D.prototype.render,null==e)throw"Cannot tween a null target.";this.target=e="string"!=typeof e?e:D.selector(e)||e;var r,n,a,o=e.jquery||e.length&&e!==t&&e[0]&&(e[0]===t||e[0].nodeType&&e[0].style&&!e.nodeType),h=this.vars.overwrite;if(this._overwrite=h=null==h?Y[D.defaultOverwrite]:"number"==typeof h?h>>0:Y[h],(o||e instanceof Array||e.push&&c(e))&&"number"!=typeof e[0])for(this._targets=a=u(e),this._propLookup=[],this._siblings=[],r=0;a.length>r;r++)n=a[r],n?"string"!=typeof n?n.length&&n!==t&&n[0]&&(n[0]===t||n[0].nodeType&&n[0].style&&!n.nodeType)?(a.splice(r--,1),this._targets=a=a.concat(u(n))):(this._siblings[r]=V(n,this,!1),1===h&&this._siblings[r].length>1&&W(n,this,null,1,this._siblings[r])):(n=a[r--]=D.selector(n),"string"==typeof n&&a.splice(r+1,1)):a.splice(r--,1);else this._propLookup={},this._siblings=V(e,this,!1),1===h&&this._siblings.length>1&&W(e,this,null,1,this._siblings);(this.vars.immediateRender||0===i&&0===this._delay&&this.vars.immediateRender!==!1)&&(this._time=-_,this.render(-this._delay))},!0),M=function(e){return e&&e.length&&e!==t&&e[0]&&(e[0]===t||e[0].nodeType&&e[0].style&&!e.nodeType)},z=function(t,e){var i,s={};for(i in t)U[i]||i in e&&"transform"!==i&&"x"!==i&&"y"!==i&&"width"!==i&&"height"!==i&&"className"!==i&&"border"!==i||!(!L[i]||L[i]&&L[i]._autoCSS)||(s[i]=t[i],delete t[i]);t.css=s};n=D.prototype=new A,n.constructor=D,n.kill()._gc=!1,n.ratio=0,n._firstPT=n._targets=n._overwrittenProps=n._startAt=null,n._notifyPluginsOfEnabled=n._lazy=!1,D.version="1.14.2",D.defaultEase=n._ease=new T(null,null,1,1),D.defaultOverwrite="auto",D.ticker=a,D.autoSleep=!0,D.lagSmoothing=function(t,e){a.lagSmoothing(t,e)},D.selector=t.$||t.jQuery||function(e){var i=t.$||t.jQuery;return i?(D.selector=i,i(e)):"undefined"==typeof document?e:document.querySelectorAll?document.querySelectorAll(e):document.getElementById("#"===e.charAt(0)?e.substr(1):e)};var I=[],E={},F=D._internals={isArray:c,isSelector:M,lazyTweens:I},L=D._plugins={},N=F.tweenLookup={},X=0,U=F.reservedProps={ease:1,delay:1,overwrite:1,onComplete:1,onCompleteParams:1,onCompleteScope:1,useFrames:1,runBackwards:1,startAt:1,onUpdate:1,onUpdateParams:1,onUpdateScope:1,onStart:1,onStartParams:1,onStartScope:1,onReverseComplete:1,onReverseCompleteParams:1,onReverseCompleteScope:1,onRepeat:1,onRepeatParams:1,onRepeatScope:1,easeParams:1,yoyo:1,immediateRender:1,repeat:1,repeatDelay:1,data:1,paused:1,reversed:1,autoCSS:1,lazy:1,onOverwrite:1},Y={none:0,all:1,auto:2,concurrent:3,allOnStart:4,preexisting:5,"true":1,"false":0},j=A._rootFramesTimeline=new O,B=A._rootTimeline=new O,q=F.lazyRender=function(){var t,e=I.length;for(E={};--e>-1;)t=I[e],t&&t._lazy!==!1&&(t.render(t._lazy[0],t._lazy[1],!0),t._lazy=!1);I.length=0};B._startTime=a.time,j._startTime=a.frame,B._active=j._active=!0,setTimeout(q,1),A._updateRoot=D.render=function(){var t,e,i;if(I.length&&q(),B.render((a.time-B._startTime)*B._timeScale,!1,!1),j.render((a.frame-j._startTime)*j._timeScale,!1,!1),I.length&&q(),!(a.frame%120)){for(i in N){for(e=N[i].tweens,t=e.length;--t>-1;)e[t]._gc&&e.splice(t,1);0===e.length&&delete N[i]}if(i=B._first,(!i||i._paused)&&D.autoSleep&&!j._first&&1===a._listeners.tick.length){for(;i&&i._paused;)i=i._next;i||a.sleep()}}},a.addEventListener("tick",A._updateRoot);var V=function(t,e,i){var s,r,n=t._gsTweenID;if(N[n||(t._gsTweenID=n="t"+X++)]||(N[n]={target:t,tweens:[]}),e&&(s=N[n].tweens,s[r=s.length]=e,i))for(;--r>-1;)s[r]===e&&s.splice(r,1);return N[n].tweens},G=function(t,e,i,s){var r,n,a=t.vars.onOverwrite;return a&&(r=a(t,e,i,s)),a=D.onOverwrite,a&&(n=a(t,e,i,s)),r!==!1&&n!==!1},W=function(t,e,i,s,r){var n,a,o,h;if(1===s||s>=4){for(h=r.length,n=0;h>n;n++)if((o=r[n])!==e)o._gc||G(o,e)&&o._enabled(!1,!1)&&(a=!0);else if(5===s)break;return a}var l,u=e._startTime+_,p=[],c=0,f=0===e._duration;for(n=r.length;--n>-1;)(o=r[n])===e||o._gc||o._paused||(o._timeline!==e._timeline?(l=l||Z(e,0,f),0===Z(o,l,f)&&(p[c++]=o)):u>=o._startTime&&o._startTime+o.totalDuration()/o._timeScale>u&&((f||!o._initted)&&2e-10>=u-o._startTime||(p[c++]=o)));for(n=c;--n>-1;)if(o=p[n],2===s&&o._kill(i,t,e)&&(a=!0),2!==s||!o._firstPT&&o._initted){if(2!==s&&!G(o,e))continue;o._enabled(!1,!1)&&(a=!0)}return a},Z=function(t,e,i){for(var s=t._timeline,r=s._timeScale,n=t._startTime;s._timeline;){if(n+=s._startTime,r*=s._timeScale,s._paused)return-100;s=s._timeline}return n/=r,n>e?n-e:i&&n===e||!t._initted&&2*_>n-e?_:(n+=t.totalDuration()/t._timeScale/r)>e+_?0:n-e-_};n._init=function(){var t,e,i,s,r,n=this.vars,a=this._overwrittenProps,o=this._duration,h=!!n.immediateRender,l=n.ease;if(n.startAt){this._startAt&&(this._startAt.render(-1,!0),this._startAt.kill()),r={};for(s in n.startAt)r[s]=n.startAt[s];if(r.overwrite=!1,r.immediateRender=!0,r.lazy=h&&n.lazy!==!1,r.startAt=r.delay=null,this._startAt=D.to(this.target,0,r),h)if(this._time>0)this._startAt=null;else if(0!==o)return}else if(n.runBackwards&&0!==o)if(this._startAt)this._startAt.render(-1,!0),this._startAt.kill(),this._startAt=null;else{0!==this._time&&(h=!1),i={};for(s in n)U[s]&&"autoCSS"!==s||(i[s]=n[s]);if(i.overwrite=0,i.data="isFromStart",i.lazy=h&&n.lazy!==!1,i.immediateRender=h,this._startAt=D.to(this.target,0,i),h){if(0===this._time)return}else this._startAt._init(),this._startAt._enabled(!1),this.vars.immediateRender&&(this._startAt=null)}if(this._ease=l=l?l instanceof T?l:"function"==typeof l?new T(l,n.easeParams):w[l]||D.defaultEase:D.defaultEase,n.easeParams instanceof Array&&l.config&&(this._ease=l.config.apply(l,n.easeParams)),this._easeType=this._ease._type,this._easePower=this._ease._power,this._firstPT=null,this._targets)for(t=this._targets.length;--t>-1;)this._initProps(this._targets[t],this._propLookup[t]={},this._siblings[t],a?a[t]:null)&&(e=!0);else e=this._initProps(this.target,this._propLookup,this._siblings,a);if(e&&D._onPluginEvent("_onInitAllProps",this),a&&(this._firstPT||"function"!=typeof this.target&&this._enabled(!1,!1)),n.runBackwards)for(i=this._firstPT;i;)i.s+=i.c,i.c=-i.c,i=i._next;this._onUpdate=n.onUpdate,this._initted=!0},n._initProps=function(e,i,s,r){var n,a,o,h,l,_;if(null==e)return!1;E[e._gsTweenID]&&q(),this.vars.css||e.style&&e!==t&&e.nodeType&&L.css&&this.vars.autoCSS!==!1&&z(this.vars,e);for(n in this.vars){if(_=this.vars[n],U[n])_&&(_ instanceof Array||_.push&&c(_))&&-1!==_.join("").indexOf("{self}")&&(this.vars[n]=_=this._swapSelfInParams(_,this));else if(L[n]&&(h=new L[n])._onInitTween(e,this.vars[n],this)){for(this._firstPT=l={_next:this._firstPT,t:h,p:"setRatio",s:0,c:1,f:!0,n:n,pg:!0,pr:h._priority},a=h._overwriteProps.length;--a>-1;)i[h._overwriteProps[a]]=this._firstPT;(h._priority||h._onInitAllProps)&&(o=!0),(h._onDisable||h._onEnable)&&(this._notifyPluginsOfEnabled=!0)}else this._firstPT=i[n]=l={_next:this._firstPT,t:e,p:n,f:"function"==typeof e[n],n:n,pg:!1,pr:0},l.s=l.f?e[n.indexOf("set")||"function"!=typeof e["get"+n.substr(3)]?n:"get"+n.substr(3)]():parseFloat(e[n]),l.c="string"==typeof _&&"="===_.charAt(1)?parseInt(_.charAt(0)+"1",10)*Number(_.substr(2)):Number(_)-l.s||0;l&&l._next&&(l._next._prev=l)}return r&&this._kill(r,e)?this._initProps(e,i,s,r):this._overwrite>1&&this._firstPT&&s.length>1&&W(e,this,i,this._overwrite,s)?(this._kill(i,e),this._initProps(e,i,s,r)):(this._firstPT&&(this.vars.lazy!==!1&&this._duration||this.vars.lazy&&!this._duration)&&(E[e._gsTweenID]=!0),o)},n.render=function(t,e,i){var s,r,n,a,o=this._time,h=this._duration,l=this._rawPrevTime;if(t>=h)this._totalTime=this._time=h,this.ratio=this._ease._calcEnd?this._ease.getRatio(1):1,this._reversed||(s=!0,r="onComplete"),0===h&&(this._initted||!this.vars.lazy||i)&&(this._startTime===this._timeline._duration&&(t=0),(0===t||0>l||l===_)&&l!==t&&(i=!0,l>_&&(r="onReverseComplete")),this._rawPrevTime=a=!e||t||l===t?t:_);else if(1e-7>t)this._totalTime=this._time=0,this.ratio=this._ease._calcEnd?this._ease.getRatio(0):0,(0!==o||0===h&&l>0&&l!==_)&&(r="onReverseComplete",s=this._reversed),0>t&&(this._active=!1,0===h&&(this._initted||!this.vars.lazy||i)&&(l>=0&&(i=!0),this._rawPrevTime=a=!e||t||l===t?t:_)),this._initted||(i=!0);else if(this._totalTime=this._time=t,this._easeType){var u=t/h,p=this._easeType,c=this._easePower;(1===p||3===p&&u>=.5)&&(u=1-u),3===p&&(u*=2),1===c?u*=u:2===c?u*=u*u:3===c?u*=u*u*u:4===c&&(u*=u*u*u*u),this.ratio=1===p?1-u:2===p?u:.5>t/h?u/2:1-u/2}else this.ratio=this._ease.getRatio(t/h);if(this._time!==o||i){if(!this._initted){if(this._init(),!this._initted||this._gc)return;if(!i&&this._firstPT&&(this.vars.lazy!==!1&&this._duration||this.vars.lazy&&!this._duration))return this._time=this._totalTime=o,this._rawPrevTime=l,I.push(this),this._lazy=[t,e],void 0;this._time&&!s?this.ratio=this._ease.getRatio(this._time/h):s&&this._ease._calcEnd&&(this.ratio=this._ease.getRatio(0===this._time?0:1))}for(this._lazy!==!1&&(this._lazy=!1),this._active||!this._paused&&this._time!==o&&t>=0&&(this._active=!0),0===o&&(this._startAt&&(t>=0?this._startAt.render(t,e,i):r||(r="_dummyGS")),this.vars.onStart&&(0!==this._time||0===h)&&(e||this.vars.onStart.apply(this.vars.onStartScope||this,this.vars.onStartParams||y))),n=this._firstPT;n;)n.f?n.t[n.p](n.c*this.ratio+n.s):n.t[n.p]=n.c*this.ratio+n.s,n=n._next;this._onUpdate&&(0>t&&this._startAt&&t!==-1e-4&&this._startAt.render(t,e,i),e||(this._time!==o||s)&&this._onUpdate.apply(this.vars.onUpdateScope||this,this.vars.onUpdateParams||y)),r&&(!this._gc||i)&&(0>t&&this._startAt&&!this._onUpdate&&t!==-1e-4&&this._startAt.render(t,e,i),s&&(this._timeline.autoRemoveChildren&&this._enabled(!1,!1),this._active=!1),!e&&this.vars[r]&&this.vars[r].apply(this.vars[r+"Scope"]||this,this.vars[r+"Params"]||y),0===h&&this._rawPrevTime===_&&a!==_&&(this._rawPrevTime=0))}},n._kill=function(t,e,i){if("all"===t&&(t=null),null==t&&(null==e||e===this.target))return this._lazy=!1,this._enabled(!1,!1);e="string"!=typeof e?e||this._targets||this.target:D.selector(e)||e;\nvar s,r,n,a,o,h,l,_,u;if((c(e)||M(e))&&"number"!=typeof e[0])for(s=e.length;--s>-1;)this._kill(t,e[s])&&(h=!0);else{if(this._targets){for(s=this._targets.length;--s>-1;)if(e===this._targets[s]){o=this._propLookup[s]||{},this._overwrittenProps=this._overwrittenProps||[],r=this._overwrittenProps[s]=t?this._overwrittenProps[s]||{}:"all";break}}else{if(e!==this.target)return!1;o=this._propLookup,r=this._overwrittenProps=t?this._overwrittenProps||{}:"all"}if(o){if(l=t||o,_=t!==r&&"all"!==r&&t!==o&&("object"!=typeof t||!t._tempKill),i&&(D.onOverwrite||this.vars.onOverwrite)){for(n in l)o[n]&&(u||(u=[]),u.push(n));if(!G(this,i,e,u))return!1}for(n in l)(a=o[n])&&(a.pg&&a.t._kill(l)&&(h=!0),a.pg&&0!==a.t._overwriteProps.length||(a._prev?a._prev._next=a._next:a===this._firstPT&&(this._firstPT=a._next),a._next&&(a._next._prev=a._prev),a._next=a._prev=null),delete o[n]),_&&(r[n]=1);!this._firstPT&&this._initted&&this._enabled(!1,!1)}}return h},n.invalidate=function(){return this._notifyPluginsOfEnabled&&D._onPluginEvent("_onDisable",this),this._firstPT=this._overwrittenProps=this._startAt=this._onUpdate=null,this._notifyPluginsOfEnabled=this._active=this._lazy=!1,this._propLookup=this._targets?{}:[],A.prototype.invalidate.call(this),this.vars.immediateRender&&(this._time=-_,this.render(-this._delay)),this},n._enabled=function(t,e){if(o||a.wake(),t&&this._gc){var i,s=this._targets;if(s)for(i=s.length;--i>-1;)this._siblings[i]=V(s[i],this,!0);else this._siblings=V(this.target,this,!0)}return A.prototype._enabled.call(this,t,e),this._notifyPluginsOfEnabled&&this._firstPT?D._onPluginEvent(t?"_onEnable":"_onDisable",this):!1},D.to=function(t,e,i){return new D(t,e,i)},D.from=function(t,e,i){return i.runBackwards=!0,i.immediateRender=0!=i.immediateRender,new D(t,e,i)},D.fromTo=function(t,e,i,s){return s.startAt=i,s.immediateRender=0!=s.immediateRender&&0!=i.immediateRender,new D(t,e,s)},D.delayedCall=function(t,e,i,s,r){return new D(e,0,{delay:t,onComplete:e,onCompleteParams:i,onCompleteScope:s,onReverseComplete:e,onReverseCompleteParams:i,onReverseCompleteScope:s,immediateRender:!1,useFrames:r,overwrite:0})},D.set=function(t,e){return new D(t,0,e)},D.getTweensOf=function(t,e){if(null==t)return[];t="string"!=typeof t?t:D.selector(t)||t;var i,s,r,n;if((c(t)||M(t))&&"number"!=typeof t[0]){for(i=t.length,s=[];--i>-1;)s=s.concat(D.getTweensOf(t[i],e));for(i=s.length;--i>-1;)for(n=s[i],r=i;--r>-1;)n===s[r]&&s.splice(i,1)}else for(s=V(t).concat(),i=s.length;--i>-1;)(s[i]._gc||e&&!s[i].isActive())&&s.splice(i,1);return s},D.killTweensOf=D.killDelayedCallsTo=function(t,e,i){"object"==typeof e&&(i=e,e=!1);for(var s=D.getTweensOf(t,e),r=s.length;--r>-1;)s[r]._kill(i,t)};var Q=g("plugins.TweenPlugin",function(t,e){this._overwriteProps=(t||"").split(","),this._propName=this._overwriteProps[0],this._priority=e||0,this._super=Q.prototype},!0);if(n=Q.prototype,Q.version="1.10.1",Q.API=2,n._firstPT=null,n._addTween=function(t,e,i,s,r,n){var a,o;return null!=s&&(a="number"==typeof s||"="!==s.charAt(1)?Number(s)-i:parseInt(s.charAt(0)+"1",10)*Number(s.substr(2)))?(this._firstPT=o={_next:this._firstPT,t:t,p:e,s:i,c:a,f:"function"==typeof t[e],n:r||e,r:n},o._next&&(o._next._prev=o),o):void 0},n.setRatio=function(t){for(var e,i=this._firstPT,s=1e-6;i;)e=i.c*t+i.s,i.r?e=Math.round(e):s>e&&e>-s&&(e=0),i.f?i.t[i.p](e):i.t[i.p]=e,i=i._next},n._kill=function(t){var e,i=this._overwriteProps,s=this._firstPT;if(null!=t[this._propName])this._overwriteProps=[];else for(e=i.length;--e>-1;)null!=t[i[e]]&&i.splice(e,1);for(;s;)null!=t[s.n]&&(s._next&&(s._next._prev=s._prev),s._prev?(s._prev._next=s._next,s._prev=null):this._firstPT===s&&(this._firstPT=s._next)),s=s._next;return!1},n._roundProps=function(t,e){for(var i=this._firstPT;i;)(t[this._propName]||null!=i.n&&t[i.n.split(this._propName+"_").join("")])&&(i.r=e),i=i._next},D._onPluginEvent=function(t,e){var i,s,r,n,a,o=e._firstPT;if("_onInitAllProps"===t){for(;o;){for(a=o._next,s=r;s&&s.pr>o.pr;)s=s._next;(o._prev=s?s._prev:n)?o._prev._next=o:r=o,(o._next=s)?s._prev=o:n=o,o=a}o=e._firstPT=r}for(;o;)o.pg&&"function"==typeof o.t[t]&&o.t[t]()&&(i=!0),o=o._next;return i},Q.activate=function(t){for(var e=t.length;--e>-1;)t[e].API===Q.API&&(L[(new t[e])._propName]=t[e]);return!0},d.plugin=function(t){if(!(t&&t.propName&&t.init&&t.API))throw"illegal plugin definition.";var e,i=t.propName,s=t.priority||0,r=t.overwriteProps,n={init:"_onInitTween",set:"setRatio",kill:"_kill",round:"_roundProps",initAll:"_onInitAllProps"},a=g("plugins."+i.charAt(0).toUpperCase()+i.substr(1)+"Plugin",function(){Q.call(this,i,s),this._overwriteProps=r||[]},t.global===!0),o=a.prototype=new Q(i);o.constructor=a,a.API=t.API;for(e in n)"function"==typeof t[e]&&(o[n[e]]=t[e]);return a.version=t.version,Q.activate([a]),a},s=t._gsQueue){for(r=0;s.length>r;r++)s[r]();for(n in f)f[n].func||t.console.log("GSAP encountered missing dependency: com.greensock."+n)}o=!1}}("undefined"!=typeof module&&module.exports&&"undefined"!=typeof global?global:this||window,"TweenMax");'
}, function(module) {
    module.exports = "//addEventListener polyfill 1.0 / Eirik Backer / MIT Licence\n(function(win, doc){\n	if(win.addEventListener)return;		//No need to polyfill\n\n	function docHijack(p){var old = doc[p];doc[p] = function(v){return addListen(old(v))}}\n	function addEvent(on, fn, self){\n		return (self = this).attachEvent('on' + on, function(e){\n			var e = e || win.event;\n			e.preventDefault  = e.preventDefault  || function(){e.returnValue = false}\n			e.stopPropagation = e.stopPropagation || function(){e.cancelBubble = true}\n			fn.call(self, e);\n		});\n	}\n	function addListen(obj, i){\n		if(i = obj.length)while(i--)obj[i].addEventListener = addEvent;\n		else obj.addEventListener = addEvent;\n		return obj;\n	}\n\n	addListen([doc, win]);\n	if('Element' in win)win.Element.prototype.addEventListener = addEvent;			//IE8\n	else{		//IE < 8\n		doc.attachEvent('onreadystatechange', function(){addListen(doc.all)});		//Make sure we also init at domReady\n		docHijack('getElementsByTagName');\n		docHijack('getElementById');\n		docHijack('createElement');\n		addListen(doc.all);	\n	}\n})(window, document);"
}, function(module) {
    module.exports = "(function () {\n\nif (typeof window.Element === \"undefined\" || \"classList\" in document.documentElement) return;\n\nvar prototype = Array.prototype,\n    push = prototype.push,\n    splice = prototype.splice,\n    join = prototype.join;\n\nfunction DOMTokenList(el) {\n  this.el = el;\n  // The className needs to be trimmed and split on whitespace\n  // to retrieve a list of classes.\n  var classes = el.className.replace(/^\\s+|\\s+$/g,'').split(/\\s+/);\n  for (var i = 0; i < classes.length; i++) {\n    push.call(this, classes[i]);\n  }\n};\n\nDOMTokenList.prototype = {\n  add: function(token) {\n    if(this.contains(token)) return;\n    push.call(this, token);\n    this.el.className = this.toString();\n  },\n  contains: function(token) {\n    return this.el.className.indexOf(token) != -1;\n  },\n  item: function(index) {\n    return this[index] || null;\n  },\n  remove: function(token) {\n    if (!this.contains(token)) return;\n    for (var i = 0; i < this.length; i++) {\n      if (this[i] == token) break;\n    }\n    splice.call(this, i, 1);\n    this.el.className = this.toString();\n  },\n  toString: function() {\n    return join.call(this, ' ');\n  },\n  toggle: function(token) {\n    if (!this.contains(token)) {\n      this.add(token);\n    } else {\n      this.remove(token);\n    }\n\n    return this.contains(token);\n  }\n};\n\nwindow.DOMTokenList = DOMTokenList;\n\nfunction defineElementGetter (obj, prop, getter) {\n    if (Object.defineProperty) {\n        Object.defineProperty(obj, prop,{\n            get : getter\n        });\n    } else {\n        obj.__defineGetter__(prop, getter);\n    }\n}\n\ndefineElementGetter(Element.prototype, 'classList', function () {\n  return new DOMTokenList(this);\n});\n\n})();"
}, function(module) {
    module.exports = "/*\n * $Id: object-clone.js,v 0.41 2013/03/27 18:29:04 dankogai Exp dankogai $\n *\n *  Licensed under the MIT license.\n *  http://www.opensource.org/licenses/mit-license.php\n *\n */\n\n(function(global) {\n    'use strict';\n    if (!Object.freeze || typeof Object.freeze !== 'function') {\n        throw Error('ES5 support required');\n    }\n    // from ES5\n    var O = Object, OP = O.prototype,\n    create = O.create,\n    defineProperty = O.defineProperty,\n    defineProperties = O.defineProperties,\n    getOwnPropertyNames = O.getOwnPropertyNames,\n    getOwnPropertyDescriptor = O.getOwnPropertyDescriptor,\n    getPrototypeOf = O.getPrototypeOf,\n    freeze = O.freeze,\n    isFrozen = O.isFrozen,\n    isSealed = O.isSealed,\n    seal = O.seal,\n    isExtensible = O.isExtensible,\n    preventExtensions = O.preventExtensions,\n    hasOwnProperty = OP.hasOwnProperty,\n    toString = OP.toString,\n    isArray = Array.isArray,\n    slice = Array.prototype.slice;\n    // Utility functions; some exported\n    function defaults(dst, src) {\n        getOwnPropertyNames(src).forEach(function(k) {\n            if (!hasOwnProperty.call(dst, k)) defineProperty(\n                dst, k, getOwnPropertyDescriptor(src, k)\n            );\n        });\n        return dst;\n    };\n    var isObject = function(o) { return o === Object(o) };\n    var isPrimitive = function(o) { return o !== Object(o) };\n    var isFunction = function(f) { return typeof(f) === 'function' };\n    var signatureOf = function(o) { return toString.call(o) };\n    var HASWEAKMAP = (function() { // paranoia check\n        try {\n            var wm = WeakMap();\n            wm.set(wm, wm);\n            return wm.get(wm) === wm;\n        } catch(e) {\n            return false;\n        }\n    })();\n    // exported\n    function is (x, y) {\n        return x === y\n            ? x !== 0 ? true\n            : (1 / x === 1 / y) // +-0\n        : (x !== x && y !== y); // NaN\n    };\n    function isnt (x, y) { return !is(x, y) };\n    var defaultCK = {\n        descriptors:true,\n        extensibility:true, \n        enumerator:getOwnPropertyNames\n    };\n    function equals (x, y, ck) {\n        var vx, vy;\n        if (HASWEAKMAP) {\n            vx = WeakMap();\n            vy = WeakMap();\n        }\n        ck = defaults(ck || {}, defaultCK);\n        return (function _equals(x, y) {\n            if (isPrimitive(x)) return is(x, y);\n            if (isFunction(x))  return is(x, y);\n            // check deeply\n            var sx = signatureOf(x), sy = signatureOf(y);\n            var i, l, px, py, sx, sy, kx, ky, dx, dy, dk, flt;\n            if (sx !== sy) return false;\n            switch (sx) {\n            case '[object Array]':\n            case '[object Object]':\n                if (ck.extensibility) {\n                    if (isExtensible(x) !== isExtensible(y)) return false;\n                    if (isSealed(x) !== isSealed(y)) return false;\n                    if (isFrozen(x) !== isFrozen(y)) return false;\n                }\n                if (vx) {\n                    if (vx.has(x)) {\n                        // console.log('circular ref found');\n                        return vy.has(y);\n                    }\n                    vx.set(x, true);\n                    vy.set(y, true);\n                }\n                px = ck.enumerator(x);\n                py = ck.enumerator(y);\n                if (ck.filter) {\n                    flt = function(k) {\n                        var d = getOwnPropertyDescriptor(this, k);\n                        return ck.filter(d, k, this);\n                    };\n                    px = px.filter(flt, x);\n                    py = py.filter(flt, y);\n                }\n                if (px.length != py.length) return false;\n                px.sort(); py.sort();\n                for (i = 0, l = px.length; i < l; ++i) {\n                    kx = px[i];\n                    ky = py[i];\n                    if (kx !== ky) return false;\n                    dx = getOwnPropertyDescriptor(x, ky);\n                    dy = getOwnPropertyDescriptor(y, ky);\n                    if ('value' in dx) {\n                        if (!_equals(dx.value, dy.value)) return false;\n                    } else {\n                        if (dx.get && dx.get !== dy.get) return false;\n                        if (dx.set && dx.set !== dy.set) return false;\n                    }\n                    if (ck.descriptors) {\n                        if (dx.enumerable !== dy.enumerable) return false;\n                        if (ck.extensibility) {\n                            if (dx.writable !== dy.writable)\n                                return false;\n                            if (dx.configurable !== dy.configurable)\n                                return false;\n                        }\n                    }\n                }\n                return true;\n            case '[object RegExp]':\n            case '[object Date]':\n            case '[object String]':\n            case '[object Number]':\n            case '[object Boolean]':\n                return ''+x === ''+y;\n            default:\n                throw TypeError(sx + ' not supported');\n            }\n        })(x, y);\n    }\n    function clone(src, deep, ck) {\n        var wm;\n        if (deep && HASWEAKMAP) {\n            wm = WeakMap();\n        }\n        ck = defaults(ck || {}, defaultCK);\n        return (function _clone(src) {\n            // primitives and functions\n            if (isPrimitive(src)) return src;\n            if (isFunction(src)) return src;\n            var sig = signatureOf(src);\n            switch (sig) {\n            case '[object Array]':\n            case '[object Object]':\n                if (wm) {\n                    if (wm.has(src)) {\n                        // console.log('circular ref found');\n                        return src;\n                    }\n                    wm.set(src, true);\n                }\n                var isarray = isArray(src);\n                var dst = isarray ? [] : create(getPrototypeOf(src));\n                ck.enumerator(src).forEach(function(k) {\n                    // Firefox forbids defineProperty(obj, 'length' desc)\n                    if (isarray && k === 'length') {\n                        dst.length = src.length;\n                    } else {\n                        if (ck.descriptors) {\n                            var desc = getOwnPropertyDescriptor(src, k);\n                            if (ck.filter && !ck.filter(desc, k, src)) return;\n                            if (deep && 'value' in desc) \n                                desc.value = _clone(src[k]);\n                            defineProperty(dst, k, desc);\n                        } else {\n                            dst[k] = _clone(src[k]);\n                        }\n                    }\n                });\n                if (ck.extensibility) {\n                    if (!isExtensible(src)) preventExtensions(dst);\n                    if (isSealed(src)) seal(dst);\n                    if (isFrozen(src)) freeze(dst);\n                }\n                return dst;\n            case '[object RegExp]':\n            case '[object Date]':\n            case '[object String]':\n            case '[object Number]':\n            case '[object Boolean]':\n                return deep ? new src.constructor(src.valueOf()) : src;\n            default:\n                throw TypeError(sig + ' is not supported');\n            }\n        })(src);\n    };\n    //  Install\n    var obj2specs = function(src) {\n        var specs = create(null);\n        getOwnPropertyNames(src).forEach(function(k) {\n            specs[k] = {\n                value: src[k],\n                configurable: true,\n                writable: true,\n                enumerable: false\n            };\n        });\n        return specs;\n    };\n    var defaultProperties = function(dst, descs) {\n        getOwnPropertyNames(descs).forEach(function(k) {\n            if (!hasOwnProperty.call(dst, k)) defineProperty(\n                dst, k, descs[k]\n            );\n        });\n        return dst;\n    };\n    (Object.installProperties || defaultProperties)(Object, obj2specs({\n        clone: clone,\n        is: is,\n        isnt: isnt,\n        equals: equals\n    }));\n})(this);\n"
}, function(module) {
    module.exports = "/*\n *  Copyright 2012-2013 (c) Pierre Duquesne <stackp@online.fr>\n *  Licensed under the New BSD License.\n *  https://github.com/stackp/promisejs\n */\n(function(a){function b(){this._callbacks=[];}b.prototype.then=function(a,c){var d;if(this._isdone)d=a.apply(c,this.result);else{d=new b();this._callbacks.push(function(){var b=a.apply(c,arguments);if(b&&typeof b.then==='function')b.then(d.done,d);});}return d;};b.prototype.done=function(){this.result=arguments;this._isdone=true;for(var a=0;a<this._callbacks.length;a++)this._callbacks[a].apply(null,arguments);this._callbacks=[];};function c(a){var c=new b();var d=[];if(!a||!a.length){c.done(d);return c;}var e=0;var f=a.length;function g(a){return function(){e+=1;d[a]=Array.prototype.slice.call(arguments);if(e===f)c.done(d);};}for(var h=0;h<f;h++)a[h].then(g(h));return c;}function d(a,c){var e=new b();if(a.length===0)e.done.apply(e,c);else a[0].apply(null,c).then(function(){a.splice(0,1);d(a,arguments).then(function(){e.done.apply(e,arguments);});});return e;}function e(a){var b=\"\";if(typeof a===\"string\")b=a;else{var c=encodeURIComponent;for(var d in a)if(a.hasOwnProperty(d))b+='&'+c(d)+'='+c(a[d]);}return b;}function f(){var a;if(window.XMLHttpRequest)a=new XMLHttpRequest();else if(window.ActiveXObject)try{a=new ActiveXObject(\"Msxml2.XMLHTTP\");}catch(b){a=new ActiveXObject(\"Microsoft.XMLHTTP\");}return a;}function g(a,c,d,g){var h=new b();var j,k;d=d||{};g=g||{};try{j=f();}catch(l){h.done(i.ENOXHR,\"\");return h;}k=e(d);if(a==='GET'&&k){c+='?'+k;k=null;}j.open(a,c);j.setRequestHeader('Content-type','application/x-www-form-urlencoded');for(var m in g)if(g.hasOwnProperty(m))j.setRequestHeader(m,g[m]);function n(){j.abort();h.done(i.ETIMEOUT,\"\",j);}var o=i.ajaxTimeout;if(o)var p=setTimeout(n,o);j.onreadystatechange=function(){if(o)clearTimeout(p);if(j.readyState===4){var a=(!j.status||(j.status<200||j.status>=300)&&j.status!==304);h.done(a,j.responseText,j);}};j.send(k);return h;}function h(a){return function(b,c,d){return g(a,b,c,d);};}var i={Promise:b,join:c,chain:d,ajax:g,get:h('GET'),post:h('POST'),put:h('PUT'),del:h('DELETE'),ENOXHR:1,ETIMEOUT:2,ajaxTimeout:0};if(typeof define==='function'&&define.amd)define(function(){return i;});else a.promise=i;})(this);"
}, function(module) {
    module.exports = '/*!\n* SoundJS\n* Visit http://createjs.com/ for documentation, updates and examples.\n*\n* Copyright (c) 2010 gskinner.com, inc.\n*\n* Permission is hereby granted, free of charge, to any person\n* obtaining a copy of this software and associated documentation\n* files (the "Software"), to deal in the Software without\n* restriction, including without limitation the rights to use,\n* copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the\n* Software is furnished to do so, subject to the following\n* conditions:\n*\n* The above copyright notice and this permission notice shall be\n* included in all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n* OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n\n//##############################################################################\n// version.js\n//##############################################################################\n\nthis.createjs = this.createjs || {};\n\n(function () {\n\n	/**\n	 * Static class holding library specific information such as the version and buildDate of the library.\n	 * The SoundJS class has been renamed {{#crossLink "Sound"}}{{/crossLink}}.  Please see {{#crossLink "Sound"}}{{/crossLink}}\n	 * for information on using sound.\n	 * @class SoundJS\n	 **/\n	var s = createjs.SoundJS = createjs.SoundJS || {};\n\n	/**\n	 * The version string for this release.\n	 * @property version\n	 * @type String\n	 * @static\n	 **/\n	s.version = /*=version*/"0.6.0"; // injected by build process\n\n	/**\n	 * The build date for this release in UTC format.\n	 * @property buildDate\n	 * @type String\n	 * @static\n	 **/\n	s.buildDate = /*=date*/"Thu, 11 Dec 2014 23:32:09 GMT"; // injected by build process\n\n})();\n\n//##############################################################################\n// extend.js\n//##############################################################################\n\nthis.createjs = this.createjs||{};\n\n/**\n * @class Utility Methods\n */\n\n/**\n * Sets up the prototype chain and constructor property for a new class.\n *\n * This should be called right after creating the class constructor.\n *\n * 	function MySubClass() {}\n * 	createjs.extend(MySubClass, MySuperClass);\n * 	ClassB.prototype.doSomething = function() { }\n *\n * 	var foo = new MySubClass();\n * 	console.log(foo instanceof MySuperClass); // true\n * 	console.log(foo.prototype.constructor === MySubClass); // true\n *\n * @method extends\n * @param {Function} subclass The subclass.\n * @param {Function} superclass The superclass to extend.\n * @return {Function} Returns the subclass\'s new prototype.\n */\ncreatejs.extend = function(subclass, superclass) {\n	"use strict";\n\n	function o() { this.constructor = subclass; }\n	o.prototype = superclass.prototype;\n	return (subclass.prototype = new o());\n};\n\n//##############################################################################\n// promote.js\n//##############################################################################\n\nthis.createjs = this.createjs||{};\n\n/**\n * @class Utility Methods\n */\n\n/**\n * Promotes any methods on the super class that were overridden, by creating an alias in the format `prefix_methodName`.\n * It is recommended to use the super class\'s name as the prefix.\n * An alias to the super class\'s constructor is always added in the format `prefix_constructor`.\n * This allows the subclass to call super class methods without using `function.call`, providing better performance.\n *\n * For example, if `MySubClass` extends `MySuperClass`, and both define a `draw` method, then calling `promote(MySubClass, "MySuperClass")`\n * would add a `MySuperClass_constructor` method to MySubClass and promote the `draw` method on `MySuperClass` to the\n * prototype of `MySubClass` as `MySuperClass_draw`.\n *\n * This should be called after the class\'s prototype is fully defined.\n *\n * 	function ClassA(name) {\n * 		this.name = name;\n * 	}\n * 	ClassA.prototype.greet = function() {\n * 		return "Hello "+this.name;\n * 	}\n *\n * 	function ClassB(name, punctuation) {\n * 		this.ClassA_constructor(name);\n * 		this.punctuation = punctuation;\n * 	}\n * 	createjs.extend(ClassB, ClassA);\n * 	ClassB.prototype.greet = function() {\n * 		return this.ClassA_greet()+this.punctuation;\n * 	}\n * 	createjs.promote(ClassB, "ClassA");\n *\n * 	var foo = new ClassB("World", "!?!");\n * 	console.log(foo.greet()); // Hello World!?!\n *\n * @method promote\n * @param {Function} subclass The class to promote super class methods on.\n * @param {String} prefix The prefix to add to the promoted method names. Usually the name of the superclass.\n * @return {Function} Returns the subclass.\n */\ncreatejs.promote = function(subclass, prefix) {\n	"use strict";\n\n	var subP = subclass.prototype, supP = (Object.getPrototypeOf&&Object.getPrototypeOf(subP))||subP.__proto__;\n	if (supP) {\n		subP[(prefix+="_") + "constructor"] = supP.constructor; // constructor is not always innumerable\n		for (var n in supP) {\n			if (subP.hasOwnProperty(n) && (typeof supP[n] == "function")) { subP[prefix + n] = supP[n]; }\n		}\n	}\n	return subclass;\n};\n\n//##############################################################################\n// IndexOf.js\n//##############################################################################\n\nthis.createjs = this.createjs||{};\n\n/**\n * @class Utility Methods\n */\n\n/**\n * Finds the first occurrence of a specified value searchElement in the passed in array, and returns the index of\n * that value.  Returns -1 if value is not found.\n *\n *      var i = createjs.indexOf(myArray, myElementToFind);\n *\n * @method indexOf\n * @param {Array} array Array to search for searchElement\n * @param searchElement Element to find in array.\n * @return {Number} The first index of searchElement in array.\n */\ncreatejs.indexOf = function (array, searchElement){\n	"use strict";\n\n	for (var i = 0,l=array.length; i < l; i++) {\n		if (searchElement === array[i]) {\n			return i;\n		}\n	}\n	return -1;\n};\n\n//##############################################################################\n// Proxy.js\n//##############################################################################\n\nthis.createjs = this.createjs||{};\n\n/**\n * Various utilities that the CreateJS Suite uses. Utilities are created as separate files, and will be available on the\n * createjs namespace directly.\n *\n * <h4>Example</h4>\n *\n *      myObject.addEventListener("change", createjs.proxy(myMethod, scope));\n *\n * @class Utility Methods\n * @main Utility Methods\n */\n\n(function() {\n	"use strict";\n\n	/**\n	 * A function proxy for methods. By default, JavaScript methods do not maintain scope, so passing a method as a\n	 * callback will result in the method getting called in the scope of the caller. Using a proxy ensures that the\n	 * method gets called in the correct scope.\n	 *\n	 * Additional arguments can be passed that will be applied to the function when it is called.\n	 *\n	 * <h4>Example</h4>\n	 *\n	 *      myObject.addEventListener("event", createjs.proxy(myHandler, this, arg1, arg2));\n	 *\n	 *      function myHandler(arg1, arg2) {\n	 *           // This gets called when myObject.myCallback is executed.\n	 *      }\n	 *\n	 * @method proxy\n	 * @param {Function} method The function to call\n	 * @param {Object} scope The scope to call the method name on\n	 * @param {mixed} [arg] * Arguments that are appended to the callback for additional params.\n	 * @public\n	 * @static\n	 */\n	createjs.proxy = function (method, scope) {\n		var aArgs = Array.prototype.slice.call(arguments, 2);\n		return function () {\n			return method.apply(scope, Array.prototype.slice.call(arguments, 0).concat(aArgs));\n		};\n	}\n\n}());\n\n//##############################################################################\n// definePropertySupported.js\n//##############################################################################\n\nthis.createjs = this.createjs||{};\n\n/**\n * @class Utility Methods\n */\n(function() {\n	"use strict";\n\n	/**\n	 * Boolean value indicating if Object.defineProperty is supported.\n	 *\n	 * <h4>Example</h4>\n	 *\n	 *      if (createjs.definePropertySupported) { // add getter / setter}\n	 *\n	 * @property definePropertySupported\n	 * @type {Boolean}\n	 * @default true\n	 */\n	var t = Object.defineProperty ? true : false;\n\n	// IE8 has Object.defineProperty, but only for DOM objects, so check if fails to suppress errors\n	var foo = {};\n	try {\n		Object.defineProperty(foo, "bar", {\n			get: function () {\n				return this._bar;\n			},\n			set: function (value) {\n				this._bar = value;\n			}\n		});\n	} catch (e) {\n		t = false;\n	}\n\n	createjs.definePropertySupported = t;\n}());\n\n//##############################################################################\n// BrowserDetect.js\n//##############################################################################\n\nthis.createjs = this.createjs||{};\n\n/**\n * @class Utility Methods\n */\n(function() {\n	"use strict";\n\n	/**\n	 * An object that determines the current browser, version, operating system, and other environment\n	 * variables via user agent string.\n	 *\n	 * Used for audio because feature detection is unable to detect the many limitations of mobile devices.\n	 *\n	 * <h4>Example</h4>\n	 *\n	 *      if (createjs.BrowserDetect.isIOS) { // do stuff }\n	 *\n	 * @property BrowserDetect\n	 * @type {Object}\n	 * @param {Boolean} isFirefox True if our browser is Firefox.\n	 * @param {Boolean} isOpera True if our browser is opera.\n	 * @param {Boolean} isChrome True if our browser is Chrome.  Note that Chrome for Android returns true, but is a\n	 * completely different browser with different abilities.\n	 * @param {Boolean} isIOS True if our browser is safari for iOS devices (iPad, iPhone, and iPod).\n	 * @param {Boolean} isAndroid True if our browser is Android.\n	 * @param {Boolean} isBlackberry True if our browser is Blackberry.\n	 * @constructor\n	 * @static\n	 */\n	function BrowserDetect() {\n		throw "BrowserDetect cannot be instantiated";\n	};\n\n	var agent = BrowserDetect.agent = window.navigator.userAgent;\n	BrowserDetect.isWindowPhone = (agent.indexOf("IEMobile") > -1) || (agent.indexOf("Windows Phone") > -1);\n	BrowserDetect.isFirefox = (agent.indexOf("Firefox") > -1);\n	BrowserDetect.isOpera = (window.opera != null);\n	BrowserDetect.isChrome = (agent.indexOf("Chrome") > -1);  // NOTE that Chrome on Android returns true but is a completely different browser with different abilities\n	BrowserDetect.isIOS = (agent.indexOf("iPod") > -1 || agent.indexOf("iPhone") > -1 || agent.indexOf("iPad") > -1) && !BrowserDetect.isWindowPhone;\n	BrowserDetect.isAndroid = (agent.indexOf("Android") > -1) && !BrowserDetect.isWindowPhone;\n	BrowserDetect.isBlackberry = (agent.indexOf("Blackberry") > -1);\n\n	createjs.BrowserDetect = BrowserDetect;\n\n}());\n\n//##############################################################################\n// EventDispatcher.js\n//##############################################################################\n\nthis.createjs = this.createjs||{};\n\n(function() {\n	"use strict";\n\n\n// constructor:\n	/**\n	 * EventDispatcher provides methods for managing queues of event listeners and dispatching events.\n	 *\n	 * You can either extend EventDispatcher or mix its methods into an existing prototype or instance by using the\n	 * EventDispatcher {{#crossLink "EventDispatcher/initialize"}}{{/crossLink}} method.\n	 * \n	 * Together with the CreateJS Event class, EventDispatcher provides an extended event model that is based on the\n	 * DOM Level 2 event model, including addEventListener, removeEventListener, and dispatchEvent. It supports\n	 * bubbling / capture, preventDefault, stopPropagation, stopImmediatePropagation, and handleEvent.\n	 * \n	 * EventDispatcher also exposes a {{#crossLink "EventDispatcher/on"}}{{/crossLink}} method, which makes it easier\n	 * to create scoped listeners, listeners that only run once, and listeners with associated arbitrary data. The \n	 * {{#crossLink "EventDispatcher/off"}}{{/crossLink}} method is merely an alias to\n	 * {{#crossLink "EventDispatcher/removeEventListener"}}{{/crossLink}}.\n	 * \n	 * Another addition to the DOM Level 2 model is the {{#crossLink "EventDispatcher/removeAllEventListeners"}}{{/crossLink}}\n	 * method, which can be used to listeners for all events, or listeners for a specific event. The Event object also \n	 * includes a {{#crossLink "Event/remove"}}{{/crossLink}} method which removes the active listener.\n	 *\n	 * <h4>Example</h4>\n	 * Add EventDispatcher capabilities to the "MyClass" class.\n	 *\n	 *      EventDispatcher.initialize(MyClass.prototype);\n	 *\n	 * Add an event (see {{#crossLink "EventDispatcher/addEventListener"}}{{/crossLink}}).\n	 *\n	 *      instance.addEventListener("eventName", handlerMethod);\n	 *      function handlerMethod(event) {\n	 *          console.log(event.target + " Was Clicked");\n	 *      }\n	 *\n	 * <b>Maintaining proper scope</b><br />\n	 * Scope (ie. "this") can be be a challenge with events. Using the {{#crossLink "EventDispatcher/on"}}{{/crossLink}}\n	 * method to subscribe to events simplifies this.\n	 *\n	 *      instance.addEventListener("click", function(event) {\n	 *          console.log(instance == this); // false, scope is ambiguous.\n	 *      });\n	 *      \n	 *      instance.on("click", function(event) {\n	 *          console.log(instance == this); // true, "on" uses dispatcher scope by default.\n	 *      });\n	 * \n	 * If you want to use addEventListener instead, you may want to use function.bind() or a similar proxy to manage scope.\n	 *      \n	 *\n	 * @class EventDispatcher\n	 * @constructor\n	 **/\n	function EventDispatcher() {\n	\n	\n	// private properties:\n		/**\n		 * @protected\n		 * @property _listeners\n		 * @type Object\n		 **/\n		this._listeners = null;\n		\n		/**\n		 * @protected\n		 * @property _captureListeners\n		 * @type Object\n		 **/\n		this._captureListeners = null;\n	}\n	var p = EventDispatcher.prototype;\n\n\n// static public methods:\n	/**\n	 * Static initializer to mix EventDispatcher methods into a target object or prototype.\n	 * \n	 * 		EventDispatcher.initialize(MyClass.prototype); // add to the prototype of the class\n	 * 		EventDispatcher.initialize(myObject); // add to a specific instance\n	 * \n	 * @method initialize\n	 * @static\n	 * @param {Object} target The target object to inject EventDispatcher methods into. This can be an instance or a\n	 * prototype.\n	 **/\n	EventDispatcher.initialize = function(target) {\n		target.addEventListener = p.addEventListener;\n		target.on = p.on;\n		target.removeEventListener = target.off =  p.removeEventListener;\n		target.removeAllEventListeners = p.removeAllEventListeners;\n		target.hasEventListener = p.hasEventListener;\n		target.dispatchEvent = p.dispatchEvent;\n		target._dispatchEvent = p._dispatchEvent;\n		target.willTrigger = p.willTrigger;\n	};\n	\n\n// public methods:\n	/**\n	 * Adds the specified event listener. Note that adding multiple listeners to the same function will result in\n	 * multiple callbacks getting fired.\n	 *\n	 * <h4>Example</h4>\n	 *\n	 *      displayObject.addEventListener("click", handleClick);\n	 *      function handleClick(event) {\n	 *         // Click happened.\n	 *      }\n	 *\n	 * @method addEventListener\n	 * @param {String} type The string type of the event.\n	 * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when\n	 * the event is dispatched.\n	 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n	 * @return {Function | Object} Returns the listener for chaining or assignment.\n	 **/\n	p.addEventListener = function(type, listener, useCapture) {\n		var listeners;\n		if (useCapture) {\n			listeners = this._captureListeners = this._captureListeners||{};\n		} else {\n			listeners = this._listeners = this._listeners||{};\n		}\n		var arr = listeners[type];\n		if (arr) { this.removeEventListener(type, listener, useCapture); }\n		arr = listeners[type]; // remove may have deleted the array\n		if (!arr) { listeners[type] = [listener];  }\n		else { arr.push(listener); }\n		return listener;\n	};\n	\n	/**\n	 * A shortcut method for using addEventListener that makes it easier to specify an execution scope, have a listener\n	 * only run once, associate arbitrary data with the listener, and remove the listener.\n	 * \n	 * This method works by creating an anonymous wrapper function and subscribing it with addEventListener.\n	 * The created anonymous function is returned for use with .removeEventListener (or .off).\n	 * \n	 * <h4>Example</h4>\n	 * \n	 * 		var listener = myBtn.on("click", handleClick, null, false, {count:3});\n	 * 		function handleClick(evt, data) {\n	 * 			data.count -= 1;\n	 * 			console.log(this == myBtn); // true - scope defaults to the dispatcher\n	 * 			if (data.count == 0) {\n	 * 				alert("clicked 3 times!");\n	 * 				myBtn.off("click", listener);\n	 * 				// alternately: evt.remove();\n	 * 			}\n	 * 		}\n	 * \n	 * @method on\n	 * @param {String} type The string type of the event.\n	 * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when\n	 * the event is dispatched.\n	 * @param {Object} [scope] The scope to execute the listener in. Defaults to the dispatcher/currentTarget for function listeners, and to the listener itself for object listeners (ie. using handleEvent).\n	 * @param {Boolean} [once=false] If true, the listener will remove itself after the first time it is triggered.\n	 * @param {*} [data] Arbitrary data that will be included as the second parameter when the listener is called.\n	 * @param {Boolean} [useCapture=false] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n	 * @return {Function} Returns the anonymous function that was created and assigned as the listener. This is needed to remove the listener later using .removeEventListener.\n	 **/\n	p.on = function(type, listener, scope, once, data, useCapture) {\n		if (listener.handleEvent) {\n			scope = scope||listener;\n			listener = listener.handleEvent;\n		}\n		scope = scope||this;\n		return this.addEventListener(type, function(evt) {\n				listener.call(scope, evt, data);\n				once&&evt.remove();\n			}, useCapture);\n	};\n\n	/**\n	 * Removes the specified event listener.\n	 *\n	 * <b>Important Note:</b> that you must pass the exact function reference used when the event was added. If a proxy\n	 * function, or function closure is used as the callback, the proxy/closure reference must be used - a new proxy or\n	 * closure will not work.\n	 *\n	 * <h4>Example</h4>\n	 *\n	 *      displayObject.removeEventListener("click", handleClick);\n	 *\n	 * @method removeEventListener\n	 * @param {String} type The string type of the event.\n	 * @param {Function | Object} listener The listener function or object.\n	 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n	 **/\n	p.removeEventListener = function(type, listener, useCapture) {\n		var listeners = useCapture ? this._captureListeners : this._listeners;\n		if (!listeners) { return; }\n		var arr = listeners[type];\n		if (!arr) { return; }\n		for (var i=0,l=arr.length; i<l; i++) {\n			if (arr[i] == listener) {\n				if (l==1) { delete(listeners[type]); } // allows for faster checks.\n				else { arr.splice(i,1); }\n				break;\n			}\n		}\n	};\n	\n	/**\n	 * A shortcut to the removeEventListener method, with the same parameters and return value. This is a companion to the\n	 * .on method.\n	 *\n	 * @method off\n	 * @param {String} type The string type of the event.\n	 * @param {Function | Object} listener The listener function or object.\n	 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n	 **/\n	p.off = p.removeEventListener;\n\n	/**\n	 * Removes all listeners for the specified type, or all listeners of all types.\n	 *\n	 * <h4>Example</h4>\n	 *\n	 *      // Remove all listeners\n	 *      displayObject.removeAllEventListeners();\n	 *\n	 *      // Remove all click listeners\n	 *      displayObject.removeAllEventListeners("click");\n	 *\n	 * @method removeAllEventListeners\n	 * @param {String} [type] The string type of the event. If omitted, all listeners for all types will be removed.\n	 **/\n	p.removeAllEventListeners = function(type) {\n		if (!type) { this._listeners = this._captureListeners = null; }\n		else {\n			if (this._listeners) { delete(this._listeners[type]); }\n			if (this._captureListeners) { delete(this._captureListeners[type]); }\n		}\n	};\n\n	/**\n	 * Dispatches the specified event to all listeners.\n	 *\n	 * <h4>Example</h4>\n	 *\n	 *      // Use a string event\n	 *      this.dispatchEvent("complete");\n	 *\n	 *      // Use an Event instance\n	 *      var event = new createjs.Event("progress");\n	 *      this.dispatchEvent(event);\n	 *\n	 * @method dispatchEvent\n	 * @param {Object | String | Event} eventObj An object with a "type" property, or a string type.\n	 * While a generic object will work, it is recommended to use a CreateJS Event instance. If a string is used,\n	 * dispatchEvent will construct an Event instance with the specified type.\n	 * @return {Boolean} Returns the value of eventObj.defaultPrevented.\n	 **/\n	p.dispatchEvent = function(eventObj) {\n		if (typeof eventObj == "string") {\n			// won\'t bubble, so skip everything if there\'s no listeners:\n			var listeners = this._listeners;\n			if (!listeners || !listeners[eventObj]) { return false; }\n			eventObj = new createjs.Event(eventObj);\n		} else if (eventObj.target && eventObj.clone) {\n			// redispatching an active event object, so clone it:\n			eventObj = eventObj.clone();\n		}\n		try { eventObj.target = this; } catch (e) {} // try/catch allows redispatching of native events\n\n		if (!eventObj.bubbles || !this.parent) {\n			this._dispatchEvent(eventObj, 2);\n		} else {\n			var top=this, list=[top];\n			while (top.parent) { list.push(top = top.parent); }\n			var i, l=list.length;\n\n			// capture & atTarget\n			for (i=l-1; i>=0 && !eventObj.propagationStopped; i--) {\n				list[i]._dispatchEvent(eventObj, 1+(i==0));\n			}\n			// bubbling\n			for (i=1; i<l && !eventObj.propagationStopped; i++) {\n				list[i]._dispatchEvent(eventObj, 3);\n			}\n		}\n		return eventObj.defaultPrevented;\n	};\n\n	/**\n	 * Indicates whether there is at least one listener for the specified event type.\n	 * @method hasEventListener\n	 * @param {String} type The string type of the event.\n	 * @return {Boolean} Returns true if there is at least one listener for the specified event.\n	 **/\n	p.hasEventListener = function(type) {\n		var listeners = this._listeners, captureListeners = this._captureListeners;\n		return !!((listeners && listeners[type]) || (captureListeners && captureListeners[type]));\n	};\n	\n	/**\n	 * Indicates whether there is at least one listener for the specified event type on this object or any of its\n	 * ancestors (parent, parent\'s parent, etc). A return value of true indicates that if a bubbling event of the\n	 * specified type is dispatched from this object, it will trigger at least one listener.\n	 * \n	 * This is similar to {{#crossLink "EventDispatcher/hasEventListener"}}{{/crossLink}}, but it searches the entire\n	 * event flow for a listener, not just this object.\n	 * @method willTrigger\n	 * @param {String} type The string type of the event.\n	 * @return {Boolean} Returns `true` if there is at least one listener for the specified event.\n	 **/\n	p.willTrigger = function(type) {\n		var o = this;\n		while (o) {\n			if (o.hasEventListener(type)) { return true; }\n			o = o.parent;\n		}\n		return false;\n	};\n\n	/**\n	 * @method toString\n	 * @return {String} a string representation of the instance.\n	 **/\n	p.toString = function() {\n		return "[EventDispatcher]";\n	};\n\n\n// private methods:\n	/**\n	 * @method _dispatchEvent\n	 * @param {Object | String | Event} eventObj\n	 * @param {Object} eventPhase\n	 * @protected\n	 **/\n	p._dispatchEvent = function(eventObj, eventPhase) {\n		var l, listeners = (eventPhase==1) ? this._captureListeners : this._listeners;\n		if (eventObj && listeners) {\n			var arr = listeners[eventObj.type];\n			if (!arr||!(l=arr.length)) { return; }\n			try { eventObj.currentTarget = this; } catch (e) {}\n			try { eventObj.eventPhase = eventPhase; } catch (e) {}\n			eventObj.removed = false;\n			\n			arr = arr.slice(); // to avoid issues with items being removed or added during the dispatch\n			for (var i=0; i<l && !eventObj.immediatePropagationStopped; i++) {\n				var o = arr[i];\n				if (o.handleEvent) { o.handleEvent(eventObj); }\n				else { o(eventObj); }\n				if (eventObj.removed) {\n					this.off(eventObj.type, o, eventPhase==1);\n					eventObj.removed = false;\n				}\n			}\n		}\n	};\n\n\n	createjs.EventDispatcher = EventDispatcher;\n}());\n\n//##############################################################################\n// Event.js\n//##############################################################################\n\nthis.createjs = this.createjs||{};\n\n(function() {\n	"use strict";\n\n// constructor:\n	/**\n	 * Contains properties and methods shared by all events for use with\n	 * {{#crossLink "EventDispatcher"}}{{/crossLink}}.\n	 * \n	 * Note that Event objects are often reused, so you should never\n	 * rely on an event object\'s state outside of the call stack it was received in.\n	 * @class Event\n	 * @param {String} type The event type.\n	 * @param {Boolean} bubbles Indicates whether the event will bubble through the display list.\n	 * @param {Boolean} cancelable Indicates whether the default behaviour of this event can be cancelled.\n	 * @constructor\n	 **/\n	function Event(type, bubbles, cancelable) {\n		\n	\n	// public properties:\n		/**\n		 * The type of event.\n		 * @property type\n		 * @type String\n		 **/\n		this.type = type;\n	\n		/**\n		 * The object that generated an event.\n		 * @property target\n		 * @type Object\n		 * @default null\n		 * @readonly\n		*/\n		this.target = null;\n	\n		/**\n		 * The current target that a bubbling event is being dispatched from. For non-bubbling events, this will\n		 * always be the same as target. For example, if childObj.parent = parentObj, and a bubbling event\n		 * is generated from childObj, then a listener on parentObj would receive the event with\n		 * target=childObj (the original target) and currentTarget=parentObj (where the listener was added).\n		 * @property currentTarget\n		 * @type Object\n		 * @default null\n		 * @readonly\n		*/\n		this.currentTarget = null;\n	\n		/**\n		 * For bubbling events, this indicates the current event phase:<OL>\n		 * 	<LI> capture phase: starting from the top parent to the target</LI>\n		 * 	<LI> at target phase: currently being dispatched from the target</LI>\n		 * 	<LI> bubbling phase: from the target to the top parent</LI>\n		 * </OL>\n		 * @property eventPhase\n		 * @type Number\n		 * @default 0\n		 * @readonly\n		*/\n		this.eventPhase = 0;\n	\n		/**\n		 * Indicates whether the event will bubble through the display list.\n		 * @property bubbles\n		 * @type Boolean\n		 * @default false\n		 * @readonly\n		*/\n		this.bubbles = !!bubbles;\n	\n		/**\n		 * Indicates whether the default behaviour of this event can be cancelled via\n		 * {{#crossLink "Event/preventDefault"}}{{/crossLink}}. This is set via the Event constructor.\n		 * @property cancelable\n		 * @type Boolean\n		 * @default false\n		 * @readonly\n		*/\n		this.cancelable = !!cancelable;\n	\n		/**\n		 * The epoch time at which this event was created.\n		 * @property timeStamp\n		 * @type Number\n		 * @default 0\n		 * @readonly\n		*/\n		this.timeStamp = (new Date()).getTime();\n	\n		/**\n		 * Indicates if {{#crossLink "Event/preventDefault"}}{{/crossLink}} has been called\n		 * on this event.\n		 * @property defaultPrevented\n		 * @type Boolean\n		 * @default false\n		 * @readonly\n		*/\n		this.defaultPrevented = false;\n	\n		/**\n		 * Indicates if {{#crossLink "Event/stopPropagation"}}{{/crossLink}} or\n		 * {{#crossLink "Event/stopImmediatePropagation"}}{{/crossLink}} has been called on this event.\n		 * @property propagationStopped\n		 * @type Boolean\n		 * @default false\n		 * @readonly\n		*/\n		this.propagationStopped = false;\n	\n		/**\n		 * Indicates if {{#crossLink "Event/stopImmediatePropagation"}}{{/crossLink}} has been called\n		 * on this event.\n		 * @property immediatePropagationStopped\n		 * @type Boolean\n		 * @default false\n		 * @readonly\n		*/\n		this.immediatePropagationStopped = false;\n		\n		/**\n		 * Indicates if {{#crossLink "Event/remove"}}{{/crossLink}} has been called on this event.\n		 * @property removed\n		 * @type Boolean\n		 * @default false\n		 * @readonly\n		*/\n		this.removed = false;\n	}\n	var p = Event.prototype;\n	\n\n// public methods:\n	/**\n	 * Sets {{#crossLink "Event/defaultPrevented"}}{{/crossLink}} to true.\n	 * Mirrors the DOM event standard.\n	 * @method preventDefault\n	 **/\n	p.preventDefault = function() {\n		this.defaultPrevented = this.cancelable&&true;\n	};\n\n	/**\n	 * Sets {{#crossLink "Event/propagationStopped"}}{{/crossLink}} to true.\n	 * Mirrors the DOM event standard.\n	 * @method stopPropagation\n	 **/\n	p.stopPropagation = function() {\n		this.propagationStopped = true;\n	};\n\n	/**\n	 * Sets {{#crossLink "Event/propagationStopped"}}{{/crossLink}} and\n	 * {{#crossLink "Event/immediatePropagationStopped"}}{{/crossLink}} to true.\n	 * Mirrors the DOM event standard.\n	 * @method stopImmediatePropagation\n	 **/\n	p.stopImmediatePropagation = function() {\n		this.immediatePropagationStopped = this.propagationStopped = true;\n	};\n	\n	/**\n	 * Causes the active listener to be removed via removeEventListener();\n	 * \n	 * 		myBtn.addEventListener("click", function(evt) {\n	 * 			// do stuff...\n	 * 			evt.remove(); // removes this listener.\n	 * 		});\n	 * \n	 * @method remove\n	 **/\n	p.remove = function() {\n		this.removed = true;\n	};\n	\n	/**\n	 * Returns a clone of the Event instance.\n	 * @method clone\n	 * @return {Event} a clone of the Event instance.\n	 **/\n	p.clone = function() {\n		return new Event(this.type, this.bubbles, this.cancelable);\n	};\n	\n	/**\n	 * Provides a chainable shortcut method for setting a number of properties on the instance.\n	 *\n	 * @method set\n	 * @param {Object} props A generic object containing properties to copy to the instance.\n	 * @return {Event} Returns the instance the method is called on (useful for chaining calls.)\n	 * @chainable\n	*/\n	p.set = function(props) {\n		for (var n in props) { this[n] = props[n]; }\n		return this;\n	};\n\n	/**\n	 * Returns a string representation of this object.\n	 * @method toString\n	 * @return {String} a string representation of the instance.\n	 **/\n	p.toString = function() {\n		return "[Event (type="+this.type+")]";\n	};\n\n	createjs.Event = Event;\n}());\n\n//##############################################################################\n// ErrorEvent.js\n//##############################################################################\n\nthis.createjs = this.createjs||{};\n\n(function() {\n	"use strict";\n\n	/**\n	 * A general error {{#crossLink "Event"}}{{/crossLink}}, that describes an error that occurred, as well as any details.\n	 * @class ErrorEvent\n	 * @param {String} [title] The error title\n	 * @param {String} [message] The error description\n	 * @param {Object} [data] Additional error data\n	 * @constructor\n	 */\n	function ErrorEvent(title, message, data) {\n		this.Event_constructor("error");\n\n		/**\n		 * The short error title, which indicates the type of error that occurred.\n		 * @property title\n		 * @type String\n		 */\n		this.title = title;\n\n		/**\n		 * The verbose error message, containing details about the error.\n		 * @property message\n		 * @type String\n		 */\n		this.message = message;\n\n		/**\n		 * Additional data attached to an error.\n		 * @property data\n		 * @type {Object}\n		 */\n		this.data = data;\n	}\n\n	var p = createjs.extend(ErrorEvent, createjs.Event);\n\n	p.clone = function() {\n		return new createjs.ErrorEvent(this.title, this.message, this.data);\n	};\n\n	createjs.ErrorEvent = createjs.promote(ErrorEvent, "Event");\n\n}());\n\n//##############################################################################\n// ProgressEvent.js\n//##############################################################################\n\nthis.createjs = this.createjs || {};\n\n(function (scope) {\n	"use strict";\n\n	// constructor\n	/**\n	 * A createjs {{#crossLink "Event"}}{{/crossLink}} that is dispatched when progress changes.\n	 * @class ProgressEvent\n	 * @param {Number} loaded The amount that has been loaded. This can be any number relative to the total.\n	 * @param {Number} [total] The total amount that will load. This will default to 0, so does not need to be passed in,\n	 * as long as the loaded value is a progress value (between 0 and 1).\n	 * @todo Consider having this event be a "fileprogress" event as well\n	 * @constructor\n	 */\n	function ProgressEvent(loaded, total) {\n		this.Event_constructor("progress");\n\n		/**\n		 * The amount that has been loaded (out of a total amount)\n		 * @property loaded\n		 * @type {Number}\n		 */\n		this.loaded = loaded;\n\n		/**\n		 * The total "size" of the load.\n		 * @property total\n		 * @type {Number}\n		 * @default 1\n		 */\n		this.total = (total == null) ? 1 : total;\n\n		/**\n		 * The percentage (out of 1) that the load has been completed. This is calculated using `loaded/total`.\n		 * @property progress\n		 * @type {Number}\n		 * @default 0\n		 */\n		this.progress = (total == 0) ? 0 : this.loaded / this.total;\n	};\n\n	var p = createjs.extend(ProgressEvent, createjs.Event);\n\n	/**\n	 * Returns a clone of the ProgressEvent instance.\n	 * @method clone\n	 * @return {ProgressEvent} a clone of the Event instance.\n	 **/\n	p.clone = function() {\n		return new createjs.ProgressEvent(this.loaded, this.total);\n	};\n\n	createjs.ProgressEvent = createjs.promote(ProgressEvent, "Event");\n\n}(window));\n\n//##############################################################################\n// LoadItem.js\n//##############################################################################\n\nthis.createjs = this.createjs || {};\n\n(function () {\n	"use strict";\n\n	/**\n	 * All loaders accept an item containing the properties defined in this class. If a raw object is passed instead,\n	 * it will not be affected, but it must contain at least a {{#crossLink "src:property"}}{{/crossLink}} property. A\n	 * string path or HTML tag is also acceptable, but it will be automatically converted to a LoadItem using the\n	 * {{#crossLink "create"}}{{/crossLink}} method by {{#crossLink "AbstractLoader"}}{{/crossLink}}\n	 * @class LoadItem\n	 * @constructor\n	 * @since 0.6.0\n	 */\n	function LoadItem() {\n		/**\n		 * The source of the file that is being loaded. This property is <b>required</b>. The source can either be a\n		 * string (recommended), or an HTML tag.</li>\n		 * @property src\n		 * @type {String}\n		 * @default null\n		 */\n		this.src = null;\n\n		/**\n		 * The source of the file that is being loaded. This property is <strong>required</strong>. The source can\n		 * either be a string (recommended), or an HTML tag. See the {{#crossLink "AbstractLoader"}}{{/crossLink}}\n		 * class for the full list of supported types.\n		 * @property type\n		 * @type {String}\n		 * @default null\n		 */\n		this.type = null;\n\n		/**\n		 * A string identifier which can be used to reference the loaded object. If none is provided, this will be\n		 * automatically set to the {{#crossLink "src:property"}}{{/crossLink}}.\n		 * @property id\n		 * @type {String}\n		 * @default null\n		 */\n		this.id = null;\n\n		/**\n		 * Determines if a manifest will maintain the order of this item, in relation to other items in the manifest\n		 * that have also set the `maintainOrder` property to `true`. This only applies when the max connections has\n		 * been set above 1 (using {{#crossLink "LoadQueue/setMaxConnections"}}{{/crossLink}}). Everything with this\n		 * property set to `false` will finish as it is loaded. Ordered items are combined with script tags loading in\n		 * order when {{#crossLink "LoadQueue/maintainScriptOrder:property"}}{{/crossLink}} is set to `true`.\n		 * @property maintainOrder\n		 * @type {Boolean}\n		 * @default false\n		 */\n		this.maintainOrder = false;\n\n		/**\n		 * A callback used by JSONP requests that defines what global method to call when the JSONP content is loaded.\n		 * @property callback\n		 * @type {String}\n		 * @default null\n		 */\n		this.callback = null;\n\n		/**\n		 * An arbitrary data object, which is included with the loaded object.\n		 * @property data\n		 * @type {Object}\n		 * @default null\n		 */\n		this.data = null;\n\n		/**\n		 * The request method used for HTTP calls. Both {{#crossLink "AbstractLoader/GET:property"}}{{/crossLink}} or\n		 * {{#crossLink "AbstractLoader/POST:property"}}{{/crossLink}} request types are supported, and are defined as\n		 * constants on {{#crossLink "AbstractLoader"}}{{/crossLink}}.\n		 * @property method\n		 * @type {String}\n		 * @default get\n		 */\n		this.method = createjs.LoadItem.GET;\n\n		/**\n		 * An object hash of name/value pairs to send to the server.\n		 * @property values\n		 * @type {Object}\n		 * @default null\n		 */\n		this.values = null;\n\n		/**\n		 * An object hash of headers to attach to an XHR request. PreloadJS will automatically attach some default\n		 * headers when required, including "Origin", "Content-Type", and "X-Requested-With". You may override the\n		 * default headers by including them in your headers object.\n		 * @property headers\n		 * @type {Object}\n		 * @default null\n		 */\n		this.headers = null;\n\n		/**\n		 * Enable credentials for XHR requests.\n		 * @property withCredentials\n		 * @type {Boolean}\n		 * @default false\n		 */\n		this.withCredentials = false;\n\n		/**\n		 * Set the mime type of XHR-based requests. This is automatically set to "text/plain; charset=utf-8" for text\n		 * based files (json, xml, text, css, js).\n		 * @property mimeType\n		 * @type {String}\n		 * @default null\n		 */\n		this.mimeType = null;\n\n		/**\n		 * Sets the crossOrigin attribute for CORS-enabled images loading cross-domain.\n		 * @property crossOrigin\n		 * @type {boolean}\n		 * @default Anonymous\n		 */\n		this.crossOrigin = "Anonymous";\n\n		/**\n		 * The duration in milliseconds to wait before a request times out. This only applies to tag-based and and XHR\n		 * (level one) loading, as XHR (level 2) provides its own timeout event.\n		 * @property loadTimeout\n		 * @type {Number}\n		 * @default 8000 (8 seconds)\n		 */\n		this.loadTimeout = 8000;\n	};\n\n	var p = LoadItem.prototype = {};\n	var s = LoadItem;\n\n	/**\n	 * Create/validate a LoadItem.\n	 * <ul>\n	 *     <li>String-based items are converted to a LoadItem with a populated {{#crossLink "src:property"}}{{/crossLink}}.</li>\n	 *     <li>LoadItem instances are returned as-is</li>\n	 *     <li>Objectss are returned as-is</li>\n	 * </ul>\n	 * @method create\n	 * @param {LoadItem|String|Object} value The load item value\n	 * @returns {Object|LoadItem}\n	 * @static\n	 */\n	s.create = function (value) {\n		if (typeof value == "string") {\n			var item = new LoadItem();\n			item.src = value;\n			return item;\n		} else if (value instanceof s) {\n			return value;\n		} else if (value instanceof Object) { // Don\'t modify object, allows users to attach random data to the item.\n			// TODO: Disallow objects with no src?\n			return value;\n		} else {\n			throw new Error("Type not recognized.");\n		}\n	};\n\n	/**\n	 * Provides a chainable shortcut method for setting a number of properties on the instance.\n	 *\n	 * <h4>Example</h4>\n	 *\n	 *      var loadItem = new createjs.LoadItem().set({src:"image.png", maintainOrder:true});\n	 *\n	 * @method set\n	 * @param {Object} props A generic object containing properties to copy to the LoadItem instance.\n	 * @return {LoadItem} Returns the instance the method is called on (useful for chaining calls.)\n	*/\n	p.set = function(props) {\n		for (var n in props) { this[n] = props[n]; }\n		return this;\n	};\n\n	createjs.LoadItem = s;\n\n}());\n\n//##############################################################################\n// RequestUtils.js\n//##############################################################################\n\n(function () {\n\n	/**\n	 * Utilities that assist with parsing load items, and determining file types, etc.\n	 * @class RequestUtils\n	 */\n	var s = {};\n\n	/**\n	 * The Regular Expression used to test file URLS for an absolute path.\n	 * @property ABSOLUTE_PATH\n	 * @type {RegExp}\n	 * @static\n	 */\n	s.ABSOLUTE_PATT = /^(?:\\w+:)?\\/{2}/i;\n\n	/**\n	 * The Regular Expression used to test file URLS for an absolute path.\n	 * @property RELATIVE_PATH\n	 * @type {RegExp}\n	 * @static\n	 */\n	s.RELATIVE_PATT = (/^[./]*?\\//i);\n\n	/**\n	 * The Regular Expression used to test file URLS for an extension. Note that URIs must already have the query string\n	 * removed.\n	 * @property EXTENSION_PATT\n	 * @type {RegExp}\n	 * @static\n	 */\n	s.EXTENSION_PATT = /\\/?[^/]+\\.(\\w{1,5})$/i;\n\n	/**\n	 * Parse a file path to determine the information we need to work with it. Currently, PreloadJS needs to know:\n	 * <ul>\n	 *     <li>If the path is absolute. Absolute paths start with a protocol (such as `http://`, `file://`, or\n	 *     `//networkPath`)</li>\n	 *     <li>If the path is relative. Relative paths start with `../` or `/path` (or similar)</li>\n	 *     <li>The file extension. This is determined by the filename with an extension. Query strings are dropped, and\n	 *     the file path is expected to follow the format `name.ext`.</li>\n	 * </ul>\n	 * @method parseURI\n	 * @param {String} path\n	 * @returns {Object} An Object with an `absolute` and `relative` Boolean values, as well as an optional \'extension`\n	 * property, which is the lowercase extension.\n	 * @static\n	 */\n	s.parseURI = function (path) {\n		var info = {absolute: false, relative: false};\n		if (path == null) { return info; }\n\n		// Drop the query string\n		var queryIndex = path.indexOf("?");\n		if (queryIndex > -1) {\n			path = path.substr(0, queryIndex);\n		}\n\n		// Absolute\n		var match;\n		if (s.ABSOLUTE_PATT.test(path)) {\n			info.absolute = true;\n\n			// Relative\n		} else if (s.RELATIVE_PATT.test(path)) {\n			info.relative = true;\n		}\n\n		// Extension\n		if (match = path.match(s.EXTENSION_PATT)) {\n			info.extension = match[1].toLowerCase();\n		}\n		return info;\n	};\n\n	/**\n	 * Formats an object into a query string for either a POST or GET request.\n	 * @method formatQueryString\n	 * @param {Object} data The data to convert to a query string.\n	 * @param {Array} [query] Existing name/value pairs to append on to this query.\n	 * @static\n	 */\n	s.formatQueryString = function (data, query) {\n		if (data == null) {\n			throw new Error(\'You must specify data.\');\n		}\n		var params = [];\n		for (var n in data) {\n			params.push(n + \'=\' + escape(data[n]));\n		}\n		if (query) {\n			params = params.concat(query);\n		}\n		return params.join(\'&\');\n	};\n\n	/**\n	 * A utility method that builds a file path using a source and a data object, and formats it into a new path.\n	 * @method buildPath\n	 * @param {String} src The source path to add values to.\n	 * @param {Object} [data] Object used to append values to this request as a query string. Existing parameters on the\n	 * path will be preserved.\n	 * @returns {string} A formatted string that contains the path and the supplied parameters.\n	 * @static\n	 */\n	s.buildPath = function (src, data) {\n		if (data == null) {\n			return src;\n		}\n\n		var query = [];\n		var idx = src.indexOf(\'?\');\n\n		if (idx != -1) {\n			var q = src.slice(idx + 1);\n			query = query.concat(q.split(\'&\'));\n		}\n\n		if (idx != -1) {\n			return src.slice(0, idx) + \'?\' + this._formatQueryString(data, query);\n		} else {\n			return src + \'?\' + this._formatQueryString(data, query);\n		}\n	};\n\n	/**\n	 * @method isCrossDomain\n	 * @param {LoadItem|Object} item A load item with a `src` property.\n	 * @return {Boolean} If the load item is loading from a different domain than the current location.\n	 * @static\n	 */\n	s.isCrossDomain = function (item) {\n		var target = document.createElement("a");\n		target.href = item.src;\n\n		var host = document.createElement("a");\n		host.href = location.href;\n\n		var crossdomain = (target.hostname != "") &&\n						  (target.port != host.port ||\n						   target.protocol != host.protocol ||\n						   target.hostname != host.hostname);\n		return crossdomain;\n	};\n\n	/**\n	 * @method isLocal\n	 * @param {LoadItem|Object} item A load item with a `src` property\n	 * @return {Boolean} If the load item is loading from the "file:" protocol. Assume that the host must be local as\n	 * well.\n	 * @static\n	 */\n	s.isLocal = function (item) {\n		var target = document.createElement("a");\n		target.href = item.src;\n		return target.hostname == "" && target.protocol == "file:";\n	};\n\n	/**\n	 * Determine if a specific type should be loaded as a binary file. Currently, only images and items marked\n	 * specifically as "binary" are loaded as binary. Note that audio is <b>not</b> a binary type, as we can not play\n	 * back using an audio tag if it is loaded as binary. Plugins can change the item type to binary to ensure they get\n	 * a binary result to work with. Binary files are loaded using XHR2. Types are defined as static constants on\n	 * {{#crossLink "AbstractLoader"}}{{/crossLink}}.\n	 * @method isBinary\n	 * @param {String} type The item type.\n	 * @return {Boolean} If the specified type is binary.\n	 * @static\n	 */\n	s.isBinary = function (type) {\n		switch (type) {\n			case createjs.AbstractLoader.IMAGE:\n			case createjs.AbstractLoader.BINARY:\n				return true;\n			default:\n				return false;\n		}\n	};\n\n	/**\n	 * Check if item is a valid HTMLImageElement\n	 * @method isImageTag\n	 * @param {Object} item\n	 * @returns {Boolean}\n	 * @static\n	 */\n	s.isImageTag = function(item) {\n		return item instanceof HTMLImageElement;\n	};\n\n	/**\n	 * Check if item is a valid HTMLAudioElement\n	 * @method isAudioTag\n	 * @param {Object} item\n	 * @returns {Boolean}\n	 * @static\n	 */\n	s.isAudioTag = function(item) {\n		if (window.HTMLAudioElement) {\n			return item instanceof HTMLAudioElement;\n		} else {\n			return false;\n		}\n	};\n\n	/**\n	 * Check if item is a valid HTMLVideoElement\n	 * @method isVideoTag\n	 * @param {Objectitem\n	 * @returns {Boolean}\n	 * @static\n	 */\n	s.isVideoTag = function(item) {\n		if (window.HTMLVideoElement) {\n			return item instanceof HTMLVideoElement;\n		} else {\n			false;\n		}\n	};\n\n	/**\n	 * Determine if a specific type is a text-based asset, and should be loaded as UTF-8.\n	 * @method isText\n	 * @param {String} type The item type.\n	 * @return {Boolean} If the specified type is text.\n	 * @static\n	 */\n	s.isText = function (type) {\n		switch (type) {\n			case createjs.AbstractLoader.TEXT:\n			case createjs.AbstractLoader.JSON:\n			case createjs.AbstractLoader.MANIFEST:\n			case createjs.AbstractLoader.XML:\n			case createjs.AbstractLoader.CSS:\n			case createjs.AbstractLoader.SVG:\n			case createjs.AbstractLoader.JAVASCRIPT:\n				return true;\n			default:\n				return false;\n		}\n	};\n\n	/**\n	 * Determine the type of the object using common extensions. Note that the type can be passed in with the load item\n	 * if it is an unusual extension.\n	 * @method getTypeByExtension\n	 * @param {String} extension The file extension to use to determine the load type.\n	 * @return {String} The determined load type (for example, <code>AbstractLoader.IMAGE</code>). Will return `null` if\n	 * the type can not be determined by the extension.\n	 * @static\n	 */\n	s.getTypeByExtension = function (extension) {\n		if (extension == null) {\n			return createjs.AbstractLoader.TEXT;\n		}\n\n		switch (extension.toLowerCase()) {\n			case "jpeg":\n			case "jpg":\n			case "gif":\n			case "png":\n			case "webp":\n			case "bmp":\n				return createjs.AbstractLoader.IMAGE;\n			case "ogg":\n			case "mp3":\n			case "webm":\n				return createjs.AbstractLoader.SOUND;\n			case "mp4":\n			case "webm":\n			case "ts":\n				return createjs.AbstractLoader.VIDEO;\n			case "json":\n				return createjs.AbstractLoader.JSON;\n			case "xml":\n				return createjs.AbstractLoader.XML;\n			case "css":\n				return createjs.AbstractLoader.CSS;\n			case "js":\n				return createjs.AbstractLoader.JAVASCRIPT;\n			case \'svg\':\n				return createjs.AbstractLoader.SVG;\n			default:\n				return createjs.AbstractLoader.TEXT;\n		}\n	};\n\n	createjs.RequestUtils = s;\n\n}());\n\n//##############################################################################\n// AbstractLoader.js\n//##############################################################################\n\nthis.createjs = this.createjs || {};\n\n(function () {\n	"use strict";\n\n// constructor\n	/**\n	 * The base loader, which defines all the generic methods, properties, and events. All loaders extend this class,\n	 * including the {{#crossLink "LoadQueue"}}{{/crossLink}}.\n	 * @class AbstractLoader\n	 * @param {LoadItem|object|string} The item to be loaded.\n	 * @param {Boolean} [preferXHR] Determines if the LoadItem should <em>try</em> and load using XHR, or take a\n	 * tag-based approach, which can be better in cross-domain situations. Not all loaders can load using one or the\n	 * other, so this is a suggested directive.\n	 * @oaram {String} [type] The type of loader. Loader types are defined as constants on the AbstractLoader class,\n	 * such as {{#crossLink "IMAGE:property"}}{{/crossLink}}, {{#crossLink "CSS:property"}}{{/crossLink}}, etc.\n	 * @extends EventDispatcher\n	 */\n	function AbstractLoader(loadItem, preferXHR, type) {\n		this.EventDispatcher_constructor();\n\n		// public properties\n		/**\n		 * If the loader has completed loading. This provides a quick check, but also ensures that the different approaches\n		 * used for loading do not pile up resulting in more than one `complete` {{#crossLink "Event"}}{{/crossLink}}.\n		 * @property loaded\n		 * @type {Boolean}\n		 * @default false\n		 */\n		this.loaded = false;\n\n		/**\n		 * Determine if the loader was canceled. Canceled loads will not fire complete events. Note that this property\n		 * is readonly, so {{#crossLink "LoadQueue"}}{{/crossLink}} queues should be closed using {{#crossLink "LoadQueue/close"}}{{/crossLink}}\n		 * instead.\n		 * @property canceled\n		 * @type {Boolean}\n		 * @default false\n		 */\n		this.canceled = false;\n\n		/**\n		 * The current load progress (percentage) for this item. This will be a number between 0 and 1.\n		 *\n		 * <h4>Example</h4>\n		 *\n		 *     var queue = new createjs.LoadQueue();\n		 *     queue.loadFile("largeImage.png");\n		 *     queue.on("progress", function() {\n		 *         console.log("Progress:", queue.progress, event.progress);\n		 *     });\n		 *\n		 * @property progress\n		 * @type {Number}\n		 * @default 0\n		 */\n		this.progress = 0;\n\n		/**\n		 * The type of item this loader will load. See {{#crossLink "AbstractLoader"}}{{/crossLink}} for a full list of\n		 * supported types.\n		 * @property type\n		 * @type {String}\n		 */\n		this.type = type;\n\n		/**\n		 * A formatter function that converts the loaded raw result into the final result. For example, the JSONLoader\n		 * converts a string of text into a JavaScript object. Not all loaders have a resultFormatter, and this property\n		 * can be overridden to provide custom formatting.\n		 *\n		 * Optionally, a resultFormatter can return a callback function in cases where the formatting needs to be\n		 * asynchronous, such as creating a new image.\n		 * @property resultFormatter\n		 * @type {Function}\n		 * @default null\n		 */\n		this.resultFormatter = null;\n\n		// protected properties\n		/**\n		 * The {{#crossLink "LoadItem"}}{{/crossLink}} this loader represents. Note that this is null in a {{#crossLink "LoadQueue"}}{{/crossLink}},\n		 * but will be available on loaders such as {{#crossLink "XMLLoader"}}{{/crossLink}} and {{#crossLink "ImageLoader"}}{{/crossLink}}.\n		 * @property _item\n		 * @type {LoadItem|Object}\n		 * @private\n		 */\n		if (loadItem) {\n			this._item = createjs.LoadItem.create(loadItem);\n		} else {\n			this._item = null;\n		}\n\n		/**\n		 * Whether the loader will try and load content using XHR (true) or HTML tags (false).\n		 * @property _preferXHR\n		 * @type {Boolean}\n		 * @private\n		 */\n		this._preferXHR = preferXHR;\n\n		/**\n		 * The loaded result after it is formatted by an optional {{#crossLink "resultFormatter"}}{{/crossLink}}. For\n		 * items that are not formatted, this will be the same as the {{#crossLink "_rawResult:property"}}{{/crossLink}}.\n		 * The result is accessed using the {{#crossLink "getResult"}}{{/crossLink}} method.\n		 * @property _result\n		 * @type {Object|String}\n		 * @private\n		 */\n		this._result = null;\n\n		/**\n		 * The loaded result before it is formatted. The rawResult is accessed using the {{#crossLink "getResult"}}{{/crossLink}}\n		 * method, and passing `true`.\n		 * @property _rawResult\n		 * @type {Object|String}\n		 * @private\n		 */\n		this._rawResult = null;\n\n		/**\n		 * A list of items that loaders load behind the scenes. This does not include the main item the loader is\n		 * responsible for loading. Examples of loaders that have sub-items include the {{#crossLink "SpriteSheetLoader"}}{{/crossLink}} and\n		 * {{#crossLink "ManifestLoader"}}{{/crossLink}}.\n		 * @property _loadItems\n		 * @type {null}\n		 * @protected\n		 */\n		this._loadedItems = null;\n\n		/**\n		 * The attribute the items loaded using tags use for the source.\n		 * @type {string}\n		 * @default null\n		 * @private\n		 */\n		this._tagSrcAttribute = null;\n\n		/**\n		 * An HTML tag (or similar) that a loader may use to load HTML content, such as images, scripts, etc.\n		 * @property _tag\n		 * @type {Object}\n		 * @private\n		 */\n		this._tag = null;\n	};\n\n	var p = createjs.extend(AbstractLoader, createjs.EventDispatcher);\n	var s = AbstractLoader;\n\n	/**\n	 * Defines a POST request, use for a method value when loading data.\n	 * @property POST\n	 * @type {string}\n	 * @default post\n	 */\n	s.POST = "POST";\n\n	/**\n	 * Defines a GET request, use for a method value when loading data.\n	 * @property GET\n	 * @type {string}\n	 * @default get\n	 */\n	s.GET = "GET";\n\n	/**\n	 * The preload type for generic binary types. Note that images are loaded as binary files when using XHR.\n	 * @property BINARY\n	 * @type {String}\n	 * @default binary\n	 * @static\n	 * @since 0.6.0\n	 */\n	s.BINARY = "binary";\n\n	/**\n	 * The preload type for css files. CSS files are loaded using a &lt;link&gt; when loaded with XHR, or a\n	 * &lt;style&gt; tag when loaded with tags.\n	 * @property CSS\n	 * @type {String}\n	 * @default css\n	 * @static\n	 * @since 0.6.0\n	 */\n	s.CSS = "css";\n\n	/**\n	 * The preload type for image files, usually png, gif, or jpg/jpeg. Images are loaded into an &lt;image&gt; tag.\n	 * @property IMAGE\n	 * @type {String}\n	 * @default image\n	 * @static\n	 * @since 0.6.0\n	 */\n	s.IMAGE = "image";\n\n	/**\n	 * The preload type for javascript files, usually with the "js" file extension. JavaScript files are loaded into a\n	 * &lt;script&gt; tag.\n	 *\n	 * Since version 0.4.1+, due to how tag-loaded scripts work, all JavaScript files are automatically injected into\n	 * the body of the document to maintain parity between XHR and tag-loaded scripts. In version 0.4.0 and earlier,\n	 * only tag-loaded scripts are injected.\n	 * @property JAVASCRIPT\n	 * @type {String}\n	 * @default javascript\n	 * @static\n	 * @since 0.6.0\n	 */\n	s.JAVASCRIPT = "javascript";\n\n	/**\n	 * The preload type for json files, usually with the "json" file extension. JSON data is loaded and parsed into a\n	 * JavaScript object. Note that if a `callback` is present on the load item, the file will be loaded with JSONP,\n	 * no matter what the {{#crossLink "LoadQueue/preferXHR:property"}}{{/crossLink}} property is set to, and the JSON\n	 * must contain a matching wrapper function.\n	 * @property JSON\n	 * @type {String}\n	 * @default json\n	 * @static\n	 * @since 0.6.0\n	 */\n	s.JSON = "json";\n\n	/**\n	 * The preload type for jsonp files, usually with the "json" file extension. JSON data is loaded and parsed into a\n	 * JavaScript object. You are required to pass a callback parameter that matches the function wrapper in the JSON.\n	 * Note that JSONP will always be used if there is a callback present, no matter what the {{#crossLink "LoadQueue/preferXHR:property"}}{{/crossLink}}\n	 * property is set to.\n	 * @property JSONP\n	 * @type {String}\n	 * @default jsonp\n	 * @static\n	 * @since 0.6.0\n	 */\n	s.JSONP = "jsonp";\n\n	/**\n	 * The preload type for json-based manifest files, usually with the "json" file extension. The JSON data is loaded\n	 * and parsed into a JavaScript object. PreloadJS will then look for a "manifest" property in the JSON, which is an\n	 * Array of files to load, following the same format as the {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}\n	 * method. If a "callback" is specified on the manifest object, then it will be loaded using JSONP instead,\n	 * regardless of what the {{#crossLink "LoadQueue/preferXHR:property"}}{{/crossLink}} property is set to.\n	 * @property MANIFEST\n	 * @type {String}\n	 * @default manifest\n	 * @static\n	 * @since 0.6.0\n	 */\n	s.MANIFEST = "manifest";\n\n	/**\n	 * The preload type for sound files, usually mp3, ogg, or wav. When loading via tags, audio is loaded into an\n	 * &lt;audio&gt; tag.\n	 * @property SOUND\n	 * @type {String}\n	 * @default sound\n	 * @static\n	 * @since 0.6.0\n	 */\n	s.SOUND = "sound";\n\n	/**\n	 * The preload type for video files, usually mp4, ts, or ogg. When loading via tags, video is loaded into an\n	 * &lt;video&gt; tag.\n	 * @property VIDEO\n	 * @type {String}\n	 * @default video\n	 * @static\n	 * @since 0.6.0\n	 */\n	s.VIDEO = "video";\n\n	/**\n	 * The preload type for SpriteSheet files. SpriteSheet files are JSON files that contain string image paths.\n	 * @property SPRITESHEET\n	 * @type {String}\n	 * @default spritesheet\n	 * @static\n	 * @since 0.6.0\n	 */\n	s.SPRITESHEET = "spritesheet";\n\n	/**\n	 * The preload type for SVG files.\n	 * @property SVG\n	 * @type {String}\n	 * @default svg\n	 * @static\n	 * @since 0.6.0\n	 */\n	s.SVG = "svg";\n\n	/**\n	 * The preload type for text files, which is also the default file type if the type can not be determined. Text is\n	 * loaded as raw text.\n	 * @property TEXT\n	 * @type {String}\n	 * @default text\n	 * @static\n	 * @since 0.6.0\n	 */\n	s.TEXT = "text";\n\n	/**\n	 * The preload type for xml files. XML is loaded into an XML document.\n	 * @property XML\n	 * @type {String}\n	 * @default xml\n	 * @static\n	 * @since 0.6.0\n	 */\n	s.XML = "xml";\n\n// Events\n	/**\n	 * The {{#crossLink "ProgressEvent"}}{{/crossLink}} that is fired when the overall progress changes. Prior to\n	 * version 0.6.0, this was just a regular {{#crossLink "Event"}}{{/crossLink}}.\n	 * @event progress\n	 * @since 0.3.0\n	 */\n\n	/**\n	 * The {{#crossLink "Event"}}{{/crossLink}} that is fired when a load starts.\n	 * @event loadstart\n	 * @param {Object} target The object that dispatched the event.\n	 * @param {String} type The event type.\n	 * @since 0.3.1\n	 */\n\n	/**\n	 * The {{#crossLink "Event"}}{{/crossLink}} that is fired when the entire queue has been loaded.\n	 * @event complete\n	 * @param {Object} target The object that dispatched the event.\n	 * @param {String} type The event type.\n	 * @since 0.3.0\n	 */\n\n	/**\n	 * The {{#crossLink "ErrorEvent"}}{{/crossLink}} that is fired when the loader encounters an error. If the error was\n	 * encountered by a file, the event will contain the item that caused the error. Prior to version 0.6.0, this was\n	 * just a regular {{#crossLink "Event"}}{{/crossLink}}.\n	 * @event error\n	 * @since 0.3.0\n	 */\n\n	/**\n	 * The {{#crossLink "Event"}}{{/crossLink}} that is fired when the loader encounters an internal file load error.\n	 * This enables loaders to maintain internal queues, and surface file load errors.\n	 * @event fileerror\n	 * @param {Object} target The object that dispatched the event.\n	 * @param {String} type The even type ("fileerror")\n	 * @param {LoadItem|object} The item that encountered the error\n	 * @since 0.6.0\n	 */\n\n	/**\n	 * The {{#crossLink "Event"}}{{/crossLink}} that is fired when a loader internally loads a file. This enables\n	 * loaders such as {{#crossLink "ManifestLoader"}}{{/crossLink}} to maintain internal {{#crossLink "LoadQueue"}}{{/crossLink}}s\n	 * and notify when they have loaded a file. The {{#crossLink "LoadQueue"}}{{/crossLink}} class dispatches a\n	 * slightly different {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}} event.\n	 * @event fileload\n	 * @param {Object} target The object that dispatched the event.\n	 * @param {String} type The event type ("fileload")\n	 * @param {Object} item The file item which was specified in the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}\n	 * or {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}} call. If only a string path or tag was specified, the\n	 * object will contain that value as a `src` property.\n	 * @param {Object} result The HTML tag or parsed result of the loaded item.\n	 * @param {Object} rawResult The unprocessed result, usually the raw text or binary data before it is converted\n	 * to a usable object.\n	 * @since 0.6.0\n	 */\n\n	/**\n	 * The {{#crossLink "Event"}}{{/crossLink}} that is fired after the internal request is created, but before a load.\n	 * This allows updates to the loader for specific loading needs, such as binary or XHR image loading.\n	 * @event initialize\n	 * @param {Object} target The object that dispatched the event.\n	 * @param {String} type The event type ("initialize")\n	 * @param {AbstractLoader} loader The loader that has been initialized.\n	 */\n\n\n	/**\n	 * Get a reference to the manifest item that is loaded by this loader. In some cases this will be the value that was\n	 * passed into {{#crossLink "LoadQueue"}}{{/crossLink}} using {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} or\n	 * {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}. However if only a String path was passed in, then it will\n	 * be a {{#crossLink "LoadItem"}}{{/crossLink}}.\n	 * @method getItem\n	 * @return {Object} The manifest item that this loader is responsible for loading.\n	 * @since 0.6.0\n	 */\n	p.getItem = function () {\n		return this._item;\n	};\n\n	/**\n	 * Get a reference to the content that was loaded by the loader (only available after the {{#crossLink "complete:event"}}{{/crossLink}}\n	 * event is dispatched.\n	 * @method getResult\n	 * @param {Boolean} [raw=false] Determines if the returned result will be the formatted content, or the raw loaded\n	 * data (if it exists).\n	 * @return {Object}\n	 * @since 0.6.0\n	 */\n	p.getResult = function (raw) {\n		return raw ? this._rawResult : this._result;\n	};\n\n	/**\n	 * Return the `tag` this object creates or uses for loading.\n	 * @method getTag\n	 * @return {Object} The tag instance\n	 * @since 0.6.0\n	 */\n	p.getTag = function () {\n		return this._tag;\n	};\n\n	/**\n	 * Set the `tag` this item uses for loading.\n	 * @method setTag\n	 * @param {Object} tag The tag instance\n	 * @since 0.6.0\n	 */\n	p.setTag = function(tag) {\n	  this._tag = tag;\n	};\n\n	/**\n	 * Begin loading the item. This method is required when using a loader by itself.\n	 *\n	 * <h4>Example</h4>\n	 *\n	 *      var queue = new createjs.LoadQueue();\n	 *      queue.on("complete", handleComplete);\n	 *      queue.loadManifest(fileArray, false); // Note the 2nd argument that tells the queue not to start loading yet\n	 *      queue.load();\n	 *\n	 * @method load\n	 */\n	p.load = function () {\n		this._createRequest();\n\n		this._request.on("complete", this, this);\n		this._request.on("progress", this, this);\n		this._request.on("loadStart", this, this);\n		this._request.on("abort", this, this);\n		this._request.on("timeout", this, this);\n		this._request.on("error", this, this);\n\n		var evt = new createjs.Event("initialize");\n		evt.loader = this._request;\n		this.dispatchEvent(evt);\n\n		this._request.load();\n	};\n\n	/**\n	 * Close the the item. This will stop any open requests (although downloads using HTML tags may still continue in\n	 * the background), but events will not longer be dispatched.\n	 * @method cancel\n	 */\n	p.cancel = function () {\n		this.canceled = true;\n		this.destroy();\n	};\n\n	/**\n	 * Clean up the loader.\n	 * @method destroy\n	 */\n	p.destroy = function() {\n		if (this._request) {\n			this._request.removeAllEventListeners();\n			this._request.destroy();\n		}\n\n		this._request = null;\n\n		this._item = null;\n		this._rawResult = null;\n		this._result = null;\n\n		this._loadItems = null;\n\n		this.removeAllEventListeners();\n	};\n\n	/**\n	 * Get any items loaded internally by the loader. The enables loaders such as {{#crossLink "ManifestLoader"}}{{/crossLink}}\n	 * to expose items it loads internally.\n	 * @method getLoadedItems\n	 * @return {Array} A list of the items loaded by the loader.\n	 * @since 0.6.0\n	 */\n	p.getLoadedItems = function () {\n		return this._loadedItems;\n	};\n\n\n	// Private methods\n	/**\n	 * Create an internal request used for loading. By default, an {{#crossLink "XHRRequest"}}{{/crossLink}} or\n	 * {{#crossLink "TagRequest"}}{{/crossLink}} is created, depending on the value of {{#crossLink "preferXHR:property"}}{{/crossLink}}.\n	 * Other loaders may override this to use different request types, such as {{#crossLink "ManifestLoader"}}{{/crossLink}},\n	 * which uses {{#crossLink "JSONLoader"}}{{/crossLink}} or {{#crossLink "JSONPLoader"}}{{/crossLink}} under the hood.\n	 * @method _createRequest\n	 * @protected\n	 */\n	p._createRequest = function() {\n		if (!this._preferXHR) {\n			this._request = new createjs.TagRequest(this._item, this._tag || this._createTag(), this._tagSrcAttribute);\n		} else {\n			this._request = new createjs.XHRRequest(this._item);\n		}\n	};\n\n	/**\n	 * Create the HTML tag used for loading. This method does nothing by default, and needs to be implemented\n	 * by loaders that require tag loading.\n	 * @method _createTag\n	 * @param {String} src The tag source\n	 * @return {HTMLElement} The tag that was created\n	 * @protected\n	 */\n	p._createTag = function(src) { return null; };\n\n	/**\n	 * Dispatch a loadstart {{#crossLink "Event"}}{{/crossLink}}. Please see the {{#crossLink "AbstractLoader/loadstart:event"}}{{/crossLink}}\n	 * event for details on the event payload.\n	 * @method _sendLoadStart\n	 * @protected\n	 */\n	p._sendLoadStart = function () {\n		if (this._isCanceled()) { return; }\n		this.dispatchEvent("loadstart");\n	};\n\n	/**\n	 * Dispatch a {{#crossLink "ProgressEvent"}}{{/crossLink}}.\n	 * @method _sendProgress\n	 * @param {Number | Object} value The progress of the loaded item, or an object containing <code>loaded</code>\n	 * and <code>total</code> properties.\n	 * @protected\n	 */\n	p._sendProgress = function (value) {\n		if (this._isCanceled()) { return; }\n		var event = null;\n		if (typeof(value) == "number") {\n			this.progress = value;\n			event = new createjs.ProgressEvent(this.progress);\n		} else {\n			event = value;\n			this.progress = value.loaded / value.total;\n			event.progress = this.progress;\n			if (isNaN(this.progress) || this.progress == Infinity) { this.progress = 0; }\n		}\n		this.hasEventListener("progress") && this.dispatchEvent(event);\n	};\n\n	/**\n	 * Dispatch a complete {{#crossLink "Event"}}{{/crossLink}}. Please see the {{#crossLink "AbstractLoader/complete:event"}}{{/crossLink}} event\n	 * @method _sendComplete\n	 * @protected\n	 */\n	p._sendComplete = function () {\n		if (this._isCanceled()) { return; }\n\n		this.loaded = true;\n\n		var event = new createjs.Event("complete");\n		event.rawResult = this._rawResult;\n\n		if (this._result != null) {\n			event.result = this._result;\n		}\n\n		this.dispatchEvent(event);\n	};\n\n	/**\n	 * Dispatch an error {{#crossLink "Event"}}{{/crossLink}}. Please see the {{#crossLink "AbstractLoader/error:event"}}{{/crossLink}}\n	 * event for details on the event payload.\n	 * @method _sendError\n	 * @param {ErrorEvent} event The event object containing specific error properties.\n	 * @protected\n	 */\n	p._sendError = function (event) {\n		if (this._isCanceled() || !this.hasEventListener("error")) { return; }\n		if (event == null) {\n			event = new createjs.ErrorEvent("PRELOAD_ERROR_EMPTY"); // TODO: Populate error\n		}\n		this.dispatchEvent(event);\n	};\n\n	/**\n	 * Determine if the load has been canceled. This is important to ensure that method calls or asynchronous events\n	 * do not cause issues after the queue has been cleaned up.\n	 * @method _isCanceled\n	 * @return {Boolean} If the loader has been canceled.\n	 * @protected\n	 */\n	p._isCanceled = function () {\n		if (window.createjs == null || this.canceled) {\n			return true;\n		}\n		return false;\n	};\n\n	/**\n	 * A custom result formatter function, which is called just before a request dispatches its complete event. Most\n	 * loader types already have an internal formatter, but this can be user-overridden for custom formatting. The\n	 * formatted result will be available on Loaders using {{#crossLink "getResult"}}{{/crossLink}}, and passing `true`.\n	 * @property resultFormatter\n	 * @type Function\n	 * @return {Object} The formatted result\n	 * @since 0.6.0\n	 */\n	p.resultFormatter = null; //TODO: Add support for async formatting.\n\n	/**\n	 * Handle events from internal requests. By default, loaders will handle, and redispatch the necessary events, but\n	 * this method can be overridden for custom behaviours.\n	 * @method handleEvent\n	 * @param {Event} The event that the internal request dispatches.\n	 * @protected\n	 * @since 0.6.0\n	 */\n	p.handleEvent = function (event) {\n		switch (event.type) {\n			case "complete":\n				this._rawResult = event.target._response;\n				var result = this.resultFormatter && this.resultFormatter(this);\n				var _this = this;\n				if (result instanceof Function) {\n					result(function(result) {\n						_this._result = result;\n						_this._sendComplete();\n					});\n				} else {\n					this._result =  result || this._rawResult;\n					this._sendComplete();\n				}\n				break;\n			case "progress":\n				this._sendProgress(event);\n				break;\n			case "error":\n				this._sendError(event);\n				break;\n			case "loadstart":\n				this._sendLoadStart();\n				break;\n			case "abort":\n			case "timeout":\n				if (!this._isCanceled()) {\n					this.dispatchEvent(event.type);\n				}\n				break;\n		}\n	};\n\n	/**\n	 * @method buildPath\n	 * @protected\n	 * @deprecated Use the {{#crossLink "RequestUtils"}}{{/crossLink}} method {{#crossLink "RequestUtils/buildPath"}}{{/crossLink}}\n	 * instead.\n	 */\n	p.buildPath = function (src, data) {\n		return createjs.RequestUtils.buildPath(src, data);\n	};\n\n	/**\n	 * @method toString\n	 * @return {String} a string representation of the instance.\n	 */\n	p.toString = function () {\n		return "[PreloadJS AbstractLoader]";\n	};\n\n	createjs.AbstractLoader = createjs.promote(AbstractLoader, "EventDispatcher");\n\n}());\n\n//##############################################################################\n// AbstractMediaLoader.js\n//##############################################################################\n\nthis.createjs = this.createjs || {};\n\n(function () {\n	"use strict";\n\n	// constructor\n	/**\n	 * The AbstractMediaLoader is a base class that handles some of the shared methods and properties of loaders that\n	 * handle HTML media elements, such as Video and Audio.\n	 * @class AbstractMediaLoader\n	 * @param {LoadItem|Object} loadItem\n	 * @param {Boolean} preferXHR\n	 * @param {String} type The type of media to load. Usually "video" or "audio".\n	 * @constructor\n	 */\n	function AbstractMediaLoader(loadItem, preferXHR, type) {\n		this.AbstractLoader_constructor(loadItem, preferXHR, type);\n\n		// public properties\n		this.resultFormatter = this._formatResult;\n\n		// protected properties\n		this._tagSrcAttribute = "src";\n	};\n\n	var p = createjs.extend(AbstractMediaLoader, createjs.AbstractLoader);\n\n	// static properties\n	// public methods\n	p.load = function () {\n		// TagRequest will handle most of this, but Sound / Video need a few custom properties, so just handle them here.\n		if (!this._tag) {\n			this._tag = this._createTag(this._item.src);\n		}\n\n		this._tag.preload = "auto";\n		this._tag.load();\n\n		this.AbstractLoader_load();\n	};\n\n	// protected methods\n	/**\n	 * Creates a new tag for loading if it doesn\'t exist yet.\n	 * @method _createTag\n	 * @private\n	 */\n	p._createTag = function () {};\n\n\n	p._createRequest = function() {\n		if (!this._preferXHR) {\n			this._request = new createjs.MediaTagRequest(this._item, this._tag || this._createTag(), this._tagSrcAttribute);\n		} else {\n			this._request = new createjs.XHRRequest(this._item);\n		}\n	};\n\n	/**\n	 * The result formatter for media files.\n	 * @method _formatResult\n	 * @param {AbstractLoader} loader\n	 * @returns {HTMLVideoElement|HTMLAudioElement}\n	 * @private\n	 */\n	p._formatResult = function (loader) {\n		this._tag.removeEventListener && this._tag.removeEventListener("canplaythrough", this._loadedHandler);\n		this._tag.onstalled = null;\n		if (this._preferXHR) {\n			loader.getTag().src = loader.getResult(true);\n		}\n		return loader.getTag();\n	};\n\n	createjs.AbstractMediaLoader = createjs.promote(AbstractMediaLoader, "AbstractLoader");\n\n}());\n\n//##############################################################################\n// AbstractRequest.js\n//##############################################################################\n\nthis.createjs = this.createjs || {};\n\n(function () {\n	"use strict";\n\n	/**\n	 * A base class for actual data requests, such as {{#crossLink "XHRRequest"}}{{/crossLink}}, {{#crossLink "TagRequest"}}{{/crossLink}},\n	 * and {{#crossLink "MediaRequest"}}{{/crossLink}}. PreloadJS loaders will typically use a data loader under the\n	 * hood to get data.\n	 * @class AbstractRequest\n	 * @param {LoadItem} item\n	 * @constructor\n	 */\n	var AbstractRequest = function (item) {\n		this._item = item;\n	};\n\n	var p = createjs.extend(AbstractRequest, createjs.EventDispatcher);\n\n	// public methods\n	/**\n	 * Begin a load.\n	 * @method load\n	 */\n	p.load =  function() {};\n\n	/**\n	 * Clean up a request.\n	 * @method destroy\n	 */\n	p.destroy = function() {};\n\n	/**\n	 * Cancel an in-progress request.\n	 * @method cancel\n	 */\n	p.cancel = function() {};\n\n	createjs.AbstractRequest = createjs.promote(AbstractRequest, "EventDispatcher");\n\n}());\n\n//##############################################################################\n// TagRequest.js\n//##############################################################################\n\nthis.createjs = this.createjs || {};\n\n(function () {\n	"use strict";\n\n	// constructor\n	/**\n	 * An {{#crossLink "AbstractRequest"}}{{/crossLink}} that loads HTML tags, such as images and scripts.\n	 * @class TagRequest\n	 * @param {LoadItem} loadItem\n	 * @param {HTMLElement} tag\n	 * @param {String} srcAttribute The tag attribute that specifies the source, such as "src", "href", etc.\n	 */\n	function TagRequest(loadItem, tag, srcAttribute) {\n		this.AbstractRequest_constructor(loadItem);\n\n		// protected properties\n		/**\n		 * The HTML tag instance that is used to load.\n		 * @property _tag\n		 * @type {HTMLElement}\n		 * @protected\n		 */\n		this._tag = tag;\n\n		/**\n		 * The tag attribute that specifies the source, such as "src", "href", etc.\n		 * @property _tagSrcAttribute\n		 * @type {String}\n		 * @protected\n		 */\n		this._tagSrcAttribute = srcAttribute;\n\n		/**\n		 * A method closure used for handling the tag load event.\n		 * @property _loadedHandler\n		 * @type {Function}\n		 * @private\n		 */\n		this._loadedHandler = createjs.proxy(this._handleTagComplete, this);\n\n		/**\n		 * Determines if the element was added to the DOM automatically by PreloadJS, so it can be cleaned up after.\n		 * @property _addedToDOM\n		 * @type {Boolean}\n		 * @private\n		 */\n		this._addedToDOM = false;\n\n		/**\n		 * Determines what the tags initial style.visibility was, so we can set it correctly after a load.\n		 *\n		 * @type {null}\n		 * @private\n		 */\n		this._startTagVisibility = null;\n	};\n\n	var p = createjs.extend(TagRequest, createjs.AbstractRequest);\n\n	// public methods\n	p.load = function () {\n		if (this._tag.parentNode == null) {\n			window.document.body.appendChild(this._tag);\n			this._addedToDOM = true;\n		}\n\n		this._tag.onload = createjs.proxy(this._handleTagComplete, this);\n		this._tag.onreadystatechange = createjs.proxy(this._handleReadyStateChange, this);\n\n		var evt = new createjs.Event("initialize");\n		evt.loader = this._tag;\n\n		this.dispatchEvent(evt);\n\n		this._hideTag();\n\n		this._tag[this._tagSrcAttribute] = this._item.src;\n	};\n\n	p.destroy = function() {\n		this._clean();\n		this._tag = null;\n\n		this.AbstractRequest_destroy();\n	};\n\n	// private methods\n	/**\n	 * Handle the readyStateChange event from a tag. We need this in place of the `onload` callback (mainly SCRIPT\n	 * and LINK tags), but other cases may exist.\n	 * @method _handleReadyStateChange\n	 * @private\n	 */\n	p._handleReadyStateChange = function () {\n		clearTimeout(this._loadTimeout);\n		// This is strictly for tags in browsers that do not support onload.\n		var tag = this._tag;\n\n		// Complete is for old IE support.\n		if (tag.readyState == "loaded" || tag.readyState == "complete") {\n			this._handleTagComplete();\n		}\n	};\n\n	/**\n	 * Handle the tag\'s onload callback.\n	 * @method _handleTagComplete\n	 * @private\n	 */\n	p._handleTagComplete = function () {\n		this._rawResult = this._tag;\n		this._result = this.resultFormatter && this.resultFormatter(this) || this._rawResult;\n\n		this._clean();\n		this._showTag();\n\n		this.dispatchEvent("complete");\n	};\n\n	/**\n	 * Remove event listeners, but don\'t destroy the request object\n	 * @method _clean\n	 * @private\n	 */\n	p._clean = function() {\n		this._tag.onload = null;\n		this._tag.onreadystatechange = null;\n		if (this._addedToDOM && this._tag.parentNode != null) {\n			this._tag.parentNode.removeChild(this._tag);\n		}\n	};\n\n	p._hideTag = function() {\n		this._startTagVisibility = this._tag.style.visibility;\n		this._tag.style.visibility = "hidden";\n	};\n\n	p._showTag = function() {\n		this._tag.style.visibility = this._startTagVisibility;\n	};\n\n	/**\n	 * Handle a stalled audio event. The main place this happens is with HTMLAudio in Chrome when playing back audio\n	 * that is already in a load, but not complete.\n	 * @method _handleStalled\n	 * @private\n	 */\n	p._handleStalled = function () {\n		//Ignore, let the timeout take care of it. Sometimes its not really stopped.\n	};\n\n	createjs.TagRequest = createjs.promote(TagRequest, "AbstractRequest");\n\n}());\n\n//##############################################################################\n// MediaTagRequest.js\n//##############################################################################\n\nthis.createjs = this.createjs || {};\n\n(function () {\n	"use strict";\n\n	// constructor\n	/**\n	 * An {{#crossLink "TagRequest"}}{{/crossLink}} that loads HTML tags for video and audio.\n	 * @class MediaTagRequest\n	 * @param {LoadItem} loadItem\n	 * @param {HTMLAudioElement|HTMLVideoElement} tag\n	 * @param {String} srcAttribute The tag attribute that specifies the source, such as "src", "href", etc.\n	 * @constructor\n	 */\n	function MediaTagRequest(loadItem, tag, srcAttribute) {\n		this.AbstractRequest_constructor(loadItem);\n\n		// protected properties\n		this._tag = tag;\n		this._tagSrcAttribute = srcAttribute;\n		this._loadedHandler = createjs.proxy(this._handleTagComplete, this);\n	};\n\n	var p = createjs.extend(MediaTagRequest, createjs.TagRequest);\n	var s = MediaTagRequest;\n\n	// public methods\n	p.load = function () {\n		this._tag.onstalled = createjs.proxy(this._handleStalled, this);\n		this._tag.onprogress = createjs.proxy(this._handleProgress, this);\n\n		// This will tell us when audio is buffered enough to play through, but not when its loaded.\n		// The tag doesn\'t keep loading in Chrome once enough has buffered, and we have decided that behaviour is sufficient.\n		this._tag.addEventListener && this._tag.addEventListener("canplaythrough", this._loadedHandler, false); // canplaythrough callback doesn\'t work in Chrome, so we use an event.\n\n		this.TagRequest_load();\n	};\n\n	// private methods\n	p._handleReadyStateChange = function () {\n		clearTimeout(this._loadTimeout);\n		// This is strictly for tags in browsers that do not support onload.\n		var tag = this._tag;\n\n		// Complete is for old IE support.\n		if (tag.readyState == "loaded" || tag.readyState == "complete") {\n			this._handleTagComplete();\n		}\n	};\n\n	p._handleStalled = function () {\n		//Ignore, let the timeout take care of it. Sometimes its not really stopped.\n	};\n\n	/**\n	 * An XHR request has reported progress.\n	 * @method _handleProgress\n	 * @param {Object} event The XHR progress event.\n	 * @private\n	 */\n	p._handleProgress = function (event) {\n		if (!event || event.loaded > 0 && event.total == 0) {\n			return; // Sometimes we get no "total", so just ignore the progress event.\n		}\n\n		var newEvent = new createjs.ProgressEvent(event.loaded, event.total);\n		this.dispatchEvent(newEvent);\n	};\n\n	// protected methods\n	p._clean = function () {\n		this._tag.removeEventListener && this._tag.removeEventListener("canplaythrough", this._loadedHandler);\n		this._tag.onstalled = null;\n		this._tag.onprogress = null;\n\n		this.TagRequest__clean();\n	};\n\n	createjs.MediaTagRequest = createjs.promote(MediaTagRequest, "TagRequest");\n\n}());\n\n//##############################################################################\n// XHRRequest.js\n//##############################################################################\n\nthis.createjs = this.createjs || {};\n\n(function () {\n	"use strict";\n\n// constructor\n	/**\n	 * A preloader that loads items using XHR requests, usually XMLHttpRequest. However XDomainRequests will be used\n	 * for cross-domain requests if possible, and older versions of IE fall back on to ActiveX objects when necessary.\n	 * XHR requests load the content as text or binary data, provide progress and consistent completion events, and\n	 * can be canceled during load. Note that XHR is not supported in IE 6 or earlier, and is not recommended for\n	 * cross-domain loading.\n	 * @class XHRRequest\n	 * @constructor\n	 * @param {Object} item The object that defines the file to load. Please see the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}\n	 * for an overview of supported file properties.\n	 * @extends AbstractLoader\n	 */\n	function XHRRequest(item) {\n		this.AbstractRequest_constructor(item);\n\n		// protected properties\n		/**\n		 * A reference to the XHR request used to load the content.\n		 * @property _request\n		 * @type {XMLHttpRequest | XDomainRequest | ActiveX.XMLHTTP}\n		 * @private\n		 */\n		this._request = null;\n\n		/**\n		 * A manual load timeout that is used for browsers that do not support the onTimeout event on XHR (XHR level 1,\n		 * typically IE9).\n		 * @property _loadTimeout\n		 * @type {Number}\n		 * @private\n		 */\n		this._loadTimeout = null;\n\n		/**\n		 * The browser\'s XHR (XMLHTTPRequest) version. Supported versions are 1 and 2. There is no official way to detect\n		 * the version, so we use capabilities to make a best guess.\n		 * @property _xhrLevel\n		 * @type {Number}\n		 * @default 1\n		 * @private\n		 */\n		this._xhrLevel = 1;\n\n		/**\n		 * The response of a loaded file. This is set because it is expensive to look up constantly. This property will be\n		 * null until the file is loaded.\n		 * @property _response\n		 * @type {mixed}\n		 * @private\n		 */\n		this._response = null;\n\n		/**\n		 * The response of the loaded file before it is modified. In most cases, content is converted from raw text to\n		 * an HTML tag or a formatted object which is set to the <code>result</code> property, but the developer may still\n		 * want to access the raw content as it was loaded.\n		 * @property _rawResponse\n		 * @type {String|Object}\n		 * @private\n		 */\n		this._rawResponse = null;\n\n		this._canceled = false;\n\n		// Setup our event handlers now.\n		this._handleLoadStartProxy = createjs.proxy(this._handleLoadStart, this);\n		this._handleProgressProxy = createjs.proxy(this._handleProgress, this);\n		this._handleAbortProxy = createjs.proxy(this._handleAbort, this);\n		this._handleErrorProxy = createjs.proxy(this._handleError, this);\n		this._handleTimeoutProxy = createjs.proxy(this._handleTimeout, this);\n		this._handleLoadProxy = createjs.proxy(this._handleLoad, this);\n		this._handleReadyStateChangeProxy = createjs.proxy(this._handleReadyStateChange, this);\n\n		if (!this._createXHR(item)) {\n			//TODO: Throw error?\n		}\n	};\n\n	var p = createjs.extend(XHRRequest, createjs.AbstractRequest);\n\n// static properties\n	/**\n	 * A list of XMLHTTP object IDs to try when building an ActiveX object for XHR requests in earlier versions of IE.\n	 * @property ACTIVEX_VERSIONS\n	 * @type {Array}\n	 * @since 0.4.2\n	 * @private\n	 */\n	XHRRequest.ACTIVEX_VERSIONS = [\n		"Msxml2.XMLHTTP.6.0",\n		"Msxml2.XMLHTTP.5.0",\n		"Msxml2.XMLHTTP.4.0",\n		"MSXML2.XMLHTTP.3.0",\n		"MSXML2.XMLHTTP",\n		"Microsoft.XMLHTTP"\n	];\n\n// Public methods\n	/**\n	 * Look up the loaded result.\n	 * @method getResult\n	 * @param {Boolean} [raw=false] Return a raw result instead of a formatted result. This applies to content\n	 * loaded via XHR such as scripts, XML, CSS, and Images. If there is no raw result, the formatted result will be\n	 * returned instead.\n	 * @return {Object} A result object containing the content that was loaded, such as:\n	 * <ul>\n	 *      <li>An image tag (&lt;image /&gt;) for images</li>\n	 *      <li>A script tag for JavaScript (&lt;script /&gt;). Note that scripts loaded with tags may be added to the\n	 *      HTML head.</li>\n	 *      <li>A style tag for CSS (&lt;style /&gt;)</li>\n	 *      <li>Raw text for TEXT</li>\n	 *      <li>A formatted JavaScript object defined by JSON</li>\n	 *      <li>An XML document</li>\n	 *      <li>An binary arraybuffer loaded by XHR</li>\n	 * </ul>\n	 * Note that if a raw result is requested, but not found, the result will be returned instead.\n	 */\n	p.getResult = function (raw) {\n		if (raw && this._rawResponse) {\n			return this._rawResponse;\n		}\n		return this._response;\n	};\n\n	// Overrides abstract method in AbstractRequest\n	p.cancel = function () {\n		this.canceled = true;\n		this._clean();\n		this._request.abort();\n	};\n\n	// Overrides abstract method in AbstractLoader\n	p.load = function () {\n		if (this._request == null) {\n			this._handleError();\n			return;\n		}\n\n		//Events\n		this._request.addEventListener("loadstart", this._handleLoadStartProxy, false);\n		this._request.addEventListener("progress", this._handleProgressProxy, false);\n		this._request.addEventListener("abort", this._handleAbortProxy, false);\n		this._request.addEventListener("error",this._handleErrorProxy, false);\n		this._request.addEventListener("timeout", this._handleTimeoutProxy, false);\n\n		// Note: We don\'t get onload in all browsers (earlier FF and IE). onReadyStateChange handles these.\n		this._request.addEventListener("load", this._handleLoadProxy, false);\n		this._request.addEventListener("readystatechange", this._handleReadyStateChangeProxy, false);\n\n		// Set up a timeout if we don\'t have XHR2\n		if (this._xhrLevel == 1) {\n			this._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);\n		}\n\n		// Sometimes we get back 404s immediately, particularly when there is a cross origin request.  // note this does not catch in Chrome\n		try {\n			if (!this._item.values || this._item.method == createjs.AbstractLoader.GET) {\n				this._request.send();\n			} else if (this._item.method == createjs.AbstractLoader.POST) {\n				this._request.send(createjs.RequestUtils.formatQueryString(this._item.values));\n			}\n		} catch (error) {\n			this.dispatchEvent(new createjs.ErrorEvent("XHR_SEND", null, error));\n		}\n	};\n\n	p.setResponseType = function (type) {\n		this._request.responseType = type;\n	};\n\n	/**\n	 * Get all the response headers from the XmlHttpRequest.\n	 *\n	 * <strong>From the docs:</strong> Return all the HTTP headers, excluding headers that are a case-insensitive match\n	 * for Set-Cookie or Set-Cookie2, as a single string, with each header line separated by a U+000D CR U+000A LF pair,\n	 * excluding the status line, and with each header name and header value separated by a U+003A COLON U+0020 SPACE\n	 * pair.\n	 * @method getAllResponseHeaders\n	 * @return {String}\n	 * @since 0.4.1\n	 */\n	p.getAllResponseHeaders = function () {\n		if (this._request.getAllResponseHeaders instanceof Function) {\n			return this._request.getAllResponseHeaders();\n		} else {\n			return null;\n		}\n	};\n\n	/**\n	 * Get a specific response header from the XmlHttpRequest.\n	 *\n	 * <strong>From the docs:</strong> Returns the header field value from the response of which the field name matches\n	 * header, unless the field name is Set-Cookie or Set-Cookie2.\n	 * @method getResponseHeader\n	 * @param {String} header The header name to retrieve.\n	 * @return {String}\n	 * @since 0.4.1\n	 */\n	p.getResponseHeader = function (header) {\n		if (this._request.getResponseHeader instanceof Function) {\n			return this._request.getResponseHeader(header);\n		} else {\n			return null;\n		}\n	};\n\n// protected methods\n	/**\n	 * The XHR request has reported progress.\n	 * @method _handleProgress\n	 * @param {Object} event The XHR progress event.\n	 * @private\n	 */\n	p._handleProgress = function (event) {\n		if (!event || event.loaded > 0 && event.total == 0) {\n			return; // Sometimes we get no "total", so just ignore the progress event.\n		}\n\n		var newEvent = new createjs.ProgressEvent(event.loaded, event.total);\n		this.dispatchEvent(newEvent);\n	};\n\n	/**\n	 * The XHR request has reported a load start.\n	 * @method _handleLoadStart\n	 * @param {Object} event The XHR loadStart event.\n	 * @private\n	 */\n	p._handleLoadStart = function (event) {\n		clearTimeout(this._loadTimeout);\n		this.dispatchEvent("loadstart");\n	};\n\n	/**\n	 * The XHR request has reported an abort event.\n	 * @method handleAbort\n	 * @param {Object} event The XHR abort event.\n	 * @private\n	 */\n	p._handleAbort = function (event) {\n		this._clean();\n		this.dispatchEvent(new createjs.ErrorEvent("XHR_ABORTED", null, event));\n	};\n\n	/**\n	 * The XHR request has reported an error event.\n	 * @method _handleError\n	 * @param {Object} event The XHR error event.\n	 * @private\n	 */\n	p._handleError = function (event) {\n		this._clean();\n		this.dispatchEvent(new createjs.ErrorEvent(event.message));\n	};\n\n	/**\n	 * The XHR request has reported a readyState change. Note that older browsers (IE 7 & 8) do not provide an onload\n	 * event, so we must monitor the readyStateChange to determine if the file is loaded.\n	 * @method _handleReadyStateChange\n	 * @param {Object} event The XHR readyStateChange event.\n	 * @private\n	 */\n	p._handleReadyStateChange = function (event) {\n		if (this._request.readyState == 4) {\n			this._handleLoad();\n		}\n	};\n\n	/**\n	 * The XHR request has completed. This is called by the XHR request directly, or by a readyStateChange that has\n	 * <code>request.readyState == 4</code>. Only the first call to this method will be processed.\n	 * @method _handleLoad\n	 * @param {Object} event The XHR load event.\n	 * @private\n	 */\n	p._handleLoad = function (event) {\n		if (this.loaded) {\n			return;\n		}\n		this.loaded = true;\n\n		var error = this._checkError();\n		if (error) {\n			this._handleError(error);\n			return;\n		}\n\n		this._response = this._getResponse();\n		this._clean();\n\n		this.dispatchEvent(new createjs.Event("complete"));\n	};\n\n	/**\n	 * The XHR request has timed out. This is called by the XHR request directly, or via a <code>setTimeout</code>\n	 * callback.\n	 * @method _handleTimeout\n	 * @param {Object} [event] The XHR timeout event. This is occasionally null when called by the backup setTimeout.\n	 * @private\n	 */\n	p._handleTimeout = function (event) {\n		this._clean();\n\n		this.dispatchEvent(new createjs.ErrorEvent("PRELOAD_TIMEOUT", null, event));\n	};\n\n// Protected\n	/**\n	 * Determine if there is an error in the current load. This checks the status of the request for problem codes. Note\n	 * that this does not check for an actual response. Currently, it only checks for 404 or 0 error code.\n	 * @method _checkError\n	 * @return {int} If the request status returns an error code.\n	 * @private\n	 */\n	p._checkError = function () {\n		//LM: Probably need additional handlers here, maybe 501\n		var status = parseInt(this._request.status);\n\n		switch (status) {\n			case 404:   // Not Found\n			case 0:     // Not Loaded\n				return new Error(status);\n		}\n		return null;\n	};\n\n	/**\n	 * Validate the response. Different browsers have different approaches, some of which throw errors when accessed\n	 * in other browsers. If there is no response, the <code>_response</code> property will remain null.\n	 * @method _getResponse\n	 * @private\n	 */\n	p._getResponse = function () {\n		if (this._response != null) {\n			return this._response;\n		}\n\n		if (this._request.response != null) {\n			return this._request.response;\n		}\n\n		// Android 2.2 uses .responseText\n		try {\n			if (this._request.responseText != null) {\n				return this._request.responseText;\n			}\n		} catch (e) {\n		}\n\n		// When loading XML, IE9 does not return .response, instead it returns responseXML.xml\n		try {\n			if (this._request.responseXML != null) {\n				return this._request.responseXML;\n			}\n		} catch (e) {\n		}\n\n		return null;\n	};\n\n	/**\n	 * Create an XHR request. Depending on a number of factors, we get totally different results.\n	 * <ol><li>Some browsers get an <code>XDomainRequest</code> when loading cross-domain.</li>\n	 *      <li>XMLHttpRequest are created when available.</li>\n	 *      <li>ActiveX.XMLHTTP objects are used in older IE browsers.</li>\n	 *      <li>Text requests override the mime type if possible</li>\n	 *      <li>Origin headers are sent for crossdomain requests in some browsers.</li>\n	 *      <li>Binary loads set the response type to "arraybuffer"</li></ol>\n	 * @method _createXHR\n	 * @param {Object} item The requested item that is being loaded.\n	 * @return {Boolean} If an XHR request or equivalent was successfully created.\n	 * @private\n	 */\n	p._createXHR = function (item) {\n		// Check for cross-domain loads. We can\'t fully support them, but we can try.\n		var crossdomain = createjs.RequestUtils.isCrossDomain(item);\n		var headers = {};\n\n		// Create the request. Fallback to whatever support we have.\n		var req = null;\n		if (window.XMLHttpRequest) {\n			req = new XMLHttpRequest();\n			// This is 8 or 9, so use XDomainRequest instead.\n			if (crossdomain && req.withCredentials === undefined && window.XDomainRequest) {\n				req = new XDomainRequest();\n			}\n		} else { // Old IE versions use a different approach\n			for (var i = 0, l = s.ACTIVEX_VERSIONS.length; i < l; i++) {\n				var axVersion = s.ACTIVEX_VERSIONS[i];\n				try {\n					req = new ActiveXObject(axVersions);\n					break;\n				} catch (e) {}\n			}\n			if (req == null) { return false; }\n		}\n\n		// IE9 doesn\'t support overrideMimeType(), so we need to check for it.\n		if (item.mimeType && req.overrideMimeType) {\n			req.overrideMimeType(item.mimeType);\n		}\n\n		// Determine the XHR level\n		this._xhrLevel = (typeof req.responseType === "string") ? 2 : 1;\n\n		var src = null;\n		if (item.method == createjs.AbstractLoader.GET) {\n			src = createjs.RequestUtils.buildPath(item.src, item.values);\n		} else {\n			src = item.src;\n		}\n\n		// Open the request.  Set cross-domain flags if it is supported (XHR level 1 only)\n		req.open(item.method || createjs.AbstractLoader.GET, src, true);\n\n		if (crossdomain && req instanceof XMLHttpRequest && this._xhrLevel == 1) {\n			headers["Origin"] = location.origin;\n		}\n\n		// To send data we need to set the Content-type header)\n		if (item.values && item.method == createjs.AbstractLoader.POST) {\n			headers["Content-Type"] = "application/x-www-form-urlencoded";\n		}\n\n		if (!crossdomain && !headers["X-Requested-With"]) {\n			headers["X-Requested-With"] = "XMLHttpRequest";\n		}\n\n		if (item.headers) {\n			for (var n in item.headers) {\n				headers[n] = item.headers[n];\n			}\n		}\n\n		for (n in headers) {\n			req.setRequestHeader(n, headers[n])\n		}\n\n		if (req instanceof XMLHttpRequest && item.withCredentials !== undefined) {\n			req.withCredentials = item.withCredentials;\n		}\n\n		this._request = req;\n\n		return true;\n	};\n\n	/**\n	 * A request has completed (or failed or canceled), and needs to be disposed.\n	 * @method _clean\n	 * @private\n	 */\n	p._clean = function () {\n		clearTimeout(this._loadTimeout);\n\n		this._request.removeEventListener("loadstart", this._handleLoadStartProxy);\n		this._request.removeEventListener("progress", this._handleProgressProxy);\n		this._request.removeEventListener("abort", this._handleAbortProxy);\n		this._request.removeEventListener("error",this._handleErrorProxy);\n		this._request.removeEventListener("timeout", this._handleTimeoutProxy);\n		this._request.removeEventListener("load", this._handleLoadProxy);\n		this._request.removeEventListener("readystatechange", this._handleReadyStateChangeProxy);\n	};\n\n	p.toString = function () {\n		return "[PreloadJS XHRRequest]";\n	};\n\n	createjs.XHRRequest = createjs.promote(XHRRequest, "AbstractRequest");\n\n}());\n\n//##############################################################################\n// SoundLoader.js\n//##############################################################################\n\nthis.createjs = this.createjs || {};\n\n(function () {\n	"use strict";\n\n	// constructor\n	/**\n	 * A loader for HTML audio files. PreloadJS can not load WebAudio files, as a WebAudio context is required, which\n	 * should be created by either a library playing the sound (such as <a href="http://soundjs.com">SoundJS</a>, or an\n	 * external framework that handles audio playback. To load content that can be played by WebAudio, use the\n	 * {{#crossLink "BinaryLoader"}}{{/crossLink}}, and handle the audio context decoding manually.\n	 * @class SoundLoader\n	 * @param {LoadItem|Object} loadItem\n	 * @param {Boolean} preferXHR\n	 * @constructor\n	 */\n	function SoundLoader(loadItem, preferXHR) {\n		this.AbstractMediaLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.SOUND);\n\n		// protected properties\n		if (createjs.RequestUtils.isAudioTag(loadItem)) {\n			this._tag = loadItem;\n		} else if (createjs.RequestUtils.isAudioTag(loadItem.src)) {\n			this._tag = loadItem;\n		} else if (createjs.RequestUtils.isAudioTag(loadItem.tag)) {\n			this._tag = createjs.RequestUtils.isAudioTag(loadItem) ? loadItem : loadItem.src;\n		}\n\n		if (this._tag != null) {\n			this._preferXHR = false;\n		}\n	};\n\n	var p = createjs.extend(SoundLoader, createjs.AbstractMediaLoader);\n	var s = SoundLoader;\n\n	// static methods\n	/**\n	 * Determines if the loader can load a specific item. This loader can only load items that are of type\n	 * {{#crossLink "AbstractLoader/SOUND:property"}}{{/crossLink}}.\n	 * @method canLoadItem\n	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n	 * @returns {Boolean} Whether the loader can load the item.\n	 * @static\n	 */\n	s.canLoadItem = function (item) {\n		return item.type == createjs.AbstractLoader.SOUND;\n	};\n\n	// protected methods\n	p._createTag = function (src) {\n		var tag = document.createElement("audio");\n		tag.autoplay = false;\n		tag.preload = "none";\n\n		//LM: Firefox fails when this the preload="none" for other tags, but it needs to be "none" to ensure PreloadJS works.\n		tag.src = src;\n		return tag;\n	};\n\n	createjs.SoundLoader = createjs.promote(SoundLoader, "AbstractMediaLoader");\n\n}());\n\n//##############################################################################\n// Sound.js\n//##############################################################################\n\nthis.createjs = this.createjs || {};\n\n\n\n(function () {\n	"use strict";\n\n	/**\n	 * The Sound class is the public API for creating sounds, controlling the overall sound levels, and managing plugins.\n	 * All Sound APIs on this class are static.\n	 *\n	 * <b>Registering and Preloading</b><br />\n	 * Before you can play a sound, it <b>must</b> be registered. You can do this with {{#crossLink "Sound/registerSound"}}{{/crossLink}},\n	 * or register multiple sounds using {{#crossLink "Sound/registerSounds"}}{{/crossLink}}. If you don\'t register a\n	 * sound prior to attempting to play it using {{#crossLink "Sound/play"}}{{/crossLink}} or create it using {{#crossLink "Sound/createInstance"}}{{/crossLink}},\n	 * the sound source will be automatically registered but playback will fail as the source will not be ready. If you use\n	 * <a href="http://preloadjs.com" target="_blank">PreloadJS</a>, registration is handled for you when the sound is\n	 * preloaded. It is recommended to preload sounds either internally using the register functions or externally using\n	 * PreloadJS so they are ready when you want to use them.\n	 *\n	 * <b>Playback</b><br />\n	 * To play a sound once it\'s been registered and preloaded, use the {{#crossLink "Sound/play"}}{{/crossLink}} method.\n	 * This method returns a {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} which can be paused, resumed, muted, etc.\n	 * Please see the {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} documentation for more on the instance control APIs.\n	 *\n	 * <b>Plugins</b><br />\n	 * By default, the {{#crossLink "WebAudioPlugin"}}{{/crossLink}} or the {{#crossLink "HTMLAudioPlugin"}}{{/crossLink}}\n	 * are used (when available), although developers can change plugin priority or add new plugins (such as the\n	 * provided {{#crossLink "FlashAudioPlugin"}}{{/crossLink}}). Please see the {{#crossLink "Sound"}}{{/crossLink}} API\n	 * methods for more on the playback and plugin APIs. To install plugins, or specify a different plugin order, see\n	 * {{#crossLink "Sound/installPlugins"}}{{/crossLink}}.\n	 *\n	 * <h4>Example</h4>\n	 *\n	 *      createjs.Sound.registerPlugins([createjs.WebAudioPlugin, createjs.FlashAudioPlugin]);\n	 *      createjs.Sound.alternateExtensions = ["mp3"];\n	 *      createjs.Sound.on("fileload", createjs.proxy(this.loadHandler, (this));\n	 *      createjs.Sound.registerSound("path/to/mySound.ogg", "sound");\n	 *      function loadHandler(event) {\n     *          // This is fired for each sound that is registered.\n     *          var instance = createjs.Sound.play("sound");  // play using id.  Could also use full source path or event.src.\n     *          instance.on("complete", createjs.proxy(this.handleComplete, this));\n     *          instance.volume = 0.5;\n	 *      }\n	 *\n	 * The maximum number of concurrently playing instances of the same sound can be specified in the "data" argument\n	 * of {{#crossLink "Sound/registerSound"}}{{/crossLink}}.  Note that if not specified, the active plugin will apply\n	 * a default limit.  Currently HTMLAudioPlugin sets a default limit of 2, while WebAudioPlugin and FlashAudioPlugin set a\n	 * default limit of 100.\n	 *\n	 *      createjs.Sound.registerSound("sound.mp3", "soundId", 4);\n	 *\n	 * Sound can be used as a plugin with PreloadJS to help preload audio properly. Audio preloaded with PreloadJS is\n	 * automatically registered with the Sound class. When audio is not preloaded, Sound will do an automatic internal\n	 * load. As a result, it may fail to play the first time play is called if the audio is not finished loading. Use the\n	 * {{#crossLink "Sound/fileload"}}{{/crossLink}} event to determine when a sound has finished internally preloading.\n	 * It is recommended that all audio is preloaded before it is played.\n	 *\n	 *      var queue = new createjs.LoadQueue();\n	 *		queue.installPlugin(createjs.Sound);\n	 *\n	 * <b>Audio Sprites</b><br />\n	 * SoundJS has added support for Audio Sprites, available as of version 0.6.0.\n	 * For those unfamiliar with audio sprites, they are much like CSS sprites or sprite sheets: multiple audio assets\n	 * grouped into a single file.\n	 *\n	 * Benefits of Audio Sprites\n	 * <ul><li>More robust support for older browsers and devices that only allow a single audio instance, such as iOS 5.</li>\n	 * <li>They provide a work around for the Internet Explorer 9 audio tag limit, which until now restricted how many\n	 * different sounds we could load at once.</li>\n	 * <li>Faster loading by only requiring a single network request for several sounds, especially on mobile devices\n	 * where the network round trip for each file can add significant latency.</li></ul>\n	 *\n	 * Drawbacks of Audio Sprites\n	 * <ul><li>No guarantee of smooth looping when using HTML or Flash audio.  If you have a track that needs to loop\n	 * smoothly and you are supporting non-web audio browsers, do not use audio sprites for that sound if you can avoid it.</li>\n	 * <li>No guarantee that HTML audio will play back immediately, especially the first time. In some browsers (Chrome!),\n	 * HTML audio will only load enough to play through â€“ so we rely on the â€œcanplaythroughâ€ event to determine if the audio is loaded.\n	 * Since audio sprites must jump ahead to play specific sounds, the audio may not yet have downloaded.</li>\n	 * <li>Audio sprites share the same core source, so if you have a sprite with 5 sounds and are limited to 2\n	 * concurrently playing instances, that means you can only play 2 of the sounds at the same time.</li></ul>\n	 *\n	 * <h4>Example</h4>\n	 *\n	 *      createjs.Sound.initializeDefaultPlugins();\n	 *		var assetsPath = "./assets/";\n	 *		var sounds = [{\n	 *			src:"MyAudioSprite.ogg", data: {\n	 *				audioSprite: [\n	 *					{id:"sound1", startTime:0, duration:500},\n	 *					{id:"sound2", startTime:1000, duration:400},\n	 *					{id:"sound3", startTime:1700, duration: 1000}\n	 *				]}\n *				}\n	 *		];\n	 *		createjs.Sound.alternateExtensions = ["mp3"];\n	 *		createjs.Sound.on("fileload", loadSound);\n	 *		createjs.Sound.registerSounds(sounds, assetsPath);\n	 *		// after load is complete\n	 *		createjs.Sound.play("sound2");\n	 *\n	 * You can also create audio sprites on the fly by setting the startTime and duration when creating an new AbstractSoundInstance.\n	 *\n	 * 		createjs.Sound.play("MyAudioSprite", {startTime: 1000, duration: 400});\n	 *\n	 * <b>Mobile Safe Approach</b><br />\n	 * Mobile devices require sounds to be played inside of a user initiated event (touch/click) in varying degrees.\n	 * As of SoundJS 0.4.1, you can launch a site inside of a user initiated event and have audio playback work. To\n	 * enable as broadly as possible, the site needs to setup the Sound plugin in its initialization (for example via\n	 * <code>createjs.Sound.initializeDefaultPlugins();</code>), and all sounds need to be played in the scope of the\n	 * application.  See the MobileSafe demo for a working example.\n	 *\n	 * <h4>Example</h4>\n	 *\n	 *     document.getElementById("status").addEventListener("click", handleTouch, false);    // works on Android and iPad\n	 *     function handleTouch(event) {\n	 *         document.getElementById("status").removeEventListener("click", handleTouch, false);    // remove the listener\n	 *         var thisApp = new myNameSpace.MyApp();    // launch the app\n	 *     }\n	 *\n	 * <h4>Known Browser and OS issues</h4>\n	 * <b>IE 9 HTML Audio limitations</b><br />\n	 * <ul><li>There is a delay in applying volume changes to tags that occurs once playback is started. So if you have\n	 * muted all sounds, they will all play during this delay until the mute applies internally. This happens regardless of\n	 * when or how you apply the volume change, as the tag seems to need to play to apply it.</li>\n     * <li>MP3 encoding will not always work for audio tags, particularly in Internet Explorer. We\'ve found default\n	 * encoding with 64kbps works.</li>\n	 * <li>Occasionally very short samples will get cut off.</li>\n	 * <li>There is a limit to how many audio tags you can load and play at once, which appears to be determined by\n	 * hardware and browser settings.  See {{#crossLink "HTMLAudioPlugin.MAX_INSTANCES"}}{{/crossLink}} for a safe estimate.</li></ul>\n	 *\n	 * <b>Firefox 25 Web Audio limitations</b>\n	 * <ul><li>mp3 audio files do not load properly on all windows machines, reported\n	 * <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=929969" target="_blank">here</a>. </br>\n	 * For this reason it is recommended to pass another FF supported type (ie ogg) first until this bug is resolved, if possible.</li></ul>\n\n	 * <b>Safari limitations</b><br />\n	 * <ul><li>Safari requires Quicktime to be installed for audio playback.</li></ul>\n	 *\n	 * <b>iOS 6 Web Audio limitations</b><br />\n	 * <ul><li>Sound is initially muted and will only unmute through play being called inside a user initiated event\n	 * (touch/click).</li>\n	 * <li>A bug exists that will distort un-cached web audio when a video element is present in the DOM that has audio at a different sampleRate.</li>\n	 * <li>Note HTMLAudioPlugin is not supported on iOS by default.  See {{#crossLink "HTMLAudioPlugin"}}{{/crossLink}}\n	 * for more details.</li>\n	 * </ul>\n	 *\n	 * <b>Android HTML Audio limitations</b><br />\n	 * <ul><li>We have no control over audio volume. Only the user can set volume on their device.</li>\n	 * <li>We can only play audio inside a user event (touch/click).  This currently means you cannot loop sound or use\n	 * a delay.</li></ul>\n	 *\n	 *\n	 * @class Sound\n	 * @static\n	 * @uses EventDispatcher\n	 */\n	function Sound() {\n		throw "Sound cannot be instantiated";\n	}\n\n	var s = Sound;\n\n\n// Static Properties\n	/**\n	 * The interrupt value to interrupt any currently playing instance with the same source, if the maximum number of\n	 * instances of the sound are already playing.\n	 * @property INTERRUPT_ANY\n	 * @type {String}\n	 * @default any\n	 * @static\n	 */\n	s.INTERRUPT_ANY = "any";\n\n	/**\n	 * The interrupt value to interrupt the earliest currently playing instance with the same source that progressed the\n	 * least distance in the audio track, if the maximum number of instances of the sound are already playing.\n	 * @property INTERRUPT_EARLY\n	 * @type {String}\n	 * @default early\n	 * @static\n	 */\n	s.INTERRUPT_EARLY = "early";\n\n	/**\n	 * The interrupt value to interrupt the currently playing instance with the same source that progressed the most\n	 * distance in the audio track, if the maximum number of instances of the sound are already playing.\n	 * @property INTERRUPT_LATE\n	 * @type {String}\n	 * @default late\n	 * @static\n	 */\n	s.INTERRUPT_LATE = "late";\n\n	/**\n	 * The interrupt value to not interrupt any currently playing instances with the same source, if the maximum number of\n	 * instances of the sound are already playing.\n	 * @property INTERRUPT_NONE\n	 * @type {String}\n	 * @default none\n	 * @static\n	 */\n	s.INTERRUPT_NONE = "none";\n\n	/**\n	 * Defines the playState of an instance that is still initializing.\n	 * @property PLAY_INITED\n	 * @type {String}\n	 * @default playInited\n	 * @static\n	 */\n	s.PLAY_INITED = "playInited";\n\n	/**\n	 * Defines the playState of an instance that is currently playing or paused.\n	 * @property PLAY_SUCCEEDED\n	 * @type {String}\n	 * @default playSucceeded\n	 * @static\n	 */\n	s.PLAY_SUCCEEDED = "playSucceeded";\n\n	/**\n	 * Defines the playState of an instance that was interrupted by another instance.\n	 * @property PLAY_INTERRUPTED\n	 * @type {String}\n	 * @default playInterrupted\n	 * @static\n	 */\n	s.PLAY_INTERRUPTED = "playInterrupted";\n\n	/**\n	 * Defines the playState of an instance that completed playback.\n	 * @property PLAY_FINISHED\n	 * @type {String}\n	 * @default playFinished\n	 * @static\n	 */\n	s.PLAY_FINISHED = "playFinished";\n\n	/**\n	 * Defines the playState of an instance that failed to play. This is usually caused by a lack of available channels\n	 * when the interrupt mode was "INTERRUPT_NONE", the playback stalled, or the sound could not be found.\n	 * @property PLAY_FAILED\n	 * @type {String}\n	 * @default playFailed\n	 * @static\n	 */\n	s.PLAY_FAILED = "playFailed";\n\n	/**\n	 * A list of the default supported extensions that Sound will <i>try</i> to play. Plugins will check if the browser\n	 * can play these types, so modifying this list before a plugin is initialized will allow the plugins to try to\n	 * support additional media types.\n	 *\n	 * NOTE this does not currently work for {{#crossLink "FlashAudioPlugin"}}{{/crossLink}}.\n	 *\n	 * More details on file formats can be found at <a href="http://en.wikipedia.org/wiki/Audio_file_format" target="_blank">http://en.wikipedia.org/wiki/Audio_file_format</a>.<br />\n	 * A very detailed list of file formats can be found at <a href="http://www.fileinfo.com/filetypes/audio" target="_blank">http://www.fileinfo.com/filetypes/audio</a>.\n	 * @property SUPPORTED_EXTENSIONS\n	 * @type {Array[String]}\n	 * @default ["mp3", "ogg", "mpeg", "wav", "m4a", "mp4", "aiff", "wma", "mid"]\n	 * @since 0.4.0\n	 */\n	s.SUPPORTED_EXTENSIONS = ["mp3", "ogg", "mpeg", "wav", "m4a", "mp4", "aiff", "wma", "mid"];\n\n	/**\n	 * Some extensions use another type of extension support to play (one of them is a codex).  This allows you to map\n	 * that support so plugins can accurately determine if an extension is supported.  Adding to this list can help\n	 * plugins determine more accurately if an extension is supported.\n	 *\n 	 * A useful list of extensions for each format can be found at <a href="http://html5doctor.com/html5-audio-the-state-of-play/" target="_blank">http://html5doctor.com/html5-audio-the-state-of-play/</a>.\n	 * @property EXTENSION_MAP\n	 * @type {Object}\n	 * @since 0.4.0\n	 * @default {m4a:"mp4"}\n	 */\n	s.EXTENSION_MAP = {\n		m4a:"mp4"\n	};\n\n	/**\n	 * The RegExp pattern used to parse file URIs. This supports simple file names, as well as full domain URIs with\n	 * query strings. The resulting match is: protocol:$1 domain:$2 path:$3 file:$4 extension:$5 query:$6.\n	 * @property FILE_PATTERN\n	 * @type {RegExp}\n	 * @static\n	 * @protected\n	 */\n	s.FILE_PATTERN = /^(?:(\\w+:)\\/{2}(\\w+(?:\\.\\w+)*\\/?))?([/.]*?(?:[^?]+)?\\/)?((?:[^/?]+)\\.(\\w+))(?:\\?(\\S+)?)?$/;\n\n\n// Class Public properties\n	/**\n	 * Determines the default behavior for interrupting other currently playing instances with the same source, if the\n	 * maximum number of instances of the sound are already playing.  Currently the default is {{#crossLink "Sound/INTERRUPT_NONE:property"}}{{/crossLink}}\n	 * but this can be set and will change playback behavior accordingly.  This is only used when {{#crossLink "Sound/play"}}{{/crossLink}}\n	 * is called without passing a value for interrupt.\n	 * @property defaultInterruptBehavior\n	 * @type {String}\n	 * @default Sound.INTERRUPT_NONE, or "none"\n	 * @static\n	 * @since 0.4.0\n	 */\n	s.defaultInterruptBehavior = s.INTERRUPT_NONE;  // OJR does s.INTERRUPT_ANY make more sense as default?  Needs game dev testing to see which case makes more sense.\n\n	/**\n	 * An array of extensions to attempt to use when loading sound, if the default is unsupported by the active plugin.\n	 * These are applied in order, so if you try to Load Thunder.ogg in a browser that does not support ogg, and your\n	 * extensions array is ["mp3", "m4a", "wav"] it will check mp3 support, then m4a, then wav. The audio files need\n	 * to exist in the same location, as only the extension is altered.\n	 *\n	 * Note that regardless of which file is loaded, you can call {{#crossLink "Sound/createInstance"}}{{/crossLink}}\n	 * and {{#crossLink "Sound/play"}}{{/crossLink}} using the same id or full source path passed for loading.\n	 *\n	 * <h4>Example</h4>\n	 *\n	 *	var sounds = [\n	 *		{src:"myPath/mySound.ogg", id:"example"},\n	 *	];\n	 *	createjs.Sound.alternateExtensions = ["mp3"]; // now if ogg is not supported, SoundJS will try asset0.mp3\n	 *	createjs.Sound.on("fileload", handleLoad); // call handleLoad when each sound loads\n	 *	createjs.Sound.registerSounds(sounds, assetPath);\n	 *	// ...\n	 *	createjs.Sound.play("myPath/mySound.ogg"); // works regardless of what extension is supported.  Note calling with ID is a better approach\n	 *\n	 * @property alternateExtensions\n	 * @type {Array}\n	 * @since 0.5.2\n	 */\n	s.alternateExtensions = [];\n\n	/**\n	 * The currently active plugin. If this is null, then no plugin could be initialized. If no plugin was specified,\n	 * Sound attempts to apply the default plugins: {{#crossLink "WebAudioPlugin"}}{{/crossLink}}, followed by\n	 * {{#crossLink "HTMLAudioPlugin"}}{{/crossLink}}.\n	 * @property activePlugin\n	 * @type {Object}\n	 * @static\n	 */\n    s.activePlugin = null;\n\n\n// Class Private properties\n	/**\n	 * Determines if the plugins have been registered. If false, the first call to play() will instantiate the default\n	 * plugins ({{#crossLink "WebAudioPlugin"}}{{/crossLink}}, followed by {{#crossLink "HTMLAudioPlugin"}}{{/crossLink}}).\n	 * If plugins have been registered, but none are applicable, then sound playback will fail.\n	 * @property _pluginsRegistered\n	 * @type {Boolean}\n	 * @default false\n	 * @static\n	 * @protected\n	 */\n	s._pluginsRegistered = false;\n\n	/**\n	 * Used internally to assign unique IDs to each AbstractSoundInstance.\n	 * @property _lastID\n	 * @type {Number}\n	 * @static\n	 * @protected\n	 */\n	s._lastID = 0;\n\n	/**\n	 * The master volume value, which affects all sounds. Use {{#crossLink "Sound/getVolume"}}{{/crossLink}} and\n	 * {{#crossLink "Sound/setVolume"}}{{/crossLink}} to modify the volume of all audio.\n	 * @property _masterVolume\n	 * @type {Number}\n	 * @default 1\n	 * @protected\n	 * @since 0.4.0\n	 */\n	s._masterVolume = 1;\n\n	/**\n	 * The master mute value, which affects all sounds.  This is applies to all sound instances.  This value can be set\n	 * through {{#crossLink "Sound/setMute"}}{{/crossLink}} and accessed via {{#crossLink "Sound/getMute"}}{{/crossLink}}.\n	 * @property _masterMute\n	 * @type {Boolean}\n	 * @default false\n	 * @protected\n	 * @static\n	 * @since 0.4.0\n	 */\n	s._masterMute = false;\n\n	/**\n	 * An array containing all currently playing instances. This allows Sound to control the volume, mute, and playback of\n	 * all instances when using static APIs like {{#crossLink "Sound/stop"}}{{/crossLink}} and {{#crossLink "Sound/setVolume"}}{{/crossLink}}.\n	 * When an instance has finished playback, it gets removed via the {{#crossLink "Sound/finishedPlaying"}}{{/crossLink}}\n	 * method. If the user replays an instance, it gets added back in via the {{#crossLink "Sound/_beginPlaying"}}{{/crossLink}}\n	 * method.\n	 * @property _instances\n	 * @type {Array}\n	 * @protected\n	 * @static\n	 */\n	s._instances = [];\n\n	/**\n	 * An object hash storing objects with sound sources, startTime, and duration via there corresponding ID.\n	 * @property _idHash\n	 * @type {Object}\n	 * @protected\n	 * @static\n	 */\n	s._idHash = {};\n\n	/**\n	 * An object hash that stores preloading sound sources via the parsed source that is passed to the plugin.  Contains the\n	 * source, id, and data that was passed in by the user.  Parsed sources can contain multiple instances of source, id,\n	 * and data.\n	 * @property _preloadHash\n	 * @type {Object}\n	 * @protected\n	 * @static\n	 */\n	s._preloadHash = {};\n\n\n// EventDispatcher methods:\n	s.addEventListener = null;\n	s.removeEventListener = null;\n	s.removeAllEventListeners = null;\n	s.dispatchEvent = null;\n	s.hasEventListener = null;\n	s._listeners = null;\n\n	createjs.EventDispatcher.initialize(s); // inject EventDispatcher methods.\n\n\n// Events\n	/**\n	 * This event is fired when a file finishes loading internally. This event is fired for each loaded sound,\n	 * so any handler methods should look up the <code>event.src</code> to handle a particular sound.\n	 * @event fileload\n	 * @param {Object} target The object that dispatched the event.\n	 * @param {String} type The event type.\n	 * @param {String} src The source of the sound that was loaded.\n	 * @param {String} [id] The id passed in when the sound was registered. If one was not provided, it will be null.\n	 * @param {Number|Object} [data] Any additional data associated with the item. If not provided, it will be undefined.\n	 * @since 0.4.1\n	 */\n\n	/**\n	 * This event is fired when a file fails loading internally. This event is fired for each loaded sound,\n	 * so any handler methods should look up the <code>event.src</code> to handle a particular sound.\n	 * @event fileerror\n	 * @param {Object} target The object that dispatched the event.\n	 * @param {String} type The event type.\n	 * @param {String} src The source of the sound that was loaded.\n	 * @param {String} [id] The id passed in when the sound was registered. If one was not provided, it will be null.\n	 * @param {Number|Object} [data] Any additional data associated with the item. If not provided, it will be undefined.\n	 * @since 0.6.0\n	 */\n\n\n// Class Public Methods\n	/**\n	 * Get the preload rules to allow Sound to be used as a plugin by <a href="http://preloadjs.com" target="_blank">PreloadJS</a>.\n	 * Any load calls that have the matching type or extension will fire the callback method, and use the resulting\n	 * object, which is potentially modified by Sound. This helps when determining the correct path, as well as\n	 * registering the audio instance(s) with Sound. This method should not be called, except by PreloadJS.\n	 * @method getPreloadHandlers\n	 * @return {Object} An object containing:\n	 * <ul><li>callback: A preload callback that is fired when a file is added to PreloadJS, which provides\n	 *      Sound a mechanism to modify the load parameters, select the correct file format, register the sound, etc.</li>\n	 *      <li>types: A list of file types that are supported by Sound (currently supports "sound").</li>\n	 *      <li>extensions: A list of file extensions that are supported by Sound (see {{#crossLink "Sound.SUPPORTED_EXTENSIONS"}}{{/crossLink}}).</li></ul>\n	 * @static\n	 * @protected\n	 */\n	s.getPreloadHandlers = function () {\n		return {\n			callback:createjs.proxy(s.initLoad, s),\n			types:["sound"],\n			extensions:s.SUPPORTED_EXTENSIONS\n		};\n	};\n\n	/**\n	 * Used to dispatch fileload events from internal loading.\n	 * @method _handleLoadComplete\n	 * @param event A loader event.\n	 * @protected\n	 * @static\n	 * @since 0.6.0\n	 */\n	s._handleLoadComplete = function(event) {\n		var src = event.target.getItem().src;\n		if (!s._preloadHash[src]) {return;}\n\n		for (var i = 0, l = s._preloadHash[src].length; i < l; i++) {\n			var item = s._preloadHash[src][i];\n			s._preloadHash[src][i] = true;\n\n			if (!s.hasEventListener("fileload")) { continue; }\n\n			var event = new createjs.Event("fileload");\n			event.src = item.src;\n			event.id = item.id;\n			event.data = item.data;\n			event.sprite = item.sprite;\n\n			s.dispatchEvent(event);\n		}\n	};\n\n	/**\n	 * Used to dispatch error events from internal preloading.\n	 * @param event\n	 * @protected\n	 * @since 0.6.0\n	 */\n	s._handleLoadError = function(event) {\n		var src = event.target.getItem().src;\n		if (!s._preloadHash[src]) {return;}\n\n		for (var i = 0, l = s._preloadHash[src].length; i < l; i++) {\n			var item = s._preloadHash[src][i];\n			s._preloadHash[src][i] = false;\n\n			if (!s.hasEventListener("fileerror")) { continue; }\n\n			var event = new createjs.Event("fileerror");\n			event.src = item.src;\n			event.id = item.id;\n			event.data = item.data;\n			event.sprite = item.sprite;\n\n			s.dispatchEvent(event);\n		}\n	};\n\n	/**\n	 * Used by {{#crossLink "Sound/registerPlugins"}}{{/crossLink}} to register a Sound plugin.\n	 *\n	 * @method _registerPlugin\n	 * @param {Object} plugin The plugin class to install.\n	 * @return {Boolean} Whether the plugin was successfully initialized.\n	 * @static\n	 * @private\n	 */\n	s._registerPlugin = function (plugin) {\n		// Note: Each plugin is passed in as a class reference, but we store the activePlugin as an instance\n		if (plugin.isSupported()) {\n			s.activePlugin = new plugin();\n			return true;\n		}\n		return false;\n	};\n\n	/**\n	 * Register a list of Sound plugins, in order of precedence. To register a single plugin, pass a single element in the array.\n	 *\n	 * <h4>Example</h4>\n	 *\n	 *      createjs.FlashAudioPlugin.swfPath = "../src/soundjs/flashaudio/";\n	 *      createjs.Sound.registerPlugins([createjs.WebAudioPlugin, createjs.HTMLAudioPlugin, createjs.FlashAudioPlugin]);\n	 *\n	 * @method registerPlugins\n	 * @param {Array} plugins An array of plugins classes to install.\n	 * @return {Boolean} Whether a plugin was successfully initialized.\n	 * @static\n	 */\n	s.registerPlugins = function (plugins) {\n		s._pluginsRegistered = true;\n		for (var i = 0, l = plugins.length; i < l; i++) {\n			if (s._registerPlugin(plugins[i])) {\n				return true;\n			}\n		}\n		return false;\n	};\n\n	/**\n	 * Initialize the default plugins. This method is automatically called when any audio is played or registered before\n	 * the user has manually registered plugins, and enables Sound to work without manual plugin setup. Currently, the\n	 * default plugins are {{#crossLink "WebAudioPlugin"}}{{/crossLink}} followed by {{#crossLink "HTMLAudioPlugin"}}{{/crossLink}}.\n	 *\n	 * <h4>Example</h4>\n	 *\n	 * 	if (!createjs.initializeDefaultPlugins()) { return; }\n	 *\n	 * @method initializeDefaultPlugins\n	 * @returns {Boolean} True if a plugin was initialized, false otherwise.\n	 * @since 0.4.0\n	 */\n	s.initializeDefaultPlugins = function () {\n		if (s.activePlugin != null) {return true;}\n		if (s._pluginsRegistered) {return false;}\n		if (s.registerPlugins([createjs.WebAudioPlugin, createjs.HTMLAudioPlugin])) {return true;}\n		return false;\n	};\n\n	/**\n	 * Determines if Sound has been initialized, and a plugin has been activated.\n	 *\n	 * <h4>Example</h4>\n	 * This example sets up a Flash fallback, but only if there is no plugin specified yet.\n	 *\n	 * 	if (!createjs.Sound.isReady()) {\n	 *		createjs.FlashAudioPlugin.swfPath = "../src/soundjs/flashaudio/";\n	 * 		createjs.Sound.registerPlugins([createjs.WebAudioPlugin, createjs.HTMLAudioPlugin, createjs.FlashAudioPlugin]);\n	 *	}\n	 *\n	 * @method isReady\n	 * @return {Boolean} If Sound has initialized a plugin.\n	 * @static\n	 */\n	s.isReady = function () {\n		return (s.activePlugin != null);\n	};\n\n	/**\n	 * Get the active plugins capabilities, which help determine if a plugin can be used in the current environment,\n	 * or if the plugin supports a specific feature. Capabilities include:\n	 * <ul>\n	 *     <li><b>panning:</b> If the plugin can pan audio from left to right</li>\n	 *     <li><b>volume;</b> If the plugin can control audio volume.</li>\n	 *     <li><b>tracks:</b> The maximum number of audio tracks that can be played back at a time. This will be -1\n	 *     if there is no known limit.</li>\n	 * <br />An entry for each file type in {{#crossLink "Sound/SUPPORTED_EXTENSIONS:property"}}{{/crossLink}}:\n	 *     <li><b>mp3:</b> If MP3 audio is supported.</li>\n	 *     <li><b>ogg:</b> If OGG audio is supported.</li>\n	 *     <li><b>wav:</b> If WAV audio is supported.</li>\n	 *     <li><b>mpeg:</b> If MPEG audio is supported.</li>\n	 *     <li><b>m4a:</b> If M4A audio is supported.</li>\n	 *     <li><b>mp4:</b> If MP4 audio is supported.</li>\n	 *     <li><b>aiff:</b> If aiff audio is supported.</li>\n	 *     <li><b>wma:</b> If wma audio is supported.</li>\n	 *     <li><b>mid:</b> If mid audio is supported.</li>\n	 * </ul>\n	 * @method getCapabilities\n	 * @return {Object} An object containing the capabilities of the active plugin.\n	 * @static\n	 */\n	s.getCapabilities = function () {\n		if (s.activePlugin == null) {return null;}\n		return s.activePlugin._capabilities;\n	};\n\n	/**\n	 * Get a specific capability of the active plugin. See {{#crossLink "Sound/getCapabilities"}}{{/crossLink}} for a\n	 * full list of capabilities.\n	 *\n	 * <h4>Example</h4>\n	 *\n	 *      var maxAudioInstances = createjs.Sound.getCapability("tracks");\n	 *\n	 * @method getCapability\n	 * @param {String} key The capability to retrieve\n	 * @return {Number|Boolean} The value of the capability.\n	 * @static\n	 * @see getCapabilities\n	 */\n	s.getCapability = function (key) {\n		if (s.activePlugin == null) {return null;}\n		return s.activePlugin._capabilities[key];\n	};\n\n	/**\n	 * Process manifest items from <a href="http://preloadjs.com" target="_blank">PreloadJS</a>. This method is intended\n	 * for usage by a plugin, and not for direct interaction.\n	 * @method initLoad\n	 * @param {Object} src The object to load.\n	 * @return {Object|AbstractLoader} An instance of AbstractLoader.\n	 * @protected\n	 * @static\n	 */\n	s.initLoad = function (loadItem) {\n		return s._registerSound(loadItem);\n	};\n\n	/**\n	 * Internal method for loading sounds.  This should not be called directly.\n	 *\n	 * @method _registerSound\n	 * @param {Object} src The object to load, containing src property and optionally containing id and data.\n	 * @return {Object} An object with the modified values that were passed in, which defines the sound.\n	 * Returns false if the source cannot be parsed or no plugins can be initialized.\n	 * Returns true if the source is already loaded.\n	 * @static\n	 * @private\n	 * @since 0.6.0\n	 */\n\n	s._registerSound = function (loadItem) {\n		if (!s.initializeDefaultPlugins()) {return false;}\n\n		var details = s._parsePath(loadItem.src);\n		if (details == null) {return false;}\n		loadItem.src = details.src;\n		loadItem.type = "sound";\n\n		var data = loadItem.data;\n		var numChannels = s.activePlugin.defaultNumChannels || null;\n		if (data != null) {\n			if (!isNaN(data.channels)) {\n				numChannels = parseInt(data.channels);\n			} else if (!isNaN(data)) {\n				numChannels = parseInt(data);\n			}\n\n			if(data.audioSprite) {\n				var sp;\n				for(var i = data.audioSprite.length; i--; ) {\n					sp = data.audioSprite[i];\n					s._idHash[sp.id] = {src: loadItem.src, startTime: parseInt(sp.startTime), duration: parseInt(sp.duration)};\n				}\n			}\n		}\n		if (loadItem.id != null) {s._idHash[loadItem.id] = {src: loadItem.src}};\n		var loader = s.activePlugin.register(loadItem, numChannels);  // Note only HTML audio uses numChannels\n\n		SoundChannel.create(loadItem.src, numChannels);\n\n		// return the number of instances to the user.  This will also be returned in the load event.\n		if (data == null || !isNaN(data)) {\n			loadItem.data = numChannels || SoundChannel.maxPerChannel();\n		} else {\n			loadItem.data.channels = numChannels || SoundChannel.maxPerChannel();\n		}\n\n		//if (loader.onload) {details.completeHandler = loader.onload;}	// used by preloadJS\n		if (loader.type) {loadItem.type = loader.type;}\n\n		return loader;\n	};\n\n	/**\n	 * Register an audio file for loading and future playback in Sound. This is automatically called when using\n	 * <a href="http://preloadjs.com" target="_blank">PreloadJS</a>.  It is recommended to register all sounds that\n	 * need to be played back in order to properly prepare and preload them. Sound does internal preloading when required.\n	 *\n	 * <h4>Example</h4>\n	 *\n	 *      createjs.Sound.alternateExtensions = ["mp3"];\n	 *      createjs.Sound.on("fileload", handleLoad); // add an event listener for when load is completed\n	 *      createjs.Sound.registerSound("myAudioPath/mySound.ogg", "myID", 3);\n	 *\n	 * @method registerSound\n	 * @param {String | Object} src The source or an Object with a "src" property\n	 * @param {String} [id] An id specified by the user to play the sound later.\n	 * @param {Number | Object} [data] Data associated with the item. Sound uses the data parameter as the number of\n	 * channels for an audio instance, however a "channels" property can be appended to the data object if it is used\n	 * for other information. The audio channels will set a default based on plugin if no value is found.\n	 * Sound also uses the data property to hold an audioSprite array of objects in the following format {id, startTime, duration}.<br/>\n	 *   id used to play the sound later, in the same manner as a sound src with an id.<br/>\n	 *   startTime is the initial offset to start playback and loop from, in milliseconds.<br/>\n	 *   duration is the amount of time to play the clip for, in milliseconds.<br/>\n	 * This allows Sound to support audio sprites that are played back by id.\n	 * @param {string} basePath Set a path that will be prepended to src for loading.\n	 * @return {Object} An object with the modified values that were passed in, which defines the sound.\n	 * Returns false if the source cannot be parsed or no plugins can be initialized.\n	 * Returns true if the source is already loaded.\n	 * @static\n	 * @since 0.4.0\n	 */\n	s.registerSound = function (src, id, data, basePath) {\n		var loadItem = {src: src, id: id, data:data};\n		if (src instanceof Object) {\n			basePath = id;\n			loadItem = src;\n		}\n		loadItem = createjs.LoadItem.create(loadItem);\n\n		if (basePath != null) {loadItem.src = basePath + src;}\n\n		var loader = s._registerSound(loadItem);\n		if(!loader) {return false;}\n\n		if (!s._preloadHash[loadItem.src]) { s._preloadHash[loadItem.src] = [];}\n		s._preloadHash[loadItem.src].push(loadItem);\n		if (s._preloadHash[loadItem.src].length == 1) {\n			// OJR note this will disallow reloading a sound if loading fails or the source changes\n			loader.on("complete", createjs.proxy(this._handleLoadComplete, this));\n			loader.on("error", createjs.proxy(this._handleLoadError, this));\n			s.activePlugin.preload(loader);\n		} else {\n			if (s._preloadHash[loadItem.src][0] == true) {return true;}\n		}\n\n		return loadItem;\n	};\n\n	/**\n	 * Register an array of audio files for loading and future playback in Sound. It is recommended to register all\n	 * sounds that need to be played back in order to properly prepare and preload them. Sound does internal preloading\n	 * when required.\n	 *\n	 * <h4>Example</h4>\n	 *\n	 *      var sounds = [\n	 *          {src:"asset0.ogg", id:"example"},\n	 *          {src:"asset1.ogg", id:"1", data:6},\n	 *          {src:"asset2.mp3", id:"works"}\n	 *      ];\n	 *      createjs.Sound.alternateExtensions = ["mp3"];	// if the passed extension is not supported, try this extension\n	 *      createjs.Sound.on("fileload", handleLoad); // call handleLoad when each sound loads\n	 *      createjs.Sound.registerSounds(sounds, assetPath);\n	 *\n	 * @method registerSounds\n	 * @param {Array} sounds An array of objects to load. Objects are expected to be in the format needed for\n	 * {{#crossLink "Sound/registerSound"}}{{/crossLink}}: <code>{src:srcURI, id:ID, data:Data}</code>\n	 * with "id" and "data" being optional.  You can also set an optional path property that will be prepended to the src of each object.\n	 * @param {string} basePath Set a path that will be prepended to each src when loading.  When creating, playing, or removing\n	 * audio that was loaded with a basePath by src, the basePath must be included.\n	 * @return {Object} An array of objects with the modified values that were passed in, which defines each sound.\n	 * Like registerSound, it will return false for any values when the source cannot be parsed or if no plugins can be initialized.\n	 * Also, it will return true for any values when the source is already loaded.\n	 * @static\n	 * @since 0.6.0\n	 */\n	s.registerSounds = function (sounds, basePath) {\n		var returnValues = [];\n		if (sounds.path) {\n			if (!basePath) {\n				basePath = sounds.path;\n			} else {\n				basePath = basePath + sounds.path;\n			}\n		}\n		for (var i = 0, l = sounds.length; i < l; i++) {\n			returnValues[i] = createjs.Sound.registerSound(sounds[i].src, sounds[i].id, sounds[i].data, basePath);\n		}\n		return returnValues;\n	};\n\n	/**\n	 * Deprecated.  Please use {{#crossLink "Sound/registerSounds"}}{{/crossLink} instead.\n	 *\n	 * @method registerManifest\n	 * @param {Array} sounds An array of objects to load. Objects are expected to be in the format needed for\n	 * {{#crossLink "Sound/registerSound"}}{{/crossLink}}: <code>{src:srcURI, id:ID, data:Data}</code>\n	 * with "id" and "data" being optional.\n	 * @param {string} basePath Set a path that will be prepended to each src when loading.  When creating, playing, or removing\n	 * audio that was loaded with a basePath by src, the basePath must be included.\n	 * @return {Object} An array of objects with the modified values that were passed in, which defines each sound.\n	 * Like registerSound, it will return false for any values when the source cannot be parsed or if no plugins can be initialized.\n	 * Also, it will return true for any values when the source is already loaded.\n	 * @since 0.4.0\n	 * @depreacted\n 	 */\n	s.registerManifest = function(manifest, basePath) {\n		try {\n			console.log("createjs.Sound.registerManifest is deprecated, please use createjs.Sound.registerSounds.")\n		} catch (error) {\n\n		};\n		return this.registerSounds(manifest, basePath);\n	};\n\n	/**\n	 * Remove a sound that has been registered with {{#crossLink "Sound/registerSound"}}{{/crossLink}} or\n	 * {{#crossLink "Sound/registerSounds"}}{{/crossLink}}.\n	 * <br />Note this will stop playback on active instances playing this sound before deleting them.\n	 * <br />Note if you passed in a basePath, you need to pass it or prepend it to the src here.\n	 *\n	 * <h4>Example</h4>\n	 *\n	 *      createjs.Sound.removeSound("myAudioBasePath/mySound.ogg");\n	 *      createjs.Sound.removeSound("myID");\n	 *\n	 * @method removeSound\n	 * @param {String | Object} src The src or ID of the audio, or an Object with a "src" property\n	 * @param {string} basePath Set a path that will be prepended to each src when removing.\n	 * @return {Boolean} True if sound is successfully removed.\n	 * @static\n	 * @since 0.4.1\n	 */\n	s.removeSound = function(src, basePath) {\n		if (s.activePlugin == null) {return false;}\n\n		if (src instanceof Object) {src = src.src;}\n		src = s._getSrcById(src).src;\n		if (basePath != null) {src = basePath + src;}\n\n		var details = s._parsePath(src);\n		if (details == null) {return false;}\n		src = details.src;\n\n		for(var prop in s._idHash){\n			if(s._idHash[prop].src == src) {\n				delete(s._idHash[prop]);\n			}\n		}\n\n		// clear from SoundChannel, which also stops and deletes all instances\n		SoundChannel.removeSrc(src);\n\n		delete(s._preloadHash[src]);\n\n		s.activePlugin.removeSound(src);\n\n		return true;\n	};\n\n	/**\n	 * Remove an array of audio files that have been registered with {{#crossLink "Sound/registerSound"}}{{/crossLink}} or\n	 * {{#crossLink "Sound/registerSounds"}}{{/crossLink}}.\n	 * <br />Note this will stop playback on active instances playing this audio before deleting them.\n	 * <br />Note if you passed in a basePath, you need to pass it or prepend it to the src here.\n	 *\n	 * <h4>Example</h4>\n	 *\n	 *      var sounds = [\n	 *          {src:"asset0.ogg", id:"example"},\n	 *          {src:"asset1.ogg", id:"1", data:6},\n	 *          {src:"asset2.mp3", id:"works"}\n	 *      ];\n	 *      createjs.Sound.removeSounds(sounds, assetPath);\n	 *\n	 * @method removeSounds\n	 * @param {Array} sounds An array of objects to remove. Objects are expected to be in the format needed for\n	 * {{#crossLink "Sound/removeSound"}}{{/crossLink}}: <code>{srcOrID:srcURIorID}</code>.\n	 * You can also set an optional path property that will be prepended to the src of each object.\n	 * @param {string} basePath Set a path that will be prepended to each src when removing.\n	 * @return {Object} An array of Boolean values representing if the sounds with the same array index were\n	 * successfully removed.\n	 * @static\n	 * @since 0.4.1\n	 */\n	s.removeSounds = function (sounds, basePath) {\n		var returnValues = [];\n		if (sounds.path) {\n			if (!basePath) {\n				basePath = sounds.path;\n			} else {\n				basePath = basePath + sounds.path;\n			}\n		}\n		for (var i = 0, l = sounds.length; i < l; i++) {\n			returnValues[i] = createjs.Sound.removeSound(sounds[i].src, basePath);\n		}\n		return returnValues;\n	};\n\n	/**\n	 * Deprecated.  Please use {{#crossLink "Sound/removeSounds"}}{{/crossLink}} instead.\n	 *\n	 * @method removeManifest\n	 * @param {Array} manifest An array of objects to remove. Objects are expected to be in the format needed for\n	 * {{#crossLink "Sound/removeSound"}}{{/crossLink}}: <code>{srcOrID:srcURIorID}</code>\n	 * @param {string} basePath Set a path that will be prepended to each src when removing.\n	 * @return {Object} An array of Boolean values representing if the sounds with the same array index in manifest was\n	 * successfully removed.\n	 * @static\n	 * @since 0.4.1\n	 * @deprecated\n	 */\n	s.removeManifest = function (manifest, basePath) {\n		try {\n			console.log("createjs.Sound.removeManifest is deprecated, please use createjs.Sound.removeSounds.");\n		} catch (error) {\n\n		};\n		return s.removeSounds(manifest, basePath);\n	};\n\n	/**\n	 * Remove all sounds that have been registered with {{#crossLink "Sound/registerSound"}}{{/crossLink}} or\n	 * {{#crossLink "Sound/registerSounds"}}{{/crossLink}}.\n	 * <br />Note this will stop playback on all active sound instances before deleting them.\n	 *\n	 * <h4>Example</h4>\n	 *\n	 *     createjs.Sound.removeAllSounds();\n	 *\n	 * @method removeAllSounds\n	 * @static\n	 * @since 0.4.1\n	 */\n	s.removeAllSounds = function() {\n		s._idHash = {};\n		s._preloadHash = {};\n		SoundChannel.removeAll();\n		if (s.activePlugin) {s.activePlugin.removeAllSounds();}\n	};\n\n	/**\n	 * Check if a source has been loaded by internal preloaders. This is necessary to ensure that sounds that are\n	 * not completed preloading will not kick off a new internal preload if they are played.\n	 *\n	 * <h4>Example</h4>\n	 *\n	 *     var mySound = "assetPath/asset0.ogg";\n	 *     if(createjs.Sound.loadComplete(mySound) {\n	 *         createjs.Sound.play(mySound);\n	 *     }\n	 *\n	 * @method loadComplete\n	 * @param {String} src The src or id that is being loaded.\n	 * @return {Boolean} If the src is already loaded.\n	 * @since 0.4.0\n	 */\n	s.loadComplete = function (src) {\n		if (!s.isReady()) { return false; }\n		var details = s._parsePath(src);\n		if (details) {\n			src = s._getSrcById(details.src).src;\n		} else {\n			src = s._getSrcById(src).src;\n		}\n		return (s._preloadHash[src][0] == true);  // src only loads once, so if it\'s true for the first it\'s true for all\n	};\n\n	/**\n	 * Parse the path of a sound. alternate extensions will be attempted in order if the\n	 * current extension is not supported\n	 * @method _parsePath\n	 * @param {String} value The path to an audio source.\n	 * @return {Object} A formatted object that can be registered with the {{#crossLink "Sound/activePlugin:property"}}{{/crossLink}}\n	 * and returned to a preloader like <a href="http://preloadjs.com" target="_blank">PreloadJS</a>.\n	 * @protected\n	 */\n	s._parsePath = function (value) {\n		if (typeof(value) != "string") {value = value.toString();}\n\n		var match = value.match(s.FILE_PATTERN);\n		if (match == null) {return false;}\n\n		var name = match[4];\n		var ext = match[5];\n		var c = s.getCapabilities();\n		var i = 0;\n		while (!c[ext]) {\n			ext = s.alternateExtensions[i++];\n			if (i > s.alternateExtensions.length) { return null;}	// no extensions are supported\n		}\n		value = value.replace("."+match[5], "."+ext);\n\n		var ret = {name:name, src:value, extension:ext};\n		return ret;\n	};\n\n	/* ---------------\n	 Static API.\n	 --------------- */\n	/**\n	 * Play a sound and get a {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} to control. If the sound fails to play, a\n	 * AbstractSoundInstance will still be returned, and have a playState of {{#crossLink "Sound/PLAY_FAILED:property"}}{{/crossLink}}.\n	 * Note that even on sounds with failed playback, you may still be able to call AbstractSoundInstance {{#crossLink "AbstractSoundInstance/play"}}{{/crossLink}},\n	 * since the failure could be due to lack of available channels. If the src does not have a supported extension or\n	 * if there is no available plugin, a default AbstractSoundInstance will be returned which will not play any audio, but will not generate errors.\n	 *\n	 * <h4>Example</h4>\n	 *\n	 *      createjs.Sound.on("fileload", handleLoad);\n	 *      createjs.Sound.registerSound("myAudioPath/mySound.mp3", "myID", 3);\n	 *      function handleLoad(event) {\n	 *      	createjs.Sound.play("myID");\n	 *      	// we can pass in options we want to set inside of an object, and store off AbstractSoundInstance for controlling\n	 *      	var myInstance = createjs.Sound.play("myID", {interrupt: createjs.Sound.INTERRUPT_ANY, loop:-1});\n	 *      	// alternately, we can pass full source path and specify each argument individually\n	 *      	var myInstance = createjs.Sound.play("myAudioPath/mySound.mp3", createjs.Sound.INTERRUPT_ANY, 0, 0, -1, 1, 0);\n	 *      }\n	 *\n	 * NOTE to create an audio sprite that has not already been registered, both startTime and duration need to be set.\n	 * This is only when creating a new audio sprite, not when playing using the id of an already registered audio sprite.\n	 *\n	 * @method play\n	 * @param {String} src The src or ID of the audio.\n	 * @param {String | Object} [interrupt="none"|options] How to interrupt any currently playing instances of audio with the same source,\n	 * if the maximum number of instances of the sound are already playing. Values are defined as <code>INTERRUPT_TYPE</code>\n	 * constants on the Sound class, with the default defined by {{#crossLink "Sound/defaultInterruptBehavior:property"}}{{/crossLink}}.\n	 * <br /><strong>OR</strong><br />\n	 * This parameter can be an object that contains any or all optional properties by name, including: interrupt,\n	 * delay, offset, loop, volume, pan, startTime, and duration (see the above code sample).\n	 * @param {Number} [delay=0] The amount of time to delay the start of audio playback, in milliseconds.\n	 * @param {Number} [offset=0] The offset from the start of the audio to begin playback, in milliseconds.\n	 * @param {Number} [loop=0] How many times the audio loops when it reaches the end of playback. The default is 0 (no\n	 * loops), and -1 can be used for infinite playback.\n	 * @param {Number} [volume=1] The volume of the sound, between 0 and 1. Note that the master volume is applied\n	 * against the individual volume.\n	 * @param {Number} [pan=0] The left-right pan of the sound (if supported), between -1 (left) and 1 (right).\n	 * @param {Number} [startTime=null] To create an audio sprite (with duration), the initial offset to start playback and loop from, in milliseconds.\n	 * @param {Number} [duration=null] To create an audio sprite (with startTime), the amount of time to play the clip for, in milliseconds.\n	 * @return {AbstractSoundInstance} A {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} that can be controlled after it is created.\n	 * @static\n	 */\n	s.play = function (src, interrupt, delay, offset, loop, volume, pan, startTime, duration) {\n		if (interrupt instanceof Object) {\n			delay = interrupt.delay;\n			offset = interrupt.offset;\n			loop = interrupt.loop;\n			volume = interrupt.volume;\n			pan = interrupt.pan;\n			startTime = interrupt.startTime;\n			duration = interrupt.duration;\n			interrupt = interrupt.interrupt;\n\n		}\n		var instance = s.createInstance(src, startTime, duration);\n		var ok = s._playInstance(instance, interrupt, delay, offset, loop, volume, pan);\n		if (!ok) {instance._playFailed();}\n		return instance;\n	};\n\n	/**\n	 * Creates a {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} using the passed in src. If the src does not have a\n	 * supported extension or if there is no available plugin, a default AbstractSoundInstance will be returned that can be\n	 * called safely but does nothing.\n	 *\n	 * <h4>Example</h4>\n	 *\n	 *      var myInstance = null;\n	 *      createjs.Sound.on("fileload", handleLoad);\n	 *      createjs.Sound.registerSound("myAudioPath/mySound.mp3", "myID", 3);\n	 *      function handleLoad(event) {\n	 *      	myInstance = createjs.Sound.createInstance("myID");\n	 *      	// alternately we could call the following\n	 *      	myInstance = createjs.Sound.createInstance("myAudioPath/mySound.mp3");\n	 *      }\n	 *\n	 * NOTE to create an audio sprite that has not already been registered, both startTime and duration need to be set.\n	 * This is only when creating a new audio sprite, not when playing using the id of an already registered audio sprite.\n	 *\n	 * @method createInstance\n	 * @param {String} src The src or ID of the audio.\n	 * @param {Number} [startTime=null] To create an audio sprite (with duration), the initial offset to start playback and loop from, in milliseconds.\n	 * @param {Number} [duration=null] To create an audio sprite (with startTime), the amount of time to play the clip for, in milliseconds.\n	 * @return {AbstractSoundInstance} A {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} that can be controlled after it is created.\n	 * Unsupported extensions will return the default AbstractSoundInstance.\n	 * @since 0.4.0\n	 */\n	s.createInstance = function (src, startTime, duration) {\n		if (!s.initializeDefaultPlugins()) {return new createjs.DefaultSoundInstance(src, startTime, duration);}\n\n		src = s._getSrcById(src);\n\n		var details = s._parsePath(src.src);\n\n		var instance = null;\n		if (details != null && details.src != null) {\n			SoundChannel.create(details.src);\n			if (startTime == null) {startTime = src.startTime;}\n			instance = s.activePlugin.create(details.src, startTime, duration || src.duration);\n		} else {\n			instance = new createjs.DefaultSoundInstance(src, startTime, duration);;\n		}\n\n		instance.uniqueId = s._lastID++;\n\n		return instance;\n	};\n\n	/**\n	 * Set the master volume of Sound. The master volume is multiplied against each sound\'s individual volume.  For\n	 * example, if master volume is 0.5 and a sound\'s volume is 0.5, the resulting volume is 0.25. To set individual\n	 * sound volume, use AbstractSoundInstance {{#crossLink "AbstractSoundInstance/setVolume"}}{{/crossLink}} instead.\n	 *\n	 * <h4>Example</h4>\n	 *\n	 *     createjs.Sound.setVolume(0.5);\n	 *\n	 * @method setVolume\n	 * @param {Number} value The master volume value. The acceptable range is 0-1.\n	 * @static\n	 */\n	s.setVolume = function (value) {\n		if (Number(value) == null) {return false;}\n		value = Math.max(0, Math.min(1, value));\n		s._masterVolume = value;\n		if (!this.activePlugin || !this.activePlugin.setVolume || !this.activePlugin.setVolume(value)) {\n			var instances = this._instances;\n			for (var i = 0, l = instances.length; i < l; i++) {\n				instances[i].setMasterVolume(value);\n			}\n		}\n	};\n\n	/**\n	 * Get the master volume of Sound. The master volume is multiplied against each sound\'s individual volume.\n	 * To get individual sound volume, use AbstractSoundInstance {{#crossLink "AbstractSoundInstance/volume:property"}}{{/crossLink}} instead.\n	 *\n	 * <h4>Example</h4>\n	 *\n	 *     var masterVolume = createjs.Sound.getVolume();\n	 *\n	 * @method getVolume\n	 * @return {Number} The master volume, in a range of 0-1.\n	 * @static\n	 */\n	s.getVolume = function () {\n		return s._masterVolume;\n	};\n\n	/**\n	 * Mute/Unmute all audio. Note that muted audio still plays at 0 volume. This global mute value is maintained\n	 * separately and when set will override, but not change the mute property of individual instances. To mute an individual\n	 * instance, use AbstractSoundInstance {{#crossLink "AbstractSoundInstance/setMute"}}{{/crossLink}} instead.\n	 *\n	 * <h4>Example</h4>\n	 *\n	 *     createjs.Sound.setMute(true);\n	 *\n	 * @method setMute\n	 * @param {Boolean} value Whether the audio should be muted or not.\n	 * @return {Boolean} If the mute was set.\n	 * @static\n	 * @since 0.4.0\n	 */\n	s.setMute = function (value) {\n		if (value == null) {return false;}\n\n		this._masterMute = value;\n		if (!this.activePlugin || !this.activePlugin.setMute || !this.activePlugin.setMute(value)) {\n			var instances = this._instances;\n			for (var i = 0, l = instances.length; i < l; i++) {\n				instances[i].setMasterMute(value);\n			}\n		}\n		return true;\n	};\n\n	/**\n	 * Returns the global mute value. To get the mute value of an individual instance, use AbstractSoundInstance\n	 * {{#crossLink "AbstractSoundInstance/getMute"}}{{/crossLink}} instead.\n	 *\n	 * <h4>Example</h4>\n	 *\n	 *     var muted = createjs.Sound.getMute();\n	 *\n	 * @method getMute\n	 * @return {Boolean} The mute value of Sound.\n	 * @static\n	 * @since 0.4.0\n	 */\n	s.getMute = function () {\n		return this._masterMute;\n	};\n\n	/**\n	 * Stop all audio (global stop). Stopped audio is reset, and not paused. To play audio that has been stopped,\n	 * call AbstractSoundInstance {{#crossLink "AbstractSoundInstance/play"}}{{/crossLink}}.\n	 *\n	 * <h4>Example</h4>\n	 *\n	 *     createjs.Sound.stop();\n	 *\n	 * @method stop\n	 * @static\n	 */\n	s.stop = function () {\n		var instances = this._instances;\n		for (var i = instances.length; i--; ) {\n			instances[i].stop();  // NOTE stop removes instance from this._instances\n		}\n	};\n\n\n	/* ---------------\n	 Internal methods\n	 --------------- */\n	/**\n	 * Play an instance. This is called by the static API, as well as from plugins. This allows the core class to\n	 * control delays.\n	 * @method _playInstance\n	 * @param {AbstractSoundInstance} instance The {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} to start playing.\n	 * @param {String | Object} [interrupt="none"|options] How to interrupt any currently playing instances of audio with the same source,\n	 * if the maximum number of instances of the sound are already playing. Values are defined as <code>INTERRUPT_TYPE</code>\n	 * constants on the Sound class, with the default defined by {{#crossLink "Sound/defaultInterruptBehavior"}}{{/crossLink}}.\n	 * <br /><strong>OR</strong><br />\n	 * This parameter can be an object that contains any or all optional properties by name, including: interrupt,\n	 * delay, offset, loop, volume, and pan (see the above code sample).\n	 * @param {Number} [delay=0] Time in milliseconds before playback begins.\n	 * @param {Number} [offset=instance.offset] Time into the sound to begin playback in milliseconds.  Defaults to the\n	 * current value on the instance.\n	 * @param {Number} [loop=0] The number of times to loop the audio. Use 0 for no loops, and -1 for an infinite loop.\n	 * @param {Number} [volume] The volume of the sound between 0 and 1. Defaults to current instance value.\n	 * @param {Number} [pan] The pan of the sound between -1 and 1. Defaults to current instance value.\n	 * @return {Boolean} If the sound can start playing. Sounds that fail immediately will return false. Sounds that\n	 * have a delay will return true, but may still fail to play.\n	 * @protected\n	 * @static\n	 */\n	s._playInstance = function (instance, interrupt, delay, offset, loop, volume, pan) {\n		if (interrupt instanceof Object) {\n			delay = interrupt.delay;\n			offset = interrupt.offset;\n			loop = interrupt.loop;\n			volume = interrupt.volume;\n			pan = interrupt.pan;\n			interrupt = interrupt.interrupt;\n		}\n\n		interrupt = interrupt || s.defaultInterruptBehavior;\n		if (delay == null) {delay = 0;}\n		if (offset == null) {offset = instance.getPosition();}\n		if (loop == null) {loop = instance.loop;}\n		if (volume == null) {volume = instance.volume;}\n		if (pan == null) {pan = instance.pan;}\n\n		if (delay == 0) {\n			var ok = s._beginPlaying(instance, interrupt, offset, loop, volume, pan);\n			if (!ok) {return false;}\n		} else {\n			//Note that we can\'t pass arguments to proxy OR setTimeout (IE only), so just wrap the function call.\n			// OJR WebAudio may want to handle this differently, so it might make sense to move this functionality into the plugins in the future\n			var delayTimeoutId = setTimeout(function () {\n				s._beginPlaying(instance, interrupt, offset, loop, volume, pan);\n			}, delay);\n			instance.delayTimeoutId = delayTimeoutId;\n		}\n\n		this._instances.push(instance);\n\n		return true;\n	};\n\n	/**\n	 * Begin playback. This is called immediately or after delay by {{#crossLink "Sound/playInstance"}}{{/crossLink}}.\n	 * @method _beginPlaying\n	 * @param {AbstractSoundInstance} instance A {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} to begin playback.\n	 * @param {String} [interrupt=none] How this sound interrupts other instances with the same source. Defaults to\n	 * {{#crossLink "Sound/INTERRUPT_NONE:property"}}{{/crossLink}}. Interrupts are defined as <code>INTERRUPT_TYPE</code>\n	 * constants on Sound.\n	 * @param {Number} [offset] Time in milliseconds into the sound to begin playback.  Defaults to the current value on\n	 * the instance.\n	 * @param {Number} [loop=0] The number of times to loop the audio. Use 0 for no loops, and -1 for an infinite loop.\n	 * @param {Number} [volume] The volume of the sound between 0 and 1. Defaults to the current value on the instance.\n	 * @param {Number} [pan=instance.pan] The pan of the sound between -1 and 1. Defaults to current instance value.\n	 * @return {Boolean} If the sound can start playing. If there are no available channels, or the instance fails to\n	 * start, this will return false.\n	 * @protected\n	 * @static\n	 */\n	s._beginPlaying = function (instance, interrupt, offset, loop, volume, pan) {\n		if (!SoundChannel.add(instance, interrupt)) {\n			return false;\n		}\n		var result = instance._beginPlaying(offset, loop, volume, pan);\n		if (!result) {\n			var index = createjs.indexOf(this._instances, instance);\n			if (index > -1) {this._instances.splice(index, 1);}\n			return false;\n		}\n		return true;\n	};\n\n	/**\n	 * Get the source of a sound via the ID passed in with a register call. If no ID is found the value is returned\n	 * instead.\n	 * @method _getSrcById\n	 * @param {String} value The ID the sound was registered with.\n	 * @return {String} The source of the sound if it has been registered with this ID or the value that was passed in.\n	 * @protected\n	 * @static\n	 */\n	s._getSrcById = function (value) {\n		return s._idHash[value] || {src: value};\n	};\n\n	/**\n	 * A sound has completed playback, been interrupted, failed, or been stopped. This method removes the instance from\n	 * Sound management. It will be added again, if the sound re-plays. Note that this method is called from the\n	 * instances themselves.\n	 * @method _playFinished\n	 * @param {AbstractSoundInstance} instance The instance that finished playback.\n	 * @protected\n	 * @static\n	 */\n	s._playFinished = function (instance) {\n		SoundChannel.remove(instance);\n		var index = createjs.indexOf(this._instances, instance);\n		if (index > -1) {this._instances.splice(index, 1);}	// OJR this will always be > -1, there is no way for an instance to exist without being added to this._instances\n	};\n\n	createjs.Sound = Sound;\n\n	/**\n	 * An internal class that manages the number of active {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} instances for\n	 * each sound type. This method is only used internally by the {{#crossLink "Sound"}}{{/crossLink}} class.\n	 *\n	 * The number of sounds is artificially limited by Sound in order to prevent over-saturation of a\n	 * single sound, as well as to stay within hardware limitations, although the latter may disappear with better\n	 * browser support.\n	 *\n	 * When a sound is played, this class ensures that there is an available instance, or interrupts an appropriate\n	 * sound that is already playing.\n	 * #class SoundChannel\n	 * @param {String} src The source of the instances\n	 * @param {Number} [max=1] The number of instances allowed\n	 * @constructor\n	 * @protected\n	 */\n	function SoundChannel(src, max) {\n		this.init(src, max);\n	}\n\n	/* ------------\n	 Static API\n	 ------------ */\n	/**\n	 * A hash of channel instances indexed by source.\n	 * #property channels\n	 * @type {Object}\n	 * @static\n	 */\n	SoundChannel.channels = {};\n\n	/**\n	 * Create a sound channel. Note that if the sound channel already exists, this will fail.\n	 * #method create\n	 * @param {String} src The source for the channel\n	 * @param {Number} max The maximum amount this channel holds. The default is {{#crossLink "SoundChannel.maxDefault"}}{{/crossLink}}.\n	 * @return {Boolean} If the channels were created.\n	 * @static\n	 */\n	SoundChannel.create = function (src, max) {\n		var channel = SoundChannel.get(src);\n		if (channel == null) {\n			SoundChannel.channels[src] = new SoundChannel(src, max);\n			return true;\n		}\n		return false;\n	};\n	/**\n	 * Delete a sound channel, stop and delete all related instances. Note that if the sound channel does not exist, this will fail.\n	 * #method remove\n	 * @param {String} src The source for the channel\n	 * @return {Boolean} If the channels were deleted.\n	 * @static\n	 */\n	SoundChannel.removeSrc = function (src) {\n		var channel = SoundChannel.get(src);\n		if (channel == null) {return false;}\n		channel._removeAll();	// this stops and removes all active instances\n		delete(SoundChannel.channels[src]);\n		return true;\n	};\n	/**\n	 * Delete all sound channels, stop and delete all related instances.\n	 * #method removeAll\n	 * @static\n	 */\n	SoundChannel.removeAll = function () {\n		for(var channel in SoundChannel.channels) {\n			SoundChannel.channels[channel]._removeAll();	// this stops and removes all active instances\n		}\n		SoundChannel.channels = {};\n	};\n	/**\n	 * Add an instance to a sound channel.\n	 * #method add\n	 * @param {AbstractSoundInstance} instance The instance to add to the channel\n	 * @param {String} interrupt The interrupt value to use. Please see the {{#crossLink "Sound/play"}}{{/crossLink}}\n	 * for details on interrupt modes.\n	 * @return {Boolean} The success of the method call. If the channel is full, it will return false.\n	 * @static\n	 */\n	SoundChannel.add = function (instance, interrupt) {\n		var channel = SoundChannel.get(instance.src);\n		if (channel == null) {return false;}\n		return channel._add(instance, interrupt);\n	};\n	/**\n	 * Remove an instance from the channel.\n	 * #method remove\n	 * @param {AbstractSoundInstance} instance The instance to remove from the channel\n	 * @return The success of the method call. If there is no channel, it will return false.\n	 * @static\n	 */\n	SoundChannel.remove = function (instance) {\n		var channel = SoundChannel.get(instance.src);\n		if (channel == null) {return false;}\n		channel._remove(instance);\n		return true;\n	};\n	/**\n	 * Get the maximum number of sounds you can have in a channel.\n	 * #method maxPerChannel\n	 * @return {Number} The maximum number of sounds you can have in a channel.\n	 */\n	SoundChannel.maxPerChannel = function () {\n		return p.maxDefault;\n	};\n	/**\n	 * Get a channel instance by its src.\n	 * #method get\n	 * @param {String} src The src to use to look up the channel\n	 * @static\n	 */\n	SoundChannel.get = function (src) {\n		return SoundChannel.channels[src];\n	};\n\n	var p = SoundChannel.prototype;\n	p.constructor = SoundChannel;\n\n	/**\n	 * The source of the channel.\n	 * #property src\n	 * @type {String}\n	 */\n	p.src = null;\n\n	/**\n	 * The maximum number of instances in this channel.  -1 indicates no limit\n	 * #property max\n	 * @type {Number}\n	 */\n	p.max = null;\n\n	/**\n	 * The default value to set for max, if it isn\'t passed in.  Also used if -1 is passed.\n	 * #property maxDefault\n	 * @type {Number}\n	 * @default 100\n	 * @since 0.4.0\n	 */\n	p.maxDefault = 100;\n\n	/**\n	 * The current number of active instances.\n	 * #property length\n	 * @type {Number}\n	 */\n	p.length = 0;\n\n	/**\n	 * Initialize the channel.\n	 * #method init\n	 * @param {String} src The source of the channel\n	 * @param {Number} max The maximum number of instances in the channel\n	 * @protected\n	 */\n	p.init = function (src, max) {\n		this.src = src;\n		this.max = max || this.maxDefault;\n		if (this.max == -1) {this.max = this.maxDefault;}\n		this._instances = [];\n	};\n\n	/**\n	 * Get an instance by index.\n	 * #method get\n	 * @param {Number} index The index to return.\n	 * @return {AbstractSoundInstance} The AbstractSoundInstance at a specific instance.\n	 */\n	p._get = function (index) {\n		return this._instances[index];\n	};\n\n	/**\n	 * Add a new instance to the channel.\n	 * #method add\n	 * @param {AbstractSoundInstance} instance The instance to add.\n	 * @return {Boolean} The success of the method call. If the channel is full, it will return false.\n	 */\n	p._add = function (instance, interrupt) {\n		if (!this._getSlot(interrupt, instance)) {return false;}\n		this._instances.push(instance);\n		this.length++;\n		return true;\n	};\n\n	/**\n	 * Remove an instance from the channel, either when it has finished playing, or it has been interrupted.\n	 * #method remove\n	 * @param {AbstractSoundInstance} instance The instance to remove\n	 * @return {Boolean} The success of the remove call. If the instance is not found in this channel, it will\n	 * return false.\n	 */\n	p._remove = function (instance) {\n		var index = createjs.indexOf(this._instances, instance);\n		if (index == -1) {return false;}\n		this._instances.splice(index, 1);\n		this.length--;\n		return true;\n	};\n\n	/**\n	 * Stop playback and remove all instances from the channel.  Usually in response to a delete call.\n	 * #method removeAll\n	 */\n	p._removeAll = function () {\n		// Note that stop() removes the item from the list\n		for (var i=this.length-1; i>=0; i--) {\n			this._instances[i].stop();\n		}\n	};\n\n	/**\n	 * Get an available slot depending on interrupt value and if slots are available.\n	 * #method getSlot\n	 * @param {String} interrupt The interrupt value to use.\n	 * @param {AbstractSoundInstance} instance The sound instance that will go in the channel if successful.\n	 * @return {Boolean} Determines if there is an available slot. Depending on the interrupt mode, if there are no slots,\n	 * an existing AbstractSoundInstance may be interrupted. If there are no slots, this method returns false.\n	 */\n	p._getSlot = function (interrupt, instance) {\n		var target, replacement;\n\n		if (interrupt != Sound.INTERRUPT_NONE) {\n			// First replacement candidate\n			replacement = this._get(0);\n			if (replacement == null) {\n				return true;\n			}\n		}\n\n		for (var i = 0, l = this.max; i < l; i++) {\n			target = this._get(i);\n\n			// Available Space\n			if (target == null) {\n				return true;\n			}\n\n			// Audio is complete or not playing\n			if (target.playState == Sound.PLAY_FINISHED ||\n				target.playState == Sound.PLAY_INTERRUPTED ||\n				target.playState == Sound.PLAY_FAILED) {\n				replacement = target;\n				break;\n			}\n\n			if (interrupt == Sound.INTERRUPT_NONE) {\n				continue;\n			}\n\n			// Audio is a better candidate than the current target, according to playhead\n			if ((interrupt == Sound.INTERRUPT_EARLY && target.getPosition() < replacement.getPosition()) ||\n				(interrupt == Sound.INTERRUPT_LATE && target.getPosition() > replacement.getPosition())) {\n					replacement = target;\n			}\n		}\n\n		if (replacement != null) {\n			replacement._interrupt();\n			this._remove(replacement);\n			return true;\n		}\n		return false;\n	};\n\n	p.toString = function () {\n		return "[Sound SoundChannel]";\n	};\n	// do not add SoundChannel to namespace\n\n}());\n\n//##############################################################################\n// AbstractSoundInstance.js\n//##############################################################################\n\nthis.createjs = this.createjs || {};\n\n/**\n * A AbstractSoundInstance is created when any calls to the Sound API method {{#crossLink "Sound/play"}}{{/crossLink}} or\n * {{#crossLink "Sound/createInstance"}}{{/crossLink}} are made. The AbstractSoundInstance is returned by the active plugin\n * for control by the user.\n *\n * <h4>Example</h4>\n *\n *      var myInstance = createjs.Sound.play("myAssetPath/mySrcFile.mp3");\n *\n * A number of additional parameters provide a quick way to determine how a sound is played. Please see the Sound\n * API method {{#crossLink "Sound/play"}}{{/crossLink}} for a list of arguments.\n *\n * Once a AbstractSoundInstance is created, a reference can be stored that can be used to control the audio directly through\n * the AbstractSoundInstance. If the reference is not stored, the AbstractSoundInstance will play out its audio (and any loops), and\n * is then de-referenced from the {{#crossLink "Sound"}}{{/crossLink}} class so that it can be cleaned up. If audio\n * playback has completed, a simple call to the {{#crossLink "AbstractSoundInstance/play"}}{{/crossLink}} instance method\n * will rebuild the references the Sound class need to control it.\n *\n *      var myInstance = createjs.Sound.play("myAssetPath/mySrcFile.mp3", {loop:2});\n *      myInstance.on("loop", handleLoop);\n *      function handleLoop(event) {\n *          myInstance.volume = myInstance.volume * 0.5;\n *      }\n *\n * Events are dispatched from the instance to notify when the sound has completed, looped, or when playback fails\n *\n *      var myInstance = createjs.Sound.play("myAssetPath/mySrcFile.mp3");\n *      myInstance.on("complete", handleComplete);\n *      myInstance.on("loop", handleLoop);\n *      myInstance.on("failed", handleFailed);\n *\n *\n * @class AbstractSoundInstance\n * @param {String} src The path to and file name of the sound.\n * @param {Number} startTime Audio sprite property used to apply an offset, in milliseconds.\n * @param {Number} duration Audio sprite property used to set the time the clip plays for, in milliseconds.\n * @param {Object} playbackResource Any resource needed by plugin to support audio playback.\n * @extends EventDispatcher\n * @constructor\n */\n\n(function () {\n	"use strict";\n\n\n// Constructor:\n	var AbstractSoundInstance = function (src, startTime, duration, playbackResource) {\n		this.EventDispatcher_constructor();\n\n\n	// public properties:\n		/**\n		 * The source of the sound.\n		 * @property src\n		 * @type {String}\n		 * @default null\n		 */\n		this.src = src;\n\n		/**\n		 * The unique ID of the instance. This is set by {{#crossLink "Sound"}}{{/crossLink}}.\n		 * @property uniqueId\n		 * @type {String} | Number\n		 * @default -1\n		 */\n		this.uniqueId = -1;\n\n		/**\n		 * The play state of the sound. Play states are defined as constants on {{#crossLink "Sound"}}{{/crossLink}}.\n		 * @property playState\n		 * @type {String}\n		 * @default null\n		 */\n		this.playState = null;\n\n		/**\n		 * A Timeout created by {{#crossLink "Sound"}}{{/crossLink}} when this AbstractSoundInstance is played with a delay.\n		 * This allows AbstractSoundInstance to remove the delay if stop, pause, or cleanup are called before playback begins.\n		 * @property delayTimeoutId\n		 * @type {timeoutVariable}\n		 * @default null\n		 * @protected\n		 * @since 0.4.0\n		 */\n		this.delayTimeoutId = null;\n		// TODO consider moving delay into AbstractSoundInstance so it can be handled by plugins\n\n\n	// private properties\n		/**\n		 * Audio sprite property used to determine the starting offset.\n		 * @type {Number}\n		 * @default null\n		 * @protected\n		 */\n		this._startTime = Math.max(0, startTime || 0);\n		//TODO add a getter / setter for startTime?\n\n\n	// Getter / Setter Properties\n		// OJR TODO find original reason that we didn\'t use defined functions.  I think it was performance related\n		/**\n		 * The volume of the sound, between 0 and 1.\n		 * <br />Note this uses a getter setter, which is not supported by Firefox versions 3.6 or lower and Opera versions 11.50 or lower,\n		 * and Internet Explorer 8 or lower.  Instead use {{#crossLink "AbstractSoundInstance/setVolume"}}{{/crossLink}} and {{#crossLink "AbstractSoundInstance/getVolume"}}{{/crossLink}}.\n		 *\n		 * The actual output volume of a sound can be calculated using:\n		 * <code>myInstance.volume * createjs.Sound.getVolume();</code>\n		 *\n		 * @property volume\n		 * @type {Number}\n		 * @default 1\n		 */\n		this._volume =  1;\n		if (createjs.definePropertySupported) {\n			Object.defineProperty(this, "volume", {\n			get: this.getVolume,\n			set: this.setVolume\n			});\n		}\n\n		/**\n		 * The pan of the sound, between -1 (left) and 1 (right). Note that pan is not supported by HTML Audio.\n		 *\n		 * <br />Note this uses a getter setter, which is not supported by Firefox versions 3.6 or lower, Opera versions 11.50 or lower,\n		 * and Internet Explorer 8 or lower.  Instead use {{#crossLink "AbstractSoundInstance/setPan"}}{{/crossLink}} and {{#crossLink "AbstractSoundInstance/getPan"}}{{/crossLink}}.\n		 * <br />Note in WebAudioPlugin this only gives us the "x" value of what is actually 3D audio.\n		 *\n		 * @property pan\n		 * @type {Number}\n		 * @default 0\n		 */\n		this._pan =  0;\n		if (createjs.definePropertySupported) {\n			Object.defineProperty(this, "pan", {\n				get: this.getPan,\n				set: this.setPan\n			});\n		}\n\n		/**\n		 * The length of the audio clip, in milliseconds.\n		 *\n		 * <br />Note this uses a getter setter, which is not supported by Firefox versions 3.6 or lower, Opera versions 11.50 or lower,\n		 * and Internet Explorer 8 or lower.  Instead use {{#crossLink "AbstractSoundInstance/setDuration"}}{{/crossLink}} and {{#crossLink "AbstractSoundInstance/getDuration"}}{{/crossLink}}.\n		 *\n		 * @property duration\n		 * @type {Number}\n		 * @default 0\n		 * @since 0.6.0\n		 */\n		this._duration = Math.max(0, duration || 0);\n		if (createjs.definePropertySupported) {\n			Object.defineProperty(this, "duration", {\n				get: this.getDuration,\n				set: this.setDuration\n			});\n		}\n\n		/**\n		 * Object that holds plugin specific resource need for audio playback.\n		 * This is set internally by the plugin.  For example, WebAudioPlugin will set an array buffer,\n		 * HTMLAudioPlugin will set a tag, FlashAudioPlugin will set a flash reference.\n		 *\n		 * @property playbackResource\n		 * @type {Object}\n		 * @default null\n		 */\n		this._playbackResource = null;\n		if (createjs.definePropertySupported) {\n			Object.defineProperty(this, "playbackResource", {\n				get: this.getPlaybackResource,\n				set: this.setPlaybackResource\n			});\n		}\n		if(playbackResource !== false && playbackResource !== true) { this.setPlaybackResource(playbackResource); }\n\n		/**\n		 * The position of the playhead in milliseconds. This can be set while a sound is playing, paused, or stopped.\n		 *\n		 * <br />Note this uses a getter setter, which is not supported by Firefox versions 3.6 or lower, Opera versions 11.50 or lower,\n		 * and Internet Explorer 8 or lower.  Instead use {{#crossLink "AbstractSoundInstance/setPosition"}}{{/crossLink}} and {{#crossLink "AbstractSoundInstance/getPosition"}}{{/crossLink}}.\n		 *\n		 * @property position\n		 * @type {Number}\n		 * @default 0\n		 * @since 0.6.0\n		 */\n		this._position = 0;\n		if (createjs.definePropertySupported) {\n			Object.defineProperty(this, "position", {\n				get: this.getPosition,\n				set: this.setPosition\n			});\n		}\n\n		/**\n		 * The number of play loops remaining. Negative values will loop infinitely.\n		 *\n  		 * <br />Note this uses a getter setter, which is not supported by Firefox versions 3.6 or lower, Opera versions 11.50 or lower,\n		 * and Internet Explorer 8 or lower.  Instead use {{#crossLink "AbstractSoundInstance/setLoop"}}{{/crossLink}} and {{#crossLink "AbstractSoundInstance/getLoop"}}{{/crossLink}}.\n		 *\n		 * @property loop\n		 * @type {Number}\n		 * @default 0\n		 * @public\n		 * @since 0.6.0\n		 */\n		this._loop = 0;\n		if (createjs.definePropertySupported) {\n			Object.defineProperty(this, "loop", {\n				get: this.getLoop,\n				set: this.setLoop\n			});\n		}\n\n		/**\n		 * Determines if the audio is currently muted.\n		 *\n		 * <br />Note this uses a getter setter, which is not supported by Firefox versions 3.6 or lower, Opera versions 11.50 or lower,\n		 * and Internet Explorer 8 or lower.  Instead use {{#crossLink "AbstractSoundInstance/setMute"}}{{/crossLink}} and {{#crossLink "AbstractSoundInstance/getMute"}}{{/crossLink}}.\n		 *\n		 * @property muted\n		 * @type {Boolean}\n		 * @default false\n		 * @since 0.6.0\n		 */\n		this._muted = false;\n		if (createjs.definePropertySupported) {\n			Object.defineProperty(this, "muted", {\n				get: this.getMuted,\n				set: this.setMuted\n			});\n		}\n\n		/**\n		 * Tells you if the audio is currently paused.\n		 *\n		 * <br />Note this uses a getter setter, which is not supported by Firefox versions 3.6 or lower, Opera versions 11.50 or lower,\n		 * and Internet Explorer 8 or lower.\n		 * Use {{#crossLink "AbstractSoundInstance/pause:method"}}{{/crossLink}} and {{#crossLink "AbstractSoundInstance/resume:method"}}{{/crossLink}} to set.\n		 *\n		 * @property paused\n		 * @type {Boolean}\n		 */\n		this._paused = false;\n		if (createjs.definePropertySupported) {\n			Object.defineProperty(this, "paused", {\n				get: this.getPaused,\n				set: this.setPaused\n			});\n		}\n\n\n	// Events\n		/**\n		 * The event that is fired when playback has started successfully.\n		 * @event succeeded\n		 * @param {Object} target The object that dispatched the event.\n		 * @param {String} type The event type.\n		 * @since 0.4.0\n		 */\n\n		/**\n		 * The event that is fired when playback is interrupted. This happens when another sound with the same\n		 * src property is played using an interrupt value that causes this instance to stop playing.\n		 * @event interrupted\n		 * @param {Object} target The object that dispatched the event.\n		 * @param {String} type The event type.\n		 * @since 0.4.0\n		 */\n\n		/**\n		 * The event that is fired when playback has failed. This happens when there are too many channels with the same\n		 * src property already playing (and the interrupt value doesn\'t cause an interrupt of another instance), or\n		 * the sound could not be played, perhaps due to a 404 error.\n		 * @event failed\n		 * @param {Object} target The object that dispatched the event.\n		 * @param {String} type The event type.\n		 * @since 0.4.0\n		 */\n\n		/**\n		 * The event that is fired when a sound has completed playing but has loops remaining.\n		 * @event loop\n		 * @param {Object} target The object that dispatched the event.\n		 * @param {String} type The event type.\n		 * @since 0.4.0\n		 */\n\n		/**\n		 * The event that is fired when playback completes. This means that the sound has finished playing in its\n		 * entirety, including its loop iterations.\n		 * @event complete\n		 * @param {Object} target The object that dispatched the event.\n		 * @param {String} type The event type.\n		 * @since 0.4.0\n		 */\n	};\n\n	var p = createjs.extend(AbstractSoundInstance, createjs.EventDispatcher);\n\n\n// Public Methods:\n	/**\n	 * Play an instance. This method is intended to be called on SoundInstances that already exist (created\n	 * with the Sound API {{#crossLink "Sound/createInstance"}}{{/crossLink}} or {{#crossLink "Sound/play"}}{{/crossLink}}).\n	 *\n	 * <h4>Example</h4>\n	 *\n	 *      var myInstance = createjs.Sound.createInstance(mySrc);\n	 *      myInstance.play({offset:1, loop:2, pan:0.5});	// options as object properties\n	 *      myInstance.play(createjs.Sound.INTERRUPT_ANY);	// options as parameters\n	 *\n	 * Note that if this sound is already playing, this call will do nothing.\n	 *\n	 * @method play\n	 * @param {String | Object} [interrupt="none"|options] How to interrupt any currently playing instances of audio with the same source,\n	 * if the maximum number of instances of the sound are already playing. Values are defined as <code>INTERRUPT_TYPE</code>\n	 * constants on the Sound class, with the default defined by Sound {{#crossLink "Sound/defaultInterruptBehavior:property"}}{{/crossLink}}.\n	 * <br /><strong>OR</strong><br />\n	 * This parameter can be an object that contains any or all optional properties by name, including: interrupt,\n	 * delay, offset, loop, volume, and pan (see the above code sample).\n	 * @param {Number} [delay=0] The delay in milliseconds before the sound starts\n	 * @param {Number} [offset=0] How far into the sound to begin playback, in milliseconds.\n	 * @param {Number} [loop=0] The number of times to loop the audio. Use -1 for infinite loops.\n	 * @param {Number} [volume=1] The volume of the sound, between 0 and 1.\n	 * @param {Number} [pan=0] The pan of the sound between -1 (left) and 1 (right). Note that pan is not supported\n	 * for HTML Audio.\n	 * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.\n	 */\n	p.play = function (interrupt, delay, offset, loop, volume, pan) {\n		if (this.playState == createjs.Sound.PLAY_SUCCEEDED) {\n			if (interrupt instanceof Object) {\n				offset = interrupt.offset;\n				loop = interrupt.loop;\n				volume = interrupt.volume;\n				pan = interrupt.pan;\n			}\n			if (offset != null) { this.setPosition(offset) }\n			if (loop != null) { this.setLoop(loop); }\n			if (volume != null) { this.setVolume(volume); }\n			if (pan != null) { this.setPan(pan); }\n			if (this._paused) {	this.setPaused(false); }\n			return;\n		}\n		this._cleanUp();\n		createjs.Sound._playInstance(this, interrupt, delay, offset, loop, volume, pan);	// make this an event dispatch??\n		return this;\n	};\n\n	/**\n	 * Deprecated, please use {{#crossLink "AbstractSoundInstance/paused:property"}}{{/crossLink}} instead.\n	 *\n	 * @method pause\n	 * @return {Boolean} If the pause call succeeds. This will return false if the sound isn\'t currently playing.\n	 * @deprecated\n	 */\n	p.pause = function () {\n		if (this._paused || this.playState != createjs.Sound.PLAY_SUCCEEDED) {return false;}\n		this.setPaused(true);\n		return true;\n	};\n\n	/**\n	 * Deprecated, please use {{#crossLink "AbstractSoundInstance/paused:property"}}{{/crossLink}} instead.\n	 *\n	 * @method resume\n	 * @return {Boolean} If the resume call succeeds. This will return false if called on a sound that is not paused.\n	 * @deprecated\n	 */\n	p.resume = function () {\n		if (!this._paused) {return false;}\n		this.setPaused(false);\n		return true;\n	};\n\n	/**\n	 * Stop playback of the instance. Stopped sounds will reset their position to 0, and calls to {{#crossLink "AbstractSoundInstance/resume"}}{{/crossLink}}\n	 * will fail.  To start playback again, call {{#crossLink "AbstractSoundInstance/play"}}{{/crossLink}}.\n	 *\n	 * <h4>Example</h4>\n	 *\n	 *     myInstance.stop();\n	 *\n	 * @method stop\n	 * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.\n	 */\n	p.stop = function () {\n		this._position = 0;\n		this._paused = false;\n		this._handleStop();\n		this._cleanUp();\n		this.playState = createjs.Sound.PLAY_FINISHED;\n		return this;\n	};\n\n	/**\n	 * Remove all external references and resources from AbstractSoundInstance.  Note this is irreversible and AbstractSoundInstance will no longer work\n	 * @method destroy\n	 * @since 0.6.0\n	 */\n	p.destroy = function() {\n		this._cleanUp();\n		this.src = null;\n		this.playbackResource = null;\n\n		this.removeAllEventListeners();\n	};\n\n	p.toString = function () {\n		return "[AbstractSoundInstance]";\n	};\n\n\n// get/set methods that allow support for IE8\n	/**\n	 * NOTE {{#crossLink "AbstractSoundInstance/paused:property"}}{{/crossLink}} can be accessed directly as a property,\n	 * and getPaused remains to allow support for IE8 with FlashAudioPlugin.\n	 *\n	 * Returns true if the instance is currently paused.\n	 *\n	 * @method getPaused\n	 * @returns {boolean} If the instance is currently paused\n	 * @since 0.6.0\n	 */\n	p.getPaused = function() {\n		return this._paused;\n	};\n\n	/**\n	 * NOTE {{#crossLink "AbstractSoundInstance/paused:property"}}{{/crossLink}} can be accessed directly as a property,\n	 * setPaused remains to allow support for IE8 with FlashAudioPlugin.\n	 *\n	 * Pause or resume the instance.  Note you can also resume playback with {{#crossLink "AbstractSoundInstance/play"}}{{/crossLink}}.\n	 *\n	 * @param {boolean} value\n	 * @since 0.6.0\n	 * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.\n	 */\n	p.setPaused = function (value) {\n		if ((value !== true && value !== false) || this._paused == value) {return;}\n		if (value == true && this.playState != createjs.Sound.PLAY_SUCCEEDED) {return;}\n		this._paused = value;\n		if(value) {\n			this._pause();\n		} else {\n			this._resume();\n		}\n		clearTimeout(this.delayTimeoutId);\n		return this;\n	};\n\n	/**\n	 * NOTE {{#crossLink "AbstractSoundInstance/volume:property"}}{{/crossLink}} can be accessed directly as a property,\n	 * setVolume remains to allow support for IE8 with FlashAudioPlugin.\n	 *\n	 * Set the volume of the instance.\n	 *\n	 * <h4>Example</h4>\n	 *\n	 *      myInstance.setVolume(0.5);\n	 *\n	 * Note that the master volume set using the Sound API method {{#crossLink "Sound/setVolume"}}{{/crossLink}}\n	 * will be applied to the instance volume.\n	 *\n	 * @method setVolume\n	 * @param value The volume to set, between 0 and 1.\n	 * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.\n	 */\n	p.setVolume = function (value) {\n		if (value == this._volume) { return this; }\n		this._volume = Math.max(0, Math.min(1, value));\n		if (!this._muted) {\n			this._updateVolume();\n		}\n		return this;\n	};\n\n	/**\n	 * NOTE {{#crossLink "AbstractSoundInstance/volume:property"}}{{/crossLink}} can be accessed directly as a property,\n	 * getVolume remains to allow support for IE8 with FlashAudioPlugin.\n	 *\n	 * Get the volume of the instance. The actual output volume of a sound can be calculated using:\n	 * <code>myInstance.getVolume() * createjs.Sound.getVolume();</code>\n	 *\n	 * @method getVolume\n	 * @return The current volume of the sound instance.\n	 */\n	p.getVolume = function () {\n		return this._volume;\n	};\n\n	/**\n	 * Deprecated, please use {{#crossLink "AbstractSoundInstance/muted:property"}}{{/crossLink}} instead.\n	 *\n	 * @method setMute\n	 * @param {Boolean} value If the sound should be muted.\n	 * @return {Boolean} If the mute call succeeds.\n	 * @deprecated\n	 */\n	p.setMute = function (value) {\n		this.setMuted(value);\n	};\n\n	/**\n	 * Deprecated, please use {{#crossLink "AbstractSoundInstance/muted:property"}}{{/crossLink}} instead.\n	 *\n	 * @method getMute\n	 * @return {Boolean} If the sound is muted.\n	 * @deprecated\n	 */\n	p.getMute = function () {\n		return this._muted;\n	};\n\n	/**\n	 * NOTE {{#crossLink "AbstractSoundInstance/muted:property"}}{{/crossLink}} can be accessed directly as a property,\n	 * setMuted exists to allow support for IE8 with FlashAudioPlugin.\n	 *\n	 * Mute and unmute the sound. Muted sounds will still play at 0 volume. Note that an unmuted sound may still be\n	 * silent depending on {{#crossLink "Sound"}}{{/crossLink}} volume, instance volume, and Sound muted.\n	 *\n	 * <h4>Example</h4>\n	 *\n	 *     myInstance.setMuted(true);\n	 *\n	 * @method setMute\n	 * @param {Boolean} value If the sound should be muted.\n	 * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.\n	 * @since 0.6.0\n	 */\n	p.setMuted = function (value) {\n		if (value !== true && value !== false) {return;}\n		this._muted = value;\n		this._updateVolume();\n		return this;\n	};\n\n	/**\n	 * NOTE {{#crossLink "AbstractSoundInstance/muted:property"}}{{/crossLink}} can be accessed directly as a property,\n	 * getMuted remains to allow support for IE8 with FlashAudioPlugin.\n	 *\n	 * Get the mute value of the instance.\n	 *\n	 * <h4>Example</h4>\n	 *\n	 *      var isMuted = myInstance.getMuted();\n	 *\n	 * @method getMute\n	 * @return {Boolean} If the sound is muted.\n	 * @since 0.6.0\n	 */\n	p.getMuted = function () {\n		return this._muted;\n	};\n\n	/**\n	 * NOTE {{#crossLink "AbstractSoundInstance/pan:property"}}{{/crossLink}} can be accessed directly as a property,\n	 * getPan remains to allow support for IE8 with FlashAudioPlugin.\n	 *\n	 * Set the left(-1)/right(+1) pan of the instance. Note that {{#crossLink "HTMLAudioPlugin"}}{{/crossLink}} does not\n	 * support panning, and only simple left/right panning has been implemented for {{#crossLink "WebAudioPlugin"}}{{/crossLink}}.\n	 * The default pan value is 0 (center).\n	 *\n	 * <h4>Example</h4>\n	 *\n	 *     myInstance.setPan(-1);  // to the left!\n	 *\n	 * @method setPan\n	 * @param {Number} value The pan value, between -1 (left) and 1 (right).\n	 * @return {AbstractSoundInstance} Returns reference to itself for chaining calls\n	 */\n	p.setPan = function (value) {\n		if(value == this._pan) { return this; }\n		this._pan = Math.max(-1, Math.min(1, value));\n		this._updatePan();\n		return this;\n	};\n\n	/**\n	 * NOTE {{#crossLink "AbstractSoundInstance/pan:property"}}{{/crossLink}} can be accessed directly as a property,\n	 * getPan remains to allow support for IE8 with FlashAudioPlugin.\n	 *\n	 * Get the left/right pan of the instance. Note in WebAudioPlugin this only gives us the "x" value of what is\n	 * actually 3D audio.\n	 *\n	 * <h4>Example</h4>\n	 *\n	 *     var myPan = myInstance.getPan();\n	 *\n	 * @method getPan\n	 * @return {Number} The value of the pan, between -1 (left) and 1 (right).\n	 */\n	p.getPan = function () {\n		return this._pan;\n	};\n\n	/**\n	 * NOTE {{#crossLink "AbstractSoundInstance/position:property"}}{{/crossLink}} can be accessed directly as a property,\n	 * getPosition remains to allow support for IE8 with FlashAudioPlugin.\n	 *\n	 * Get the position of the playhead of the instance in milliseconds.\n	 *\n	 * <h4>Example</h4>\n	 *\n	 *     var currentOffset = myInstance.getPosition();\n	 *\n	 * @method getPosition\n	 * @return {Number} The position of the playhead in the sound, in milliseconds.\n	 */\n	p.getPosition = function () {\n		if (!this._paused && this.playState == createjs.Sound.PLAY_SUCCEEDED) {\n			return this._calculateCurrentPosition();	// sets this._position\n		}\n		return this._position;\n	};\n\n	/**\n	 * NOTE {{#crossLink "AbstractSoundInstance/position:property"}}{{/crossLink}} can be accessed directly as a property,\n	 * setPosition remains to allow support for IE8 with FlashAudioPlugin.\n	 *\n	 * Set the position of the playhead in the instance. This can be set while a sound is playing, paused, or\n	 * stopped.\n	 *\n	 * <h4>Example</h4>\n	 *\n	 *      myInstance.setPosition(myInstance.getDuration()/2); // set audio to its halfway point.\n	 *\n	 * @method setPosition\n	 * @param {Number} value The position to place the playhead, in milliseconds.\n	 * @return {AbstractSoundInstance} Returns reference to itself for chaining calls\n	 */\n	p.setPosition = function (value) {\n		this._position = Math.max(0, value);\n		if (this.playState == createjs.Sound.PLAY_SUCCEEDED) {\n			this._updatePosition();\n		}\n		return this;\n	};\n\n	/**\n	 * NOTE {{#crossLink "AbstractSoundInstance/duration:property"}}{{/crossLink}} can be accessed directly as a property,\n	 * getDuration exists to allow support for IE8 with FlashAudioPlugin.\n	 *\n	 * Get the duration of the instance, in milliseconds.\n	 * Note a sound needs to be loaded before it will have duration, unless it was set manually to create an audio sprite.\n	 *\n	 * <h4>Example</h4>\n	 *\n	 *     var soundDur = myInstance.getDuration();\n	 *\n	 * @method getDuration\n	 * @return {Number} The duration of the sound instance in milliseconds.\n	 */\n	p.getDuration = function () {\n		return this._duration;\n	};\n\n	/**\n	 * NOTE {{#crossLink "AbstractSoundInstance/duration:property"}}{{/crossLink}} can be accessed directly as a property,\n	 * setDuration exists to allow support for IE8 with FlashAudioPlugin.\n	 *\n	 * Set the duration of the audio.  Generally this is not called, but it can be used to create an audio sprite out of an existing AbstractSoundInstance.\n	 *\n	 * @method setDuration\n	 * @param {number} value The new duration time in milli seconds.\n	 * @return {AbstractSoundInstance} Returns reference to itself for chaining calls\n	 * @since 0.6.0\n	 */\n	p.setDuration = function (value) {\n		if (value == this._duration) { return this; }\n		this._duration = Math.max(0, value || 0);\n		this._updateDuration();\n		return this;\n	};\n\n	/**\n	 * NOTE {{#crossLink "AbstractSoundInstance/playbackResource:property"}}{{/crossLink}} can be accessed directly as a property,\n	 * setPlaybackResource exists to allow support for IE8 with FlashAudioPlugin.\n	 *\n	 * An object containing any resources needed for audio playback, set by the plugin.\n	 * Only meant for use by advanced users.\n	 *\n	 * @method setPlayback\n	 * @param {Object} value The new playback resource.\n	 * @return {AbstractSoundInstance} Returns reference to itself for chaining calls\n	 * @since 0.6.0\n	 **/\n	p.setPlaybackResource = function (value) {\n		this._playbackResource = value;\n		if (this._duration == 0) { this._setDurationFromSource(); }\n		return this;\n	};\n\n	/**\n	 * NOTE {{#crossLink "AbstractSoundInstance/playbackResource:property"}}{{/crossLink}} can be accessed directly as a property,\n	 * getPlaybackResource exists to allow support for IE8 with FlashAudioPlugin.\n	 *\n	 * An object containing any resources needed for audio playback, usually set by the plugin.\n	 *\n	 * @method setPlayback\n	 * @param {Object} value The new playback resource.\n	 * @return {Object} playback resource used for playing audio\n	 * @since 0.6.0\n	 **/\n	p.getPlaybackResource = function () {\n		return this._playbackResource;\n	};\n\n	/**\n	 * NOTE {{#crossLink "AbstractSoundInstance/loop:property"}}{{/crossLink}} can be accessed directly as a property,\n	 * getLoop exists to allow support for IE8 with FlashAudioPlugin.\n	 *\n	 * The number of play loops remaining. Negative values will loop infinitely.\n	 *\n	 * @method getLoop\n	 * @return {number}\n	 * @since 0.6.0\n	 **/\n	p.getLoop = function () {\n		return this._loop;\n	};\n\n	/**\n	 * NOTE {{#crossLink "AbstractSoundInstance/loop:property"}}{{/crossLink}} can be accessed directly as a property,\n	 * setLoop exists to allow support for IE8 with FlashAudioPlugin.\n	 *\n	 * Set the number of play loops remaining.\n	 *\n	 * @method setLoop\n	 * @param {number} value The number of times to loop after play.\n	 * @since 0.6.0\n	 */\n	p.setLoop = function (value) {\n		if(this._playbackResource != null) {\n			// remove looping\n			if (this._loop != 0 && value == 0) {\n				this._removeLooping(value);\n			}\n			// add looping\n			if (this._loop == 0 && value != 0) {\n				this._addLooping(value);\n			}\n		}\n		this._loop = value;\n	};\n\n\n// Private Methods:\n	/**\n	 * A helper method that dispatches all events for AbstractSoundInstance.\n	 * @method _sendEvent\n	 * @param {String} type The event type\n	 * @protected\n	 */\n	p._sendEvent = function (type) {\n		var event = new createjs.Event(type);\n		this.dispatchEvent(event);\n	};\n\n	/**\n	 * Clean up the instance. Remove references and clean up any additional properties such as timers.\n	 * @method _cleanUp\n	 * @protected\n	 */\n	p._cleanUp = function () {\n		clearTimeout(this.delayTimeoutId); // clear timeout that plays delayed sound\n		this._handleCleanUp();\n		this._paused = false;\n\n		createjs.Sound._playFinished(this);	// TODO change to an event\n	};\n\n	/**\n	 * The sound has been interrupted.\n	 * @method _interrupt\n	 * @protected\n	 */\n	p._interrupt = function () {\n		this._cleanUp();\n		this.playState = createjs.Sound.PLAY_INTERRUPTED;\n		this._sendEvent("interrupted");\n	};\n\n	/**\n	 * Called by the Sound class when the audio is ready to play (delay has completed). Starts sound playing if the\n	 * src is loaded, otherwise playback will fail.\n	 * @method _beginPlaying\n	 * @param {Number} offset How far into the sound to begin playback, in milliseconds.\n	 * @param {Number} loop The number of times to loop the audio. Use -1 for infinite loops.\n	 * @param {Number} volume The volume of the sound, between 0 and 1.\n	 * @param {Number} pan The pan of the sound between -1 (left) and 1 (right). Note that pan does not work for HTML Audio.\n	 * @return {Boolean} If playback succeeded.\n	 * @protected\n	 */\n	p._beginPlaying = function (offset, loop, volume, pan) {\n		this.setPosition(offset);\n		this.setLoop(loop);\n		this.setVolume(volume);\n		this.setPan(pan);\n\n		if (this._playbackResource != null && this._position < this._duration) {\n			this._paused = false;\n			this._handleSoundReady();\n			this.playState = createjs.Sound.PLAY_SUCCEEDED;\n			this._sendEvent("succeeded");\n			return true;\n		} else {\n			this._playFailed();\n			return false;\n		}\n	};\n\n	/**\n	 * Play has failed, which can happen for a variety of reasons.\n	 * Cleans up instance and dispatches failed event\n	 * @method _playFailed\n	 * @private\n	 */\n	p._playFailed = function () {\n		this._cleanUp();\n		this.playState = createjs.Sound.PLAY_FAILED;\n		this._sendEvent("failed");\n	};\n\n	/**\n	 * Audio has finished playing. Manually loop it if required.\n	 * @method _handleSoundComplete\n	 * @param event\n	 * @protected\n	 */\n	p._handleSoundComplete = function (event) {\n		this._position = 0;  // have to set this as it can be set by pause during playback\n\n		if (this._loop != 0) {\n			this._loop--;  // NOTE this introduces a theoretical limit on loops = float max size x 2 - 1\n			this._handleLoop();\n			this._sendEvent("loop");\n			return;\n		}\n\n		this._cleanUp();\n		this.playState = createjs.Sound.PLAY_FINISHED;\n		this._sendEvent("complete");\n	};\n\n// Plugin specific code\n	/**\n	 * Handles starting playback when the sound is ready for playing.\n	 * @method _handleSoundReady\n	 * @protected\n 	 */\n	p._handleSoundReady = function () {\n		// plugin specific code\n	};\n\n	/**\n	 * Internal function used to update the volume based on the instance volume, master volume, instance mute value,\n	 * and master mute value.\n	 * @method _updateVolume\n	 * @protected\n	 */\n	p._updateVolume = function () {\n		// plugin specific code\n	};\n\n	/**\n	 * Internal function used to update the pan\n	 * @method _updatePan\n	 * @protected\n	 * @since 0.6.0\n	 */\n	p._updatePan = function () {\n		// plugin specific code\n	};\n\n	/**\n	 * Internal function used to update the duration of the audio.\n	 * @method _updateDuration\n	 * @protected\n	 * @since 0.6.0\n	 */\n	p._updateDuration = function () {\n		// plugin specific code\n	};\n\n	/**\n	 * Internal function used to get the duration of the audio from the source we\'ll be playing.\n	 * @method _updateDuration\n	 * @protected\n	 * @since 0.6.0\n	 */\n	p._setDurationFromSource = function () {\n		// plugin specific code\n	};\n\n	/**\n	 * Internal function that calculates the current position of the playhead and sets it on this._position\n	 * @method _updatePosition\n	 * @protected\n	 * @since 0.6.0\n	 */\n	p._calculateCurrentPosition = function () {\n		// plugin specific code that sets this.position\n	};\n\n	/**\n	 * Internal function used to update the position of the playhead.\n	 * @method _updatePosition\n	 * @protected\n	 * @since 0.6.0\n	 */\n	p._updatePosition = function () {\n		// plugin specific code\n	};\n\n	/**\n	 * Internal function called when looping is removed during playback.\n	 * @method _removeLooping\n	 * @protected\n	 * @since 0.6.0\n	 */\n	p._removeLooping = function () {\n		// plugin specific code\n	};\n\n	/**\n	 * Internal function called when looping is added during playback.\n	 * @method _addLooping\n	 * @protected\n	 * @since 0.6.0\n	 */\n	p._addLooping = function () {\n		// plugin specific code\n	};\n\n	/**\n	 * Internal function called when pausing playback\n	 * @method _pause\n	 * @protected\n	 * @since 0.6.0\n	 */\n	p._pause = function () {\n		// plugin specific code\n	};\n\n	/**\n	 * Internal function called when resuming playback\n	 * @method _resume\n	 * @protected\n	 * @since 0.6.0\n	 */\n	p._resume = function () {\n		// plugin specific code\n	};\n\n	/**\n	 * Internal function called when stopping playback\n	 * @method _handleStop\n	 * @protected\n	 * @since 0.6.0\n	 */\n	p._handleStop = function() {\n		// plugin specific code\n	};\n\n	/**\n	 * Internal function called when AbstractSoundInstance is being cleaned up\n	 * @method _handleCleanUp\n	 * @protected\n	 * @since 0.6.0\n	 */\n	p._handleCleanUp = function() {\n		// plugin specific code\n	};\n\n	/**\n	 * Internal function called when AbstractSoundInstance has played to end and is looping\n	 * @method _handleCleanUp\n	 * @protected\n	 * @since 0.6.0\n	 */\n	p._handleLoop = function () {\n		// plugin specific code\n	};\n\n	createjs.AbstractSoundInstance = createjs.promote(AbstractSoundInstance, "EventDispatcher");\n	createjs.DefaultSoundInstance = createjs.AbstractSoundInstance;	// used when no plugin is supported\n}());\n\n//##############################################################################\n// AbstractPlugin.js\n//##############################################################################\n\nthis.createjs = this.createjs || {};\n\n(function () {\n	"use strict";\n\n\n// constructor:\n 	/**\n	 * A default plugin class used as a base for all other plugins.\n	 * @class AbstractPlugin\n	 * @constructor\n	 * @since 0.6.0\n	 */\n\n	var AbstractPlugin = function () {\n	// private properties:\n		/**\n		 * The capabilities of the plugin.\n		 * method and is used internally.\n		 * @property _capabilities\n		 * @type {Object}\n		 * @default null\n		 * @protected\n		 * @static\n		 */\n		this._capabilities = null;\n\n		/**\n		 * Object hash indexed by the source URI of all created loaders, used to properly destroy them if sources are removed.\n		 * @type {Object}\n		 * @protected\n		 */\n		this._loaders = {};\n\n		/**\n		 * Object hash indexed by the source URI of each file to indicate if an audio source has begun loading,\n		 * is currently loading, or has completed loading.  Can be used to store non boolean data after loading\n		 * is complete (for example arrayBuffers for web audio).\n		 * @property _audioSources\n		 * @type {Object}\n		 * @protected\n		 */\n		this._audioSources = {};\n\n		/**\n		 * Object hash indexed by the source URI of all created SoundInstances, updates the playbackResource if it loads after they are created,\n		 * and properly destroy them if sources are removed\n		 * @type {Object}\n		 * @protected\n		 */\n		this._soundInstances = {};\n\n		/**\n		 * A reference to a loader class used by a plugin that must be set.\n		 * @type {Object}\n		 * @protected\n		 */\n		this._loaderClass;\n\n		/**\n		 * A reference to an AbstractSoundInstance class used by a plugin that must be set.\n		 * @type {Object}\n		 * @protected;\n		 */\n		this._soundInstanceClass;\n	};\n	var p = AbstractPlugin.prototype;\n\n\n// Static Properties:\n// NOTE THESE PROPERTIES NEED TO BE ADDED TO EACH PLUGIN\n	/**\n	 * The capabilities of the plugin. This is generated via the {{#crossLink "WebAudioPlugin/_generateCapabilities:method"}}{{/crossLink}}\n	 * method and is used internally.\n	 * @property _capabilities\n	 * @type {Object}\n	 * @default null\n	 * @protected\n	 * @static\n	 */\n	AbstractPlugin._capabilities = null;\n\n	/**\n	 * Determine if the plugin can be used in the current browser/OS.\n	 * @method isSupported\n	 * @return {Boolean} If the plugin can be initialized.\n	 * @static\n	 */\n	AbstractPlugin.isSupported = function () {\n		return true;\n	};\n\n\n// public methods:\n	/**\n	 * Pre-register a sound for preloading and setup. This is called by {{#crossLink "Sound"}}{{/crossLink}}.\n	 * Note all plugins provide a <code>Loader</code> instance, which <a href="http://preloadjs.com" target="_blank">PreloadJS</a>\n	 * can use to assist with preloading.\n	 * @method register\n	 * @param {String} loadItem An Object containing the source of the audio\n	 * @param {Number} instances The number of concurrently playing instances to allow for the channel at any time.\n	 * Note that not every plugin will manage this value.\n	 * @return {Object} A result object, containing a "tag" for preloading purposes.\n	 */\n	p.register = function (loadItem, instances) {\n		this._audioSources[loadItem.src] = true;\n		this._soundInstances[loadItem.src] = [];\n		if(this._loaders[loadItem.src]) {return this._loaders[loadItem.src];}	// already loading/loaded this, so don\'t load twice\n		// OJR potential issue that we won\'t be firing loaded event, might need to trigger if this is already loaded?\n		var loader = new this._loaderClass(loadItem);\n		loader.on("complete", createjs.proxy(this._handlePreloadComplete, this));\n		this._loaders[loadItem.src] = loader;\n		return loader;\n	};\n\n	// note sound calls register before calling preload\n	/**\n	 * Internally preload a sound.\n	 * @method preload\n	 * @param {Loader} loader The sound URI to load.\n	 */\n	p.preload = function (loader) {\n		loader.on("error", createjs.proxy(this._handlePreloadError, this));\n		loader.load();\n	};\n\n	/**\n	 * Checks if preloading has started for a specific source. If the source is found, we can assume it is loading,\n	 * or has already finished loading.\n	 * @method isPreloadStarted\n	 * @param {String} src The sound URI to check.\n	 * @return {Boolean}\n	 */\n	p.isPreloadStarted = function (src) {\n		return (this._audioSources[src] != null);\n	};\n\n	/**\n	 * Checks if preloading has finished for a specific source.\n	 * @method isPreloadComplete\n	 * @param {String} src The sound URI to load.\n	 * @return {Boolean}\n	 */\n	p.isPreloadComplete = function (src) {\n		return (!(this._audioSources[src] == null || this._audioSources[src] == true));\n	};\n\n	/**\n	 * Remove a sound added using {{#crossLink "WebAudioPlugin/register"}}{{/crossLink}}. Note this does not cancel a preload.\n	 * @method removeSound\n	 * @param {String} src The sound URI to unload.\n	 */\n	p.removeSound = function (src) {\n		if (!this._soundInstances[src]) { return; }\n		for (var i = this._soundInstances[src].length; i--; ) {\n			var item = this._soundInstances[src][i];\n			item.destroy();\n		}\n		delete(this._soundInstances[src]);\n		delete(this._audioSources[src]);\n		if(this._loaders[src]) { this._loaders[src].destroy(); }\n		delete(this._loaders[src]);\n	};\n\n	/**\n	 * Remove all sounds added using {{#crossLink "WebAudioPlugin/register"}}{{/crossLink}}. Note this does not cancel a preload.\n	 * @method removeAllSounds\n	 * @param {String} src The sound URI to unload.\n	 */\n	p.removeAllSounds = function () {\n		for(var key in this._audioSources) {\n			this.removeSound(key);\n		}\n	};\n\n	/**\n	 * Create a sound instance. If the sound has not been preloaded, it is internally preloaded here.\n	 * @method create\n	 * @param {String} src The sound source to use.\n	 * @param {Number} startTime Audio sprite property used to apply an offset, in milliseconds.\n	 * @param {Number} duration Audio sprite property used to set the time the clip plays for, in milliseconds.\n	 * @return {AbstractSoundInstance} A sound instance for playback and control.\n	 */\n	p.create = function (src, startTime, duration) {\n		if (!this.isPreloadStarted(src)) {\n			this.preload(this.register(src));\n		}\n		var si = new this._soundInstanceClass(src, startTime, duration, this._audioSources[src]);\n		this._soundInstances[src].push(si);\n		return si;\n	};\n\n	// TODO Volume & mute Getter / Setter??\n	// TODO change calls to return nothing or this for chaining??\n	// if a plugin does not support volume and mute, it should set these to null\n	/**\n	 * Set the master volume of the plugin, which affects all SoundInstances.\n	 * @method setVolume\n	 * @param {Number} value The volume to set, between 0 and 1.\n	 * @return {Boolean} If the plugin processes the setVolume call (true). The Sound class will affect all the\n	 * instances manually otherwise.\n	 */\n	p.setVolume = function (value) {\n		this._volume = value;\n		this._updateVolume();\n		return true;\n	};\n\n	/**\n	 * Get the master volume of the plugin, which affects all SoundInstances.\n	 * @method getVolume\n	 * @return The volume level, between 0 and 1.\n	 */\n	p.getVolume = function () {\n		return this._volume;\n	};\n\n	/**\n	 * Mute all sounds via the plugin.\n	 * @method setMute\n	 * @param {Boolean} value If all sound should be muted or not. Note that plugin-level muting just looks up\n	 * the mute value of Sound {{#crossLink "Sound/getMute"}}{{/crossLink}}, so this property is not used here.\n	 * @return {Boolean} If the mute call succeeds.\n	 */\n	p.setMute = function (value) {\n		this._updateVolume();\n		return true;\n	};\n\n	// plugins should overwrite this method\n	p.toString = function () {\n		return "[AbstractPlugin]";\n	};\n\n\n// private methods:\n	/**\n	 * Handles internal preload completion.\n	 * @method _handlePreloadComplete\n	 * @protected\n	 */\n	p._handlePreloadComplete = function (event) {\n		var src = event.target.getItem().src;\n		this._audioSources[src] = event.result;\n		for (var i = 0, l = this._soundInstances[src].length; i < l; i++) {\n			var item = this._soundInstances[src][i];\n			item.setPlaybackResource(this._audioSources[src]);\n			// ToDo consider adding play call here if playstate == playfailed\n		}\n	};\n\n	/**\n	 * Handles internal preload erros\n	 * @method _handlePreloadError\n	 * @param event\n	 * @protected\n	 */\n	p._handlePreloadError = function(event) {\n		//delete(this._audioSources[src]);\n	};\n\n	/**\n	 * Set the gain value for master audio. Should not be called externally.\n	 * @method _updateVolume\n	 * @protected\n	 */\n	p._updateVolume = function () {\n		// Plugin Specific code\n	};\n\n	createjs.AbstractPlugin = AbstractPlugin;\n}());\n\n//##############################################################################\n// WebAudioLoader.js\n//##############################################################################\n\nthis.createjs = this.createjs || {};\n\n(function () {\n	"use strict";\n\n	/**\n	 * Loader provides a mechanism to preload Web Audio content via PreloadJS or internally. Instances are returned to\n	 * the preloader, and the load method is called when the asset needs to be requested.\n	 *\n	 * @class WebAudioLoader\n	 * @param {String} loadItem The item to be loaded\n	 * @param {Object} flash The flash instance that will do the preloading.\n	 * @extends XHRRequest\n	 * @protected\n	 */\n	function Loader(loadItem) {\n		this.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.SOUND);\n\n	};\n	var p = createjs.extend(Loader, createjs.AbstractLoader);\n\n	/**\n	 * web audio context required for decoding audio\n	 * @property context\n	 * @type {AudioContext}\n	 * @static\n	 */\n	Loader.context = null;\n\n\n// public methods\n	p.toString = function () {\n		return "[WebAudioLoader]";\n	};\n\n\n// private methods\n	p._createRequest = function() {\n		this._request = new createjs.XHRRequest(this._item, false);\n		this._request.setResponseType("arraybuffer");\n	};\n\n	p._sendComplete = function (event) {\n		// OJR we leave this wrapped in Loader because we need to reference src and the handler only receives a single argument, the decodedAudio\n		Loader.context.decodeAudioData(this._rawResult,\n	         createjs.proxy(this._handleAudioDecoded, this),\n	         createjs.proxy(this._handleError, this));\n	};\n\n\n	/**\n	* The audio has been decoded.\n	* @method handleAudioDecoded\n	 * @param decoded\n	* @protected\n	*/\n	p._handleAudioDecoded = function (decodedAudio) {\n		this._result = decodedAudio;\n		this.AbstractLoader__sendComplete();\n	};\n\n	createjs.WebAudioLoader = createjs.promote(Loader, "AbstractLoader");\n}());\n\n//##############################################################################\n// WebAudioSoundInstance.js\n//##############################################################################\n\nthis.createjs = this.createjs || {};\n\n/**\n * WebAudioSoundInstance extends the base api of {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} and is used by\n * {{#crossLink "WebAudioPlugin"}}{{/crossLink}}.\n *\n * WebAudioSoundInstance exposes audioNodes for advanced users.\n *\n * @param {String} src The path to and file name of the sound.\n * @param {Number} startTime Audio sprite property used to apply an offset, in milliseconds.\n * @param {Number} duration Audio sprite property used to set the time the clip plays for, in milliseconds.\n * @param {Object} playbackResource Any resource needed by plugin to support audio playback.\n * @class WebAudioSoundInstance\n * @extends AbstractSoundInstance\n * @constructor\n */\n(function () {\n	"use strict";\n\n	function WebAudioSoundInstance(src, startTime, duration, playbackResource) {\n		this.AbstractSoundInstance_constructor(src, startTime, duration, playbackResource);\n\n\n// public properties\n		/**\n		 * NOTE this is only intended for use by advanced users.\n		 * <br />GainNode for controlling <code>WebAudioSoundInstance</code> volume. Connected to the {{#crossLink "WebAudioSoundInstance/destinationNode:property"}}{{/crossLink}}.\n		 * @property gainNode\n		 * @type {AudioGainNode}\n		 * @since 0.4.0\n		 *\n		 */\n		this.gainNode = s.context.createGain();\n\n		/**\n		 * NOTE this is only intended for use by advanced users.\n		 * <br />A panNode allowing left and right audio channel panning only. Connected to WebAudioSoundInstance {{#crossLink "WebAudioSoundInstance/gainNode:property"}}{{/crossLink}}.\n		 * @property panNode\n		 * @type {AudioPannerNode}\n		 * @since 0.4.0\n		 */\n		this.panNode = s.context.createPanner();\n		this.panNode.panningModel = s._panningModel;\n		this.panNode.connect(this.gainNode);\n\n		/**\n		 * NOTE this is only intended for use by advanced users.\n		 * <br />sourceNode is the audio source. Connected to WebAudioSoundInstance {{#crossLink "WebAudioSoundInstance/panNode:property"}}{{/crossLink}}.\n		 * @property sourceNode\n		 * @type {AudioNode}\n		 * @since 0.4.0\n		 *\n		 */\n		this.sourceNode = null;\n\n\n// private properties\n		/**\n		 * Timeout that is created internally to handle sound playing to completion.\n		 * Stored so we can remove it when stop, pause, or cleanup are called\n		 * @property _soundCompleteTimeout\n		 * @type {timeoutVariable}\n		 * @default null\n		 * @protected\n		 * @since 0.4.0\n		 */\n		this._soundCompleteTimeout = null;\n\n		/**\n		 * NOTE this is only intended for use by very advanced users.\n		 * _sourceNodeNext is the audio source for the next loop, inserted in a look ahead approach to allow for smooth\n		 * looping. Connected to {{#crossLink "WebAudioSoundInstance/gainNode:property"}}{{/crossLink}}.\n		 * @property _sourceNodeNext\n		 * @type {AudioNode}\n		 * @default null\n		 * @protected\n		 * @since 0.4.1\n		 *\n		 */\n		this._sourceNodeNext = null;\n\n		/**\n		 * Time audio started playback, in seconds. Used to handle set position, get position, and resuming from paused.\n		 * @property _playbackStartTime\n		 * @type {Number}\n		 * @default 0\n		 * @protected\n		 * @since 0.4.0\n		 */\n		this._playbackStartTime = 0;\n\n		// Proxies, make removing listeners easier.\n		this._endedHandler = createjs.proxy(this._handleSoundComplete, this);\n	};\n	var p = createjs.extend(WebAudioSoundInstance, createjs.AbstractSoundInstance);\n	var s = WebAudioSoundInstance;\n\n	/**\n	 * Note this is only intended for use by advanced users.\n	 * <br />Audio context used to create nodes.  This is and needs to be the same context used by {{#crossLink "WebAudioPlugin"}}{{/crossLink}}.\n  	 * @property context\n	 * @type {AudioContext}\n	 * @static\n	 * @since 0.6.0\n	 */\n	s.context = null;\n\n	/**\n	 * Note this is only intended for use by advanced users.\n	 * <br /> Audio node from WebAudioPlugin that sequences to <code>context.destination</code>\n	 * @property destinationNode\n	 * @type {AudioNode}\n	 * @static\n	 * @since 0.6.0\n	 */\n	s.destinationNode = null;\n\n	/**\n	 * Value to set panning model to equal power for WebAudioSoundInstance.  Can be "equalpower" or 0 depending on browser implementation.\n	 * @property _panningModel\n	 * @type {Number / String}\n	 * @protected\n	 * @static\n	 * @since 0.6.0\n	 */\n	s._panningModel = "equalpower";\n\n\n// Public methods\n	p.destroy = function() {\n		this.AbstractSoundInstance_destroy();\n\n		this.panNode.disconnect(0);\n		this.panNode = null;\n		this.gainNode.disconnect(0);\n		this.gainNode = null;\n	};\n\n	p.toString = function () {\n		return "[WebAudioSoundInstance]";\n	};\n\n\n// Private Methods\n	p._updatePan = function() {\n		this.panNode.setPosition(this._pan, 0, -0.5);\n		// z need to be -0.5 otherwise the sound only plays in left, right, or center\n	};\n\n	p._removeLooping = function() {\n		this._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext);\n	};\n\n	p._addLooping = function() {\n		if (this.playState != createjs.Sound.PLAY_SUCCEEDED) { return; }\n		this._sourceNodeNext = this._createAndPlayAudioNode(this._playbackStartTime, 0);\n	};\n\n	p._setDurationFromSource = function () {\n		this._duration = this.playbackResource.duration * 1000;\n	};\n\n	p._handleCleanUp = function () {\n		if (this.sourceNode && this.playState == createjs.Sound.PLAY_SUCCEEDED) {\n			this.sourceNode = this._cleanUpAudioNode(this.sourceNode);\n			this._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext);\n		}\n\n		if (this.gainNode.numberOfOutputs != 0) {this.gainNode.disconnect(0);}\n		// OJR there appears to be a bug that this doesn\'t always work in webkit (Chrome and Safari). According to the documentation, this should work.\n\n		clearTimeout(this._soundCompleteTimeout);\n\n		this._playbackStartTime = 0;	// This is used by getPosition\n	};\n\n	/**\n	 * Turn off and disconnect an audioNode, then set reference to null to release it for garbage collection\n	 * @method _cleanUpAudioNode\n	 * @param audioNode\n	 * @return {audioNode}\n	 * @protected\n	 * @since 0.4.1\n	 */\n	p._cleanUpAudioNode = function(audioNode) {\n		if(audioNode) {\n			audioNode.stop(0);\n			audioNode.disconnect(0);\n			audioNode = null;\n		}\n		return audioNode;\n	};\n\n	p._handleSoundReady = function (event) {\n		this.gainNode.connect(s.destinationNode);  // this line can cause a memory leak.  Nodes need to be disconnected from the audioDestination or any sequence that leads to it.\n\n		var dur = this._duration * 0.001;\n		var pos = this._position * 0.001;\n		this.sourceNode = this._createAndPlayAudioNode((s.context.currentTime - dur), pos);\n		this._playbackStartTime = this.sourceNode.startTime - pos;\n\n		this._soundCompleteTimeout = setTimeout(this._endedHandler, (dur - pos) * 1000);\n\n		if(this._loop != 0) {\n			this._sourceNodeNext = this._createAndPlayAudioNode(this._playbackStartTime, 0);\n		}\n	};\n\n	/**\n	 * Creates an audio node using the current src and context, connects it to the gain node, and starts playback.\n	 * @method _createAndPlayAudioNode\n	 * @param {Number} startTime The time to add this to the web audio context, in seconds.\n	 * @param {Number} offset The amount of time into the src audio to start playback, in seconds.\n	 * @return {audioNode}\n	 * @protected\n	 * @since 0.4.1\n	 */\n	p._createAndPlayAudioNode = function(startTime, offset) {\n		var audioNode = s.context.createBufferSource();\n		audioNode.buffer = this.playbackResource;\n		audioNode.connect(this.panNode);\n		var dur = this._duration * 0.001;\n		audioNode.startTime = startTime + dur;\n		audioNode.start(audioNode.startTime, offset+(this._startTime*0.001), dur - offset);\n		return audioNode;\n	};\n\n	p._pause = function () {\n		this._position = (s.context.currentTime - this._playbackStartTime) * 1000;  // * 1000 to give milliseconds, lets us restart at same point\n		this.sourceNode = this._cleanUpAudioNode(this.sourceNode);\n		this._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext);\n\n		if (this.gainNode.numberOfOutputs != 0) {this.gainNode.disconnect(0);}\n\n		clearTimeout(this._soundCompleteTimeout);\n	};\n\n	p._resume = function () {\n		this._handleSoundReady();\n	};\n\n	/*\n	p._handleStop = function () {\n		// web audio does not need to do anything extra\n	};\n	*/\n\n	p._updateVolume = function () {\n		var newVolume = this._muted ? 0 : this._volume;\n	  	if (newVolume != this.gainNode.gain.value) {\n		  this.gainNode.gain.value = newVolume;\n  		}\n	};\n\n	p._calculateCurrentPosition = function () {\n		return ((s.context.currentTime - this._playbackStartTime) * 1000); // pos in seconds * 1000 to give milliseconds\n	};\n\n	p._updatePosition = function () {\n		this.sourceNode = this._cleanUpAudioNode(this.sourceNode);\n		this._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext);\n		clearTimeout(this._soundCompleteTimeout);\n\n		if (!this._paused) {this._handleSoundReady();}\n	};\n\n	// OJR we are using a look ahead approach to ensure smooth looping.\n	// We add _sourceNodeNext to the audio context so that it starts playing even if this callback is delayed.\n	// This technique is described here:  http://www.html5rocks.com/en/tutorials/audio/scheduling/\n	// NOTE the cost of this is that our audio loop may not always match the loop event timing precisely.\n	p._handleLoop = function () {\n		this._cleanUpAudioNode(this.sourceNode);\n		this.sourceNode = this._sourceNodeNext;\n		this._playbackStartTime = this.sourceNode.startTime;\n		this._sourceNodeNext = this._createAndPlayAudioNode(this._playbackStartTime, 0);\n		this._soundCompleteTimeout = setTimeout(this._endedHandler, this._duration);\n	};\n\n	p._updateDuration = function () {\n		this._pause();\n		this._resume();\n	};\n\n	createjs.WebAudioSoundInstance = createjs.promote(WebAudioSoundInstance, "AbstractSoundInstance");\n}());\n\n//##############################################################################\n// WebAudioPlugin.js\n//##############################################################################\n\nthis.createjs = this.createjs || {};\n\n(function () {\n\n	"use strict";\n\n	/**\n	 * Play sounds using Web Audio in the browser. The WebAudioPlugin is currently the default plugin, and will be used\n	 * anywhere that it is supported. To change plugin priority, check out the Sound API\n	 * {{#crossLink "Sound/registerPlugins"}}{{/crossLink}} method.\n\n	 * <h4>Known Browser and OS issues for Web Audio</h4>\n	 * <b>Firefox 25</b>\n	 * <ul><li>mp3 audio files do not load properly on all windows machines, reported\n	 * <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=929969" target="_blank">here</a>. </br>\n	 * For this reason it is recommended to pass another FF supported type (ie ogg) first until this bug is resolved, if possible.</li></ul>\n	 * <br />\n	 * <b>Webkit (Chrome and Safari)</b>\n	 * <ul><li>AudioNode.disconnect does not always seem to work.  This can cause the file size to grow over time if you\n	 * are playing a lot of audio files.</li></ul>\n	 * <br />\n	 * <b>iOS 6 limitations</b>\n	 * 	<ul><li>Sound is initially muted and will only unmute through play being called inside a user initiated event (touch/click).</li>\n	 *	<li>A bug exists that will distort uncached audio when a video element is present in the DOM.  You can avoid this bug\n	 * 	by ensuring the audio and video audio share the same sampleRate.</li>\n	 * </ul>\n	 * @class WebAudioPlugin\n	 * @extends AbstractPlugin\n	 * @constructor\n	 * @since 0.4.0\n	 */\n	function WebAudioPlugin() {\n		this.AbstractPlugin_constructor();\n\n\n// Private Properties\n		/**\n		 * Value to set panning model to equal power for WebAudioSoundInstance.  Can be "equalpower" or 0 depending on browser implementation.\n		 * @property _panningModel\n		 * @type {Number / String}\n		 * @protected\n		 */\n		this._panningModel = s._panningModel;;\n\n		/**\n		 * The internal master volume value of the plugin.\n		 * @property _volume\n		 * @type {Number}\n		 * @default 1\n		 * @protected\n		 */\n		this._volume = 1;\n\n		/**\n		 * The web audio context, which WebAudio uses to play audio. All nodes that interact with the WebAudioPlugin\n		 * need to be created within this context.\n		 * @property context\n		 * @type {AudioContext}\n		 */\n		this.context = s.context;\n\n		/**\n		 * A DynamicsCompressorNode, which is used to improve sound quality and prevent audio distortion.\n		 * It is connected to <code>context.destination</code>.\n		 *\n		 * Can be accessed by advanced users through createjs.Sound.activePlugin.dynamicsCompressorNode.\n		 * @property dynamicsCompressorNode\n		 * @type {AudioNode}\n		 */\n		this.dynamicsCompressorNode = this.context.createDynamicsCompressor();\n		this.dynamicsCompressorNode.connect(this.context.destination);\n\n		/**\n		 * A GainNode for controlling master volume. It is connected to {{#crossLink "WebAudioPlugin/dynamicsCompressorNode:property"}}{{/crossLink}}.\n		 *\n		 * Can be accessed by advanced users through createjs.Sound.activePlugin.gainNode.\n		 * @property gainNode\n		 * @type {AudioGainNode}\n		 */\n		this.gainNode = this.context.createGain();\n		this.gainNode.connect(this.dynamicsCompressorNode);\n		createjs.WebAudioSoundInstance.destinationNode = this.gainNode;\n\n		this._capabilities = s._capabilities;\n\n		this._loaderClass = createjs.WebAudioLoader;\n		this._soundInstanceClass = createjs.WebAudioSoundInstance;\n\n		this._addPropsToClasses();\n	}\n	var p = createjs.extend(WebAudioPlugin, createjs.AbstractPlugin);\n\n\n// Static Properties\n	var s = WebAudioPlugin;\n	/**\n	 * The capabilities of the plugin. This is generated via the {{#crossLink "WebAudioPlugin/_generateCapabilities:method"}}{{/crossLink}}\n	 * method and is used internally.\n	 * @property _capabilities\n	 * @type {Object}\n	 * @default null\n	 * @protected\n	 * @static\n	 */\n	s._capabilities = null;\n\n	/**\n	 * Value to set panning model to equal power for WebAudioSoundInstance.  Can be "equalpower" or 0 depending on browser implementation.\n	 * @property _panningModel\n	 * @type {Number / String}\n	 * @protected\n	 * @static\n	 */\n	s._panningModel = "equalpower";\n\n	/**\n	 * The web audio context, which WebAudio uses to play audio. All nodes that interact with the WebAudioPlugin\n	 * need to be created within this context.\n	 *\n	 * Advanced users can set this to an existing context, but <b>must</b> do so before they call\n	 * {{#crossLink "Sound/registerPlugins"}}{{/crossLink}} or {{#crossLink "Sound/initializeDefaultPlugins"}}{{/crossLink}}.\n	 *\n	 * @property context\n	 * @type {AudioContext}\n	 * @static\n	 */\n	s.context = null;\n\n\n// Static Public Methods\n	/**\n	 * Determine if the plugin can be used in the current browser/OS.\n	 * @method isSupported\n	 * @return {Boolean} If the plugin can be initialized.\n	 * @static\n	 */\n	s.isSupported = function () {\n		// check if this is some kind of mobile device, Web Audio works with local protocol under PhoneGap and it is unlikely someone is trying to run a local file\n		var isMobilePhoneGap = createjs.BrowserDetect.isIOS || createjs.BrowserDetect.isAndroid || createjs.BrowserDetect.isBlackberry;\n		// OJR isMobile may be redundant with _isFileXHRSupported available.  Consider removing.\n		if (location.protocol == "file:" && !isMobilePhoneGap && !this._isFileXHRSupported()) { return false; }  // Web Audio requires XHR, which is not usually available locally\n		s._generateCapabilities();\n		if (s.context == null) {return false;}\n		return true;\n	};\n\n	/**\n	 * Plays an empty sound in the web audio context.  This is used to enable web audio on iOS devices, as they\n	 * require the first sound to be played inside of a user initiated event (touch/click).  This is called when\n	 * {{#crossLink "WebAudioPlugin"}}{{/crossLink}} is initialized (by Sound {{#crossLink "Sound/initializeDefaultPlugins"}}{{/crossLink}}\n	 * for example).\n	 *\n	 * <h4>Example</h4>\n	 *\n	 *     function handleTouch(event) {\n	 *         createjs.WebAudioPlugin.playEmptySound();\n	 *     }\n	 *\n	 * @method playEmptySound\n	 * @static\n	 * @since 0.4.1\n	 */\n	s.playEmptySound = function() {\n		var source = s.context.createBufferSource();\n		source.buffer = s.context.createBuffer(1, 1, 22050);\n		source.connect(s.context.destination);\n		source.start(0, 0, 0);\n	};\n\n\n// Static Private Methods\n	/**\n	 * Determine if XHR is supported, which is necessary for web audio.\n	 * @method _isFileXHRSupported\n	 * @return {Boolean} If XHR is supported.\n	 * @since 0.4.2\n	 * @protected\n	 * @static\n	 */\n	s._isFileXHRSupported = function() {\n		// it\'s much easier to detect when something goes wrong, so let\'s start optimistically\n		var supported = true;\n\n		var xhr = new XMLHttpRequest();\n		try {\n			xhr.open("GET", "WebAudioPluginTest.fail", false); // loading non-existant file triggers 404 only if it could load (synchronous call)\n		} catch (error) {\n			// catch errors in cases where the onerror is passed by\n			supported = false;\n			return supported;\n		}\n		xhr.onerror = function() { supported = false; }; // cause irrelevant\n		// with security turned off, we can get empty success results, which is actually a failed read (status code 0?)\n		xhr.onload = function() { supported = this.status == 404 || (this.status == 200 || (this.status == 0 && this.response != "")); };\n		try {\n			xhr.send();\n		} catch (error) {\n			// catch errors in cases where the onerror is passed by\n			supported = false;\n		}\n\n		return supported;\n	};\n\n	/**\n	 * Determine the capabilities of the plugin. Used internally. Please see the Sound API {{#crossLink "Sound/getCapabilities"}}{{/crossLink}}\n	 * method for an overview of plugin capabilities.\n	 * @method _generateCapabilities\n	 * @static\n	 * @protected\n	 */\n	s._generateCapabilities = function () {\n		if (s._capabilities != null) {return;}\n		// Web Audio can be in any formats supported by the audio element, from http://www.w3.org/TR/webaudio/#AudioContext-section\n		var t = document.createElement("audio");\n		if (t.canPlayType == null) {return null;}\n\n		if (s.context == null) {\n			if (window.AudioContext) {\n				s.context = new AudioContext();\n			} else if (window.webkitAudioContext) {\n				s.context = new webkitAudioContext();\n			} else {\n				return null;\n			}\n		}\n\n		s._compatibilitySetUp();\n\n		// playing this inside of a touch event will enable audio on iOS, which starts muted\n		s.playEmptySound();\n\n		s._capabilities = {\n			panning:true,\n			volume:true,\n			tracks:-1\n		};\n\n		// determine which extensions our browser supports for this plugin by iterating through Sound.SUPPORTED_EXTENSIONS\n		var supportedExtensions = createjs.Sound.SUPPORTED_EXTENSIONS;\n		var extensionMap = createjs.Sound.EXTENSION_MAP;\n		for (var i = 0, l = supportedExtensions.length; i < l; i++) {\n			var ext = supportedExtensions[i];\n			var playType = extensionMap[ext] || ext;\n			s._capabilities[ext] = (t.canPlayType("audio/" + ext) != "no" && t.canPlayType("audio/" + ext) != "") || (t.canPlayType("audio/" + playType) != "no" && t.canPlayType("audio/" + playType) != "");\n		}  // OJR another way to do this might be canPlayType:"m4a", codex: mp4\n\n		// 0=no output, 1=mono, 2=stereo, 4=surround, 6=5.1 surround.\n		// See http://www.w3.org/TR/webaudio/#AudioChannelSplitter for more details on channels.\n		if (s.context.destination.numberOfChannels < 2) {\n			s._capabilities.panning = false;\n		}\n	};\n\n	/**\n	 * Set up compatibility if only deprecated web audio calls are supported.\n	 * See http://www.w3.org/TR/webaudio/#DeprecationNotes\n	 * Needed so we can support new browsers that don\'t support deprecated calls (Firefox) as well as old browsers that\n	 * don\'t support new calls.\n	 *\n	 * @method _compatibilitySetUp\n	 * @static\n	 * @protected\n	 * @since 0.4.2\n	 */\n	s._compatibilitySetUp = function() {\n		s._panningModel = "equalpower";\n		//assume that if one new call is supported, they all are\n		if (s.context.createGain) { return; }\n\n		// simple name change, functionality the same\n		s.context.createGain = s.context.createGainNode;\n\n		// source node, add to prototype\n		var audioNode = s.context.createBufferSource();\n		audioNode.__proto__.start = audioNode.__proto__.noteGrainOn;	// note that noteGrainOn requires all 3 parameters\n		audioNode.__proto__.stop = audioNode.__proto__.noteOff;\n\n		// panningModel\n		s._panningModel = 0;\n	};\n\n\n// Public Methods\n	p.toString = function () {\n		return "[WebAudioPlugin]";\n	};\n\n\n// Private Methods\n	/**\n	 * Set up needed properties on supported classes WebAudioSoundInstance and WebAudioLoader.\n	 * @method _addPropsToClasses\n	 * @static\n	 * @protected\n	 * @since 0.6.0\n	 */\n	p._addPropsToClasses = function() {\n		var c = this._soundInstanceClass;\n		c.context = this.context;\n		c.destinationNode = this.gainNode;\n		c._panningModel = this._panningModel;\n\n		this._loaderClass.context = this.context;\n	};\n\n\n	/**\n	 * Set the gain value for master audio. Should not be called externally.\n	 * @method _updateVolume\n	 * @protected\n	 */\n	p._updateVolume = function () {\n		var newVolume = createjs.Sound._masterMute ? 0 : this._volume;\n		if (newVolume != this.gainNode.gain.value) {\n			this.gainNode.gain.value = newVolume;\n		}\n	};\n\n	createjs.WebAudioPlugin = createjs.promote(WebAudioPlugin, "AbstractPlugin");\n}());\n\n//##############################################################################\n// HTMLAudioTagPool.js\n//##############################################################################\n\nthis.createjs = this.createjs || {};\n\n//TODO verify that tags no longer need to be precreated (mac and pc)\n//TODO modify this now that tags do not need to be precreated\n(function () {\n	"use strict";\n\n	/**\n	 * The TagPool is an object pool for HTMLAudio tag instances. In Chrome, we have to pre-create the number of HTML\n	 * audio tag instances that we are going to play before we load the data, otherwise the audio stalls.\n	 * (Note: This seems to be a bug in Chrome)\n	 * @class HTMLAudioTagPool\n	 * @param {String} src The source of the channel.\n	 * @protected\n	 */\n	function TagPool(src) {\n\n\n//Public Properties\n		/**\n		 * The source of the tag pool.\n		 * #property src\n		 * @type {String}\n		 * @protected\n		 */\n		this.src = src;\n\n		/**\n		 * The total number of HTMLAudio tags in this pool. This is the maximum number of instance of a certain sound\n		 * that can play at one time.\n		 * #property length\n		 * @type {Number}\n		 * @default 0\n		 * @protected\n		 */\n		this.length = 0;\n\n		/**\n		 * The number of unused HTMLAudio tags.\n		 * #property available\n		 * @type {Number}\n		 * @default 0\n		 * @protected\n		 */\n		this.available = 0;\n\n		/**\n		 * A list of all available tags in the pool.\n		 * #property tags\n		 * @type {Array}\n		 * @protected\n		 */\n		this.tags = [];\n\n		/**\n		 * The duration property of all audio tags, converted to milliseconds, which originally is only available on the\n		 * last tag in the tags array because that is the one that is loaded.\n		 * #property\n		 * @type {Number}\n		 * @protected\n		 */\n		this.duration = 0;\n	};\n\n	var p = TagPool.prototype;\n	p.constructor = TagPool;\n	var s = TagPool;\n\n\n// Static Properties\n	/**\n	 * A hash lookup of each sound channel, indexed by the audio source.\n	 * #property tags\n	 * @static\n	 * @protected\n	 */\n	s.tags = {};\n\n\n// Static Methods\n	/**\n	 * Get a tag pool. If the pool doesn\'t exist, create it.\n	 * #method get\n	 * @param {String} src The source file used by the audio tag.\n	 * @static\n	 * @protected\n	 */\n	s.get = function (src) {\n		var channel = s.tags[src];\n		if (channel == null) {\n			channel = s.tags[src] = new TagPool(src);\n		}\n		return channel;\n	};\n\n	/**\n	 * Delete a TagPool and all related tags. Note that if the TagPool does not exist, this will fail.\n	 * #method remove\n	 * @param {String} src The source for the tag\n	 * @return {Boolean} If the TagPool was deleted.\n	 * @static\n	 */\n	s.remove = function (src) {\n		var channel = s.tags[src];\n		if (channel == null) {return false;}\n		channel.removeAll();\n		delete(s.tags[src]);\n		return true;\n	};\n\n	/**\n	 * Get a tag instance. This is a shortcut method.\n	 * #method getInstance\n	 * @param {String} src The source file used by the audio tag.\n	 * @static\n	 * @protected\n	 */\n	s.getInstance = function (src) {\n		var channel = s.tags[src];\n		if (channel == null) {return null;}\n		return channel.get();\n	};\n\n	/**\n	 * Return a tag instance. This is a shortcut method.\n	 * #method setInstance\n	 * @param {String} src The source file used by the audio tag.\n	 * @param {HTMLElement} tag Audio tag to set.\n	 * @static\n	 * @protected\n	 */\n	s.setInstance = function (src, tag) {\n		var channel = s.tags[src];\n		if (channel == null) {return null;}\n		return channel.set(tag);\n	};\n\n	/**\n	 * Gets the duration of the src audio in milliseconds\n	 * #method getDuration\n	 * @param {String} src The source file used by the audio tag.\n	 * @return {Number} Duration of src in milliseconds\n	 */\n	s.getDuration= function (src) {\n		var channel = s.tags[src];\n		if (channel == null) {return 0;}\n		return channel.getDuration();\n	};\n\n\n// Public Methods\n	/**\n	 * Add an HTMLAudio tag into the pool.\n	 * #method add\n	 * @param {HTMLAudioElement} tag A tag to be used for playback.\n	 */\n	p.add = function (tag) {\n		this.tags.push(tag);\n		this.length++;\n		this.available++;\n	};\n\n	/**\n	 * Remove all tags from the channel.  Usually in response to a delete call.\n	 * #method removeAll\n	 */\n	p.removeAll = function () {\n		var tag;\n		while(this.length--) {\n			tag = this.tags[this.length];\n			if(tag.parentNode) {\n				tag.parentNode.removeChild(tag);\n			}\n			delete(this.tags[this.length]);	// NOTE that the audio playback is already stopped by this point\n		}\n		this.src = null;\n		this.tags.length = 0;\n	};\n\n	/**\n	 * Get an HTMLAudioElement for immediate playback. This takes it out of the pool.\n	 * #method get\n	 * @return {HTMLAudioElement} An HTML audio tag.\n	 */\n	p.get = function () {\n		if (this.tags.length == 0) {return null;}\n		this.available = this.tags.length;\n		var tag = this.tags.pop();\n		if (tag.parentNode == null) {document.body.appendChild(tag);}\n		return tag;\n	};\n\n	/**\n	 * Put an HTMLAudioElement back in the pool for use.\n	 * #method set\n	 * @param {HTMLAudioElement} tag HTML audio tag\n	 */\n	p.set = function (tag) {\n		var index = createjs.indexOf(this.tags, tag);\n		if (index == -1) {this.tags.push(tag);}\n		this.available = this.tags.length;\n	};\n\n	/**\n	 * Gets the duration for the src audio and on first call stores it to this.duration\n	 * #method getDuration\n	 * @return {Number} Duration of the src in milliseconds\n	 */\n	p.getDuration = function () {\n		// this will work because this will be only be run the first time a sound instance is created and before any tags are taken from the pool\n		if (!this.duration) {this.duration = this.tags[this.tags.length - 1].duration * 1000;}\n		return this.duration;\n	};\n\n	p.toString = function () {\n		return "[HTMLAudioTagPool]";\n	};\n\n	createjs.HTMLAudioTagPool = TagPool;\n}());\n\n//##############################################################################\n// HTMLAudioSoundInstance.js\n//##############################################################################\n\nthis.createjs = this.createjs || {};\n\n(function () {\n	"use strict";\n\n	/**\n	 * HTMLAudioSoundInstance extends the base api of {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} and is used by\n	 * {{#crossLink "HTMLAudioPlugin"}}{{/crossLink}}.\n	 *\n	 * @param {String} src The path to and file name of the sound.\n	 * @param {Number} startTime Audio sprite property used to apply an offset, in milliseconds.\n	 * @param {Number} duration Audio sprite property used to set the time the clip plays for, in milliseconds.\n	 * @param {Object} playbackResource Any resource needed by plugin to support audio playback.\n	 * @class HTMLAudioSoundInstance\n	 * @extends AbstractSoundInstance\n	 * @constructor\n	 */\n	function HTMLAudioSoundInstance(src, startTime, duration, playbackResource) {\n		this.AbstractSoundInstance_constructor(src, startTime, duration, playbackResource);\n\n\n// Private Properties\n		this._audioSpriteStopTime = null;\n		this._delayTimeoutId = null;\n\n		// Proxies, make removing listeners easier.\n		this._endedHandler = createjs.proxy(this._handleSoundComplete, this);\n		this._readyHandler = createjs.proxy(this._handleTagReady, this);\n		this._stalledHandler = createjs.proxy(this.playFailed, this);\n		this._audioSpriteEndHandler = createjs.proxy(this._handleAudioSpriteLoop, this);\n		this._loopHandler = createjs.proxy(this._handleSoundComplete, this);\n\n		if (duration) {\n			this._audioSpriteStopTime = (startTime + duration) * 0.001;\n		} else {\n			this._duration = createjs.HTMLAudioTagPool.getDuration(this.src);\n		}\n	}\n	var p = createjs.extend(HTMLAudioSoundInstance, createjs.AbstractSoundInstance);\n\n\n// Public Methods\n	/**\n	 * Called by {{#crossLink "Sound"}}{{/crossLink}} when plugin does not handle master volume.\n	 * undoc\'d because it is not meant to be used outside of Sound\n	 * #method setMasterVolume\n	 * @param value\n	 */\n	p.setMasterVolume = function (value) {\n		this._updateVolume();\n	};\n\n	/**\n	 * Called by {{#crossLink "Sound"}}{{/crossLink}} when plugin does not handle master mute.\n	 * undoc\'d because it is not meant to be used outside of Sound\n	 * #method setMasterMute\n	 * @param value\n	 */\n	p.setMasterMute = function (isMuted) {\n		this._updateVolume();\n	};\n\n	p.toString = function () {\n		return "[HTMLAudioSoundInstance]";\n	};\n\n//Private Methods\n	p._removeLooping = function() {\n		if(this._playbackResource == null) {return;}\n		this._playbackResource.loop = false;\n		this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\n	};\n\n	p._addLooping = function() {\n		if(this._playbackResource == null  || this._audioSpriteStopTime) {return;}\n		this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\n		this._playbackResource.loop = true;\n	};\n\n	p._handleCleanUp = function () {\n		var tag = this._playbackResource;\n		if (tag != null) {\n			tag.pause();\n			tag.loop = false;\n			tag.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED, this._endedHandler, false);\n			tag.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_READY, this._readyHandler, false);\n			tag.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_STALLED, this._stalledHandler, false);\n			tag.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\n			tag.removeEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE, this._audioSpriteEndHandler, false);\n\n			try {\n				tag.currentTime = this._startTime;\n			} catch (e) {\n			} // Reset Position\n			createjs.HTMLAudioTagPool.setInstance(this.src, tag);\n			this._playbackResource = null;\n		}\n	};\n\n	p._beginPlaying = function (offset, loop, volume, pan) {\n		this._playbackResource = createjs.HTMLAudioTagPool.getInstance(this.src);\n		return this.AbstractSoundInstance__beginPlaying(offset, loop, volume, pan);\n	};\n\n	p._handleSoundReady = function (event) {\n		if (this._playbackResource.readyState !== 4) {\n			var tag = this._playbackResource;\n			tag.addEventListener(createjs.HTMLAudioPlugin._AUDIO_READY, this._readyHandler, false);\n			tag.addEventListener(createjs.HTMLAudioPlugin._AUDIO_STALLED, this._stalledHandler, false);\n			tag.preload = "auto"; // This is necessary for Firefox, as it won\'t ever "load" until this is set.\n			tag.load();\n			return;\n		}\n\n		this._updateVolume();\n		this._playbackResource.currentTime = (this._startTime + this._position) * 0.001;\n		if (this._audioSpriteStopTime) {\n			this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE, this._audioSpriteEndHandler, false);\n		} else {\n			this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED, this._endedHandler, false);\n			if(this._loop != 0) {\n				this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\n				this._playbackResource.loop = true;\n			}\n		}\n\n		this._playbackResource.play();\n	};\n\n	/**\n	 * Used to handle when a tag is not ready for immediate playback when it is returned from the HTMLAudioTagPool.\n	 * @method _handleTagReady\n	 * @param event\n	 * @protected\n	 */\n	p._handleTagReady = function (event) {\n		this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_READY, this._readyHandler, false);\n		this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_STALLED, this._stalledHandler, false);\n\n		this._handleSoundReady();\n	};\n\n	p._pause = function () {\n		this._playbackResource.pause();\n	};\n\n	p._resume = function () {\n		this._playbackResource.play();\n	};\n\n	p._updateVolume = function () {\n		if (this._playbackResource != null) {\n			var newVolume = (this._muted || createjs.Sound._masterMute) ? 0 : this._volume * createjs.Sound._masterVolume;\n			if (newVolume != this._playbackResource.volume) {this._playbackResource.volume = newVolume;}\n		}\n	};\n\n	p._calculateCurrentPosition = function() {\n		return (this._playbackResource.currentTime * 1000) - this._startTime;\n	};\n\n	p._updatePosition = function() {\n		this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\n		this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._handleSetPositionSeek, false);\n		try {\n			this._playbackResource.currentTime = (this._position + this._startTime) * 0.001;\n		} catch (error) { // Out of range\n			this._handleSetPositionSeek(null);\n		}\n	};\n\n	/**\n	 * Used to enable setting position, as we need to wait for that seek to be done before we add back our loop handling seek listener\n	 * @method _handleSetPositionSeek\n	 * @param event\n	 * @protected\n	 */\n	p._handleSetPositionSeek = function(event) {\n		if (this._playbackResource == null) { return; }\n		this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._handleSetPositionSeek, false);\n		this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\n	};\n\n	/**\n	 * Timer used to loop audio sprites.\n	 * NOTE because of the inaccuracies in the timeupdate event (15 - 250ms) and in setting the tag to the desired timed\n	 * (up to 300ms), it is strongly recommended not to loop audio sprites with HTML Audio if smooth looping is desired\n	 *\n	 * @method _handleAudioSpriteLoop\n	 * @param event\n	 * @private\n	 */\n	p._handleAudioSpriteLoop = function (event) {\n		if(this._playbackResource.currentTime <= this._audioSpriteStopTime) {return;}\n		this._playbackResource.pause();\n		if(this._loop == 0) {\n			this._handleSoundComplete(null);\n		} else {\n			this._position = 0;\n			this._loop--;\n			this._playbackResource.currentTime = this._startTime * 0.001;\n			if(!this._paused) {this._playbackResource.play();}\n			this._sendEvent("loop");\n		}\n	};\n\n	// NOTE with this approach audio will loop as reliably as the browser allows\n	// but we could end up sending the loop event after next loop playback begins\n	p._handleLoop = function (event) {\n		if(this._loop == 0) {\n			this._playbackResource.loop = false;\n			this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\n		}\n	};\n\n	p._updateDuration = function () {\n		this._audioSpriteStopTime = (startTime + duration) * 0.001;\n\n		if(this.playState == createjs.Sound.PLAY_SUCCEEDED) {\n			this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED, this._endedHandler, false);\n			this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE, this._audioSpriteEndHandler, false);\n		}\n	};\n\n	/*	This should never change\n	p._setDurationFromSource = function () {\n		this._duration = createjs.HTMLAudioTagPool.getDuration(this.src);\n	};\n	*/\n\n	createjs.HTMLAudioSoundInstance = createjs.promote(HTMLAudioSoundInstance, "AbstractSoundInstance");\n}());\n\n//##############################################################################\n// HTMLAudioPlugin.js\n//##############################################################################\n\nthis.createjs = this.createjs || {};\n\n(function () {\n\n	"use strict";\n\n	/**\n	 * Play sounds using HTML &lt;audio&gt; tags in the browser. This plugin is the second priority plugin installed\n	 * by default, after the {{#crossLink "WebAudioPlugin"}}{{/crossLink}}.  For older browsers that do not support html\n	 * audio, include and install the {{#crossLink "FlashAudioPlugin"}}{{/crossLink}}.\n	 *\n	 * <h4>Known Browser and OS issues for HTML Audio</h4>\n	 * <b>All browsers</b><br />\n	 * Testing has shown in all browsers there is a limit to how many audio tag instances you are allowed.  If you exceed\n	 * this limit, you can expect to see unpredictable results.  This will be seen as soon as you register sounds, as\n	 * tags are precreated to allow Chrome to load them.  Please use {{#crossLink "Sound.MAX_INSTANCES"}}{{/crossLink}} as\n	 * a guide to how many total audio tags you can safely use in all browsers.\n	 *\n     * <b>IE html limitations</b><br />\n     * <ul><li>There is a delay in applying volume changes to tags that occurs once playback is started. So if you have\n     * muted all sounds, they will all play during this delay until the mute applies internally. This happens regardless of\n     * when or how you apply the volume change, as the tag seems to need to play to apply it.</li>\n     * <li>MP3 encoding will not always work for audio tags if it\'s not default.  We\'ve found default encoding with\n     * 64kbps works.</li>\n	 * <li>Occasionally very short samples will get cut off.</li>\n	 * <li>There is a limit to how many audio tags you can load and play at once, which appears to be determined by\n	 * hardware and browser settings.  See {{#crossLink "HTMLAudioPlugin.MAX_INSTANCES"}}{{/crossLink}} for a safe estimate.\n	 * Note that audio sprites can be used as a solution to this issue.</li></ul>\n	 *\n	 * <b>Safari limitations</b><br />\n	 * <ul><li>Safari requires Quicktime to be installed for audio playback.</li></ul>\n	 *\n	 * <b>iOS 6 limitations</b><br />\n	 * <ul><li>Note it is recommended to use {{#crossLink "WebAudioPlugin"}}{{/crossLink}} for iOS (6+)</li>\n	 * 		<li>HTML Audio is disabled by default because</li>\n	 * 		<li>can only have one &lt;audio&gt; tag</li>\n	 * 		<li>can not preload or autoplay the audio</li>\n	 * 		<li>can not cache the audio</li>\n	 * 		<li>can not play the audio except inside a user initiated event.</li>\n	 * 		<li>audio sprites can be used to mitigate some of these issues and are strongly recommended on iOS</li>\n	 * </ul>\n	 *\n	 * <b>Android Native Browser limitations</b><br />\n	 * <ul><li>We have no control over audio volume. Only the user can set volume on their device.</li>\n	 *      <li>We can only play audio inside a user event (touch/click).  This currently means you cannot loop sound or use a delay.</li></ul>\n	 * <b> Android Chrome 26.0.1410.58 specific limitations</b><br />\n	 * <ul> <li>Can only play 1 sound at a time.</li>\n	 *      <li>Sound is not cached.</li>\n	 *      <li>Sound can only be loaded in a user initiated touch/click event.</li>\n	 *      <li>There is a delay before a sound is played, presumably while the src is loaded.</li>\n	 * </ul>\n	 *\n	 * See {{#crossLink "Sound"}}{{/crossLink}} for general notes on known issues.\n	 *\n	 * @class HTMLAudioPlugin\n	 * @extends AbstractPlugin\n	 * @constructor\n	 */\n	function HTMLAudioPlugin() {\n		this.AbstractPlugin_constructor();\n\n\n	// Public Properties\n		/**\n		 * The default number of instances to allow.  Used by {{#crossLink "Sound"}}{{/crossLink}} when a source\n		 * is registered using the {{#crossLink "Sound/register"}}{{/crossLink}} method.  This is only used if\n		 * a value is not provided.\n		 *\n		 * <b>NOTE this property only exists as a limitation of HTML audio.</b>\n		 * @property defaultNumChannels\n		 * @type {Number}\n		 * @default 2\n		 * @since 0.4.0\n		 */\n		this.defaultNumChannels = 2;\n\n		this._capabilities = s._capabilities;\n\n		this._loaderClass = createjs.SoundLoader;\n		this._soundInstanceClass = createjs.HTMLAudioSoundInstance;\n	}\n\n	var p = createjs.extend(HTMLAudioPlugin, createjs.AbstractPlugin);\n	var s = HTMLAudioPlugin;\n\n\n// Static Properties\n	/**\n	 * The maximum number of instances that can be loaded and played. This is a browser limitation, primarily limited to IE9.\n	 * The actual number varies from browser to browser (and is largely hardware dependant), but this is a safe estimate.\n	 * Audio sprites work around this limitation.\n	 * @property MAX_INSTANCES\n	 * @type {Number}\n	 * @default 30\n	 * @static\n	 */\n	s.MAX_INSTANCES = 30;\n\n	/**\n	 * Event constant for the "canPlayThrough" event for cleaner code.\n	 * @property _AUDIO_READY\n	 * @type {String}\n	 * @default canplaythrough\n	 * @static\n	 * @protected\n	 */\n	s._AUDIO_READY = "canplaythrough";\n\n	/**\n	 * Event constant for the "ended" event for cleaner code.\n	 * @property _AUDIO_ENDED\n	 * @type {String}\n	 * @default ended\n	 * @static\n	 * @protected\n	 */\n	s._AUDIO_ENDED = "ended";\n\n	/**\n	 * Event constant for the "seeked" event for cleaner code.  We utilize this event for maintaining loop events.\n	 * @property _AUDIO_SEEKED\n	 * @type {String}\n	 * @default seeked\n	 * @static\n	 * @protected\n	 */\n	s._AUDIO_SEEKED = "seeked";\n\n	/**\n	 * Event constant for the "stalled" event for cleaner code.\n	 * @property _AUDIO_STALLED\n	 * @type {String}\n	 * @default stalled\n	 * @static\n	 * @protected\n	 */\n	s._AUDIO_STALLED = "stalled";\n\n	/**\n	 * Event constant for the "timeupdate" event for cleaner code.  Utilized for looping audio sprites.\n	 * This event callsback ever 15 to 250ms and can be dropped by the browser for performance.\n	 * @property _TIME_UPDATE\n	 * @type {String}\n	 * @default timeupdate\n	 * @static\n	 * @protected\n	 */\n	s._TIME_UPDATE = "timeupdate";\n\n	/**\n	 * The capabilities of the plugin. This is generated via the {{#crossLink "HTMLAudioPlugin/_generateCapabilities"}}{{/crossLink}}\n	 * method. Please see the Sound {{#crossLink "Sound/getCapabilities"}}{{/crossLink}} method for an overview of all\n	 * of the available properties.\n	 * @property _capabilities\n	 * @type {Object}\n	 * @protected\n	 * @static\n	 */\n	s._capabilities = null;\n\n	/**\n	 * Deprecated now that we have audio sprite support.  Audio sprites are strongly recommend on iOS for the following reasons:\n	 * <li>it can only have one &lt;audio&gt; tag</li>\n	 * <li>can not preload or autoplay the audio</li>\n	 * <li>can not cache the audio</li>\n	 * <li>can not play the audio except inside a user initiated event</li>\n	 *\n	 * @property enableIOS\n	 * @type {Boolean}\n	 * @default false\n	 * @deprecated\n	 */\n	s.enableIOS = false;\n\n\n// Static Methods\n	/**\n	 * Determine if the plugin can be used in the current browser/OS. Note that HTML audio is available in most modern\n	 * browsers, but is disabled in iOS because of its limitations.\n	 * @method isSupported\n	 * @return {Boolean} If the plugin can be initialized.\n	 * @static\n	 */\n	s.isSupported = function () {\n		s._generateCapabilities();\n		if (s._capabilities == null) {return false;}\n		return true;\n	};\n\n	/**\n	 * Determine the capabilities of the plugin. Used internally. Please see the Sound API {{#crossLink "Sound/getCapabilities"}}{{/crossLink}}\n	 * method for an overview of plugin capabilities.\n	 * @method _generateCapabilities\n	 * @static\n	 * @protected\n	 */\n	s._generateCapabilities = function () {\n		if (s._capabilities != null) {return;}\n		var t = document.createElement("audio");\n		if (t.canPlayType == null) {return null;}\n\n		s._capabilities = {\n			panning:true,\n			volume:true,\n			tracks:-1\n		};\n\n		// determine which extensions our browser supports for this plugin by iterating through Sound.SUPPORTED_EXTENSIONS\n		var supportedExtensions = createjs.Sound.SUPPORTED_EXTENSIONS;\n		var extensionMap = createjs.Sound.EXTENSION_MAP;\n		for (var i = 0, l = supportedExtensions.length; i < l; i++) {\n			var ext = supportedExtensions[i];\n			var playType = extensionMap[ext] || ext;\n			s._capabilities[ext] = (t.canPlayType("audio/" + ext) != "no" && t.canPlayType("audio/" + ext) != "") || (t.canPlayType("audio/" + playType) != "no" && t.canPlayType("audio/" + playType) != "");\n		}  // OJR another way to do this might be canPlayType:"m4a", codex: mp4\n	};\n\n\n// public methods\n	p.register = function (loadItem, instances) {\n		var channel = createjs.HTMLAudioTagPool.get(loadItem.src);\n		var tag = null;\n		for (var i = 0; i < instances; i++) {\n			tag = this._createTag(loadItem.src);\n			channel.add(tag);\n		}\n\n		var loader = this.AbstractPlugin_register(loadItem, instances);\n		loader.setTag(tag);\n\n		return loader;\n	};\n\n	p.removeSound = function (src) {\n		this.AbstractPlugin_removeSound(src);\n		createjs.HTMLAudioTagPool.remove(src);\n	};\n\n	p.create = function (src, startTime, duration) {\n		var si = this.AbstractPlugin_create(src, startTime, duration);\n		si.setPlaybackResource(null);\n		return si;\n	};\n\n	p.toString = function () {\n		return "[HTMLAudioPlugin]";\n	};\n\n	// plugin does not support these\n	p.setVolume = p.getVolume = p.setMute = null;\n\n\n// private methods\n	/**\n	 * Create an HTML audio tag.\n	 * @method _createTag\n	 * @param {String} src The source file to set for the audio tag.\n	 * @return {HTMLElement} Returns an HTML audio tag.\n	 * @protected\n	 */\n	// TODO move this to tagpool when it changes to be a standard object pool\n	p._createTag = function (src) {\n		var tag = document.createElement("audio");\n		tag.autoplay = false;\n		tag.preload = "none";\n		//LM: Firefox fails when this the preload="none" for other tags, but it needs to be "none" to ensure PreloadJS works.\n		tag.src = src;\n		return tag;\n	};\n\n	createjs.HTMLAudioPlugin = createjs.promote(HTMLAudioPlugin, "AbstractPlugin");\n}());'
}, function(module, exports, __webpack_require__) {
    __webpack_require__(1)(__webpack_require__(31))
}, function(module, exports, __webpack_require__) {
    __webpack_require__(1)(__webpack_require__(32))
}, function(module, exports, __webpack_require__) {
    __webpack_require__(1)(__webpack_require__(33))
}, function(module, exports, __webpack_require__) {
    __webpack_require__(1)(__webpack_require__(34))
}, function(module, exports, __webpack_require__) {
    __webpack_require__(1)(__webpack_require__(35))
}, function(module, exports, __webpack_require__) {
    __webpack_require__(1)(__webpack_require__(36))
}, function(module, exports, __webpack_require__) {
    __webpack_require__(1)(__webpack_require__(37))
}, function(module, exports, __webpack_require__) {
    __webpack_require__(1)(__webpack_require__(38))
}, function(module, exports, __webpack_require__) {
    __webpack_require__(1)(__webpack_require__(39))
}, function(module, exports, __webpack_require__) {
    __webpack_require__(1)(__webpack_require__(40))
}, function(module, exports, __webpack_require__) {
    __webpack_require__(1)(__webpack_require__(41))
}, function(module, exports, __webpack_require__) {
    __webpack_require__(1)(__webpack_require__(42))
}, function(module, exports, __webpack_require__) {
    __webpack_require__(1)(__webpack_require__(43))
}, function() {
    "use strict";
    codeplayground.FlyingmanPlaythingView = codeplayground.BasePlaythingView.extend({
        flapSpeed: 5,
        xspeed: 1000,
        tick: 0,
        flyingMan_bounds: 600,
        prevxpos: 0,
        currentx: 0,
        currentHorizSpeed: 0,
        vy: 0,
        gravity: -.01,
        flapping: !0,
        altitude: .2,
        constructor: function(id, dispatcher) {
            window.codeplayground.BasePlaythingView.call(this, id, dispatcher), this.flyingman = null, this.volume = .5
        },
        initView: function(stage, worldBounds) {
            this.proto.initView.call(this, stage, worldBounds), this.loadAssets("/images/sprites/flying-man.json"), this.loadSounds("flap-wings6")
        },
        onOver: function() {
           // this.flyingMan.tint = 16776960
        },
        onOut: function() {
            //this.flyingMan.tint = 16777215
        },
        onAssetsLoaded: function() {
            for (var flyingManTextures = [], mod = "", i = 0; 2 > i; i++) {
                mod = 9 > i ? "0" : "";
                var texture = PIXI.Texture.fromFrame("flying man " + (i + 1) + ".png");
                flyingManTextures.push(texture)
            }
            this.flyingMan = new PIXI.MovieClip(flyingManTextures);
            var centreX = this.getCenterOffsetX();
            this.flyingMan.position.x = centreX, this.flyingMan_bounds_min = 0, this.flyingMan_bounds_max = centreX, this.flyingMan.position.y = Math.floor(window.innerHeight), this.flyingMan.anchor.x = .5, this.flyingMan.anchor.y = .5, this.flyingMan.scale.x = this.flyingMan.scale.y = .5, this.flyingMan.scale.x *= -1, this.flyingMan.origWidth = this.flyingMan.width, this.flyingMan.gotoAndPlay(1), this.flyingMan.animationSpeed = .1, this.stage.addChild(this.flyingMan), this.rootDisplayObject = this.flyingMan, this.setAltitude(), this.notifyReady(), this.unlock(), this.initSelect(), this.updateView()
        },
        onSoundsLoaded: function() {
            this.proto.onSoundsLoaded.call(this), this.sound = this.createSound(this.tracks[0].id), this.sound.on("complete", this.playSound.bind(this)), this.introFinished && setTimeout(this.playSound.bind(this), 500)
        },
        playSound: function() {
            this.updateInView(), this.updateVolume(), this.sound && this.sound.play()
        },
        onIntroFinished: function() {
            this.proto.onIntroFinished.call(this), setTimeout(this.playSound.bind(this), 500)
        },
        updateProperties: function(editable) {
            this.properties = editable, this.flapSpeed = this.properties.getByName("flapSpeed").value / 100
        },
        updateView: function() {
            var flyingMan = this.flyingMan;
            if (this.isReady && this.isPlaying) {
                this.tick++;
                var sinWidth = Math.sin(this.tick / this.xspeed),
                    sinHeight = Math.sin(this.tick / 25);
                flyingMan.x = this.getCenterOffsetX() + (this.flyingMan_bounds_max - this.flyingMan_bounds_min) * sinWidth, flyingMan.y = window.innerHeight * (1 - this.altitude) + 50 * sinHeight, flyingMan.animationSpeed = Math.min(.3, (sinHeight + 1) / 2), this.updateInView(), this.updateVolume(), this.checkDirection()
            }
        },
        setAltitude: function() {
            TweenMax.to(this.flyingMan.anchor, 3, {
                y: 1 - this.flapSpeed
            }), TweenMax.to(this, 3, {
                altitude: Math.min(this.flapSpeed, window.innerHeight),
                ease: Quad.easeInOut
            })
        },
        release: function() {
            this.proto.release.call(this), this.setAltitude()
        },
        checkDirection: function() {
            this.currentx = this.flyingMan.x, this.currentHorizSpeed = Math.abs(this.currentx - this.prevxpos), this.prevxpos < this.currentx && (this.flyingMan.width = this.flyingMan.origWidth), this.prevxpos > this.currentx && (this.flyingMan.width = -this.flyingMan.origWidth), this.prevxpos = this.currentx
        },
        pause: function() {
            this.proto.pause.call(this), this.flyingMan.stop()
        },
        resume: function() {
            this.proto.resume.call(this), this.flyingman && this.flyingMan.play()
        }
    })
}
, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , function() {
    ! function(codeplayground) {
        "use strict";
        var SelectPlaythingCommand = function(dispatcher, playgroundModel, deviceModel, analyticsModel) {
            this.execute = function(event) {
                var playthingId = event.params.playthingId;
                Modernizr.touch && playgroundModel.isSwiping || (playgroundModel.selectedPlaything && dispatcher.dispatch(codeplayground.events.PLAYTHING_UNSELECTED, {
                    playthingId: playgroundModel.selectedPlaything.id
                }), playgroundModel.selectedPlaything = playgroundModel.getPlaythingById(playthingId), playgroundModel.hasChanged = !1, analyticsModel.track(playgroundModel.selectedPlaything.id, "Click", "Playground"), dispatcher.dispatch(codeplayground.events.LOCK_PLAYTHING), dispatcher.dispatch(codeplayground.events.HOLD_PLAYTHING, {
                    playthingId: playthingId
                }), dispatcher.dispatch(codeplayground.events.SHOW_EDITOR, {
                    plaything: playgroundModel.selectedPlaything,
                    playthingPosition: event.params.playthingPosition,
                    group: event.params.group
                }))
            }
        };
        codeplayground.SelectPlaythingCommand = SelectPlaythingCommand
    }(window.codeplayground = window.codeplayground || {})
}, function() {
    ! function(codeplayground) {
        "use strict";
        var UnselectPlaythingCommand = function(dispatcher, playgroundModel) {
            this.execute = function(event) {
                if (playgroundModel.selectedPlaything) {
                    var playthingId = playgroundModel.selectedPlaything.id;
                    playgroundModel.isPaused || dispatcher.dispatch(codeplayground.events.RELEASE_PLAYTHING, {
                        playthingId: playthingId
                    }), playgroundModel.selectedPlaything = null, dispatcher.dispatch(codeplayground.events.UNLOCK_PLAYTHING), playgroundModel.hasChanged && (dispatcher.dispatch(codeplayground.events.RESUME_ALL_PLAYTHING), playgroundModel.isPaused = !1, playgroundModel.hasChanged = !1), dispatcher.dispatch(codeplayground.events.HIDE_EDITOR, {
                        clicked: event.params && event.params.clicked
                    })
                }
            }
        };
        codeplayground.UnselectPlaythingCommand = UnselectPlaythingCommand
    }(window.codeplayground = window.codeplayground || {})
}, function() {
    ! function(codeplayground) {
        "use strict";
        var UpdatePropertiesCommand = function(dispatcher, playgroundModel) {
            this.execute = function(event) {
                var plaything = event.params.plaything;
                playgroundModel.getPlaythingById(plaything.id).setEditableProperties(plaything.editableProperties)
            }
        };
        codeplayground.UpdatePropertiesCommand = UpdatePropertiesCommand
    }(window.codeplayground = window.codeplayground || {})
}, function() {
    ! function(codeplayground, ga) {
        "use strict";
        var initialised = [],
            AnalyticsModel = function() {
                return {
                    init: function() {
                        var that = this,
                            addListener = function(el) {
                                initialised.indexOf(el) > -1 || (initialised.push(el), el.addEventListener("click", function() {
                                    that.trackClick(this)
                                }, !1))
                            };
                        [].forEach.call(document.querySelectorAll("a[data-event-id], button[data-event-id]"), addListener), [].forEach.call(document.querySelectorAll("input[data-event-id]"), addListener)
                    },
                    trackClick: function(elem) {
                        if ("undefined" != typeof ga) {
                            var eventId = elem.getAttribute("data-event-id");
                            eventId && ga("send", "event", "button", "click", eventId)
                        }
                    },
                    track: function(category, action, label) {
                        ga("send", "event", category, action, label)
                    }
                }
            };
        codeplayground.AnalyticsModel = AnalyticsModel
    }(window.codeplayground = window.codeplayground || {}, window.ga)
}, function() {
    ! function(codeplayground) {
        "use strict";
        codeplayground.ConfigModel = function() {
            return {
                skipIntro: /intro=false/.test(location.search),
                getLocaleConfigUrl: function() {
                    return "/locale/config.xml"
                }
            }
        }
    }(window.codeplayground = window.codeplayground || {})
}, function(module, exports, __webpack_require__) {
    ! function(codeplayground) {
        "use strict";
        var PlaygroundModel = function(dispatcher, injector, deviceModel) {
            this.dispatcher = dispatcher, this.injector = injector, this.isMobile = deviceModel.isMobile(), this.isAndroidBrowser = deviceModel.isAndroidBrowser(), this.selectedPlaything = null, this.playthings = [], this.json = __webpack_require__(129), this.isSwiping = !1, this.isPaused = !1, this.hasChanged = !1
        };
        PlaygroundModel.prototype.init = function() {
            var playthingsArray = this.json.playthings,
                solo = !1;
            this.playthings = playthingsArray.map(function(data) {
                return solo = solo || data.solo, this.injector.createInstance(codeplayground.PlaythingVO, data)
            }, this), this.playthings = solo ? this.playthings.filter(this.isSoloFilter) : this.playthings.filter(this.isEnabledFilter).filter(this.getMobileEnabledFilter()).filter(this.getAndroidEnabledFilter()).filter(this.isSoundEnabledFilter).filter(this.getWebGLFilter()), this.dispatcher.dispatch(codeplayground.events.INITIALIZE_PLAYGROUND, {
                playthings: this.playthings
            })
        }, PlaygroundModel.prototype.isSoloFilter = function(plaything) {
            return plaything.solo
        }, PlaygroundModel.prototype.isEnabledFilter = function(plaything) {
            return plaything.enabled && plaything.viewClass
        }, PlaygroundModel.prototype.getMobileEnabledFilter = function() {
            var isMobile = this.isMobile;
            return function(plaything) {
                return !isMobile || plaything.mobileEnabled
            }
        }, PlaygroundModel.prototype.getAndroidEnabledFilter = function() {
            var isMobile = this.isMobile,
                isAndroidBrowser = this.isAndroidBrowser;
            return function(plaything) {
                return !isAndroidBrowser || !isMobile || plaything.androidMobile
            }
        }, PlaygroundModel.prototype.isSoundEnabledFilter = function(plaything) {
            return !plaything.requiresSound || codeplayground.canPlaySounds
        }, PlaygroundModel.prototype.getWebGLFilter = function() {
            var hasWebGL = PIXI.autoDetectRenderer() instanceof PIXI.WebGLRenderer;
            return function(plaything) {
                return hasWebGL || !plaything.needsWebGL
            }
        }, PlaygroundModel.prototype.getPlaythingById = function(id) {
            for (var totalPlaythings = this.playthings.length, plaything = null, i = 0; totalPlaythings > i; i++)
                if (plaything = this.playthings[i], plaything.id === id) return plaything;
            return null
        }, PlaygroundModel.prototype.resetAll = function() {
            for (var totalPlaythings = this.playthings.length, plaything = null, i = 0; totalPlaythings > i; i++) plaything = this.playthings[i], plaything.resetEditableProperties()
        }, codeplayground.PlaygroundModel = PlaygroundModel
    }(window.codeplayground = window.codeplayground || {})
}, function() {
    ! function(codeplayground) {
        "use strict";
        var co = codeplayground,
            AyeView = function(id, dispatcher) {
                codeplayground.BasePlaythingView.call(this, id, dispatcher), this.isPlaying = !0, this.dispatcher = dispatcher, this.id = "AyeView", this.aye = null, this.idleTimeout = void 0, this.idleDelay = 1e4, this.isAyeAnimating = !1, this.isAyeRunning = !1, this.isAyeFolded = !1, dispatcher.addEventListener(codeplayground.events.SHOW_INFO, this.fold.bind(this)), dispatcher.addEventListener(codeplayground.events.HIDE_INFO, this.unfold.bind(this)), dispatcher.addEventListener(co.events.VIEW_FOCUS, this.focusView.bind(this)), dispatcher.addEventListener(co.events.ELEMENT_HIT, this.hitElement.bind(this))
            };
        AyeView.prototype.initView = function(stage, worldBounds) {
            codeplayground.BasePlaythingView.prototype.initView.call(this, stage, worldBounds), this.loadAssets("/images/sprites/aye.json")
        }, AyeView.prototype.generateSequenceFromFrames = function(start, end, pattern) {
            for (var sequence = [], frameNum = 0, frameName = null, i = start; end >= i; i++) frameNum = ("0000" + (i + 1)).slice(-4), frameName = pattern + frameNum + ".png", sequence.push(PIXI.Texture.fromFrame(frameName));
            return sequence
        }, AyeView.prototype.onAssetsLoaded = function() {
            var sequences = {
                idle: this.generateSequenceFromFrames(0, 0, "aye-"),
                blink: this.generateSequenceFromFrames(1, 8, "aye-"),
                hop: this.generateSequenceFromFrames(9, 21, "aye-"),
                "run-right": this.generateSequenceFromFrames(22, 25, "aye-"),
                "run-left": this.generateSequenceFromFrames(26, 29, "aye-"),
                fold: this.generateSequenceFromFrames(30, 46, "aye-"),
                unfold: this.generateSequenceFromFrames(47, 58, "aye-")
            };
            this.aye = new PIXI.AnimatedSprite(sequences, 12, "idle"), this.aye.position.x = Math.random() * window.innerWidth, this.aye.position.y = this.worldBounds.height, this.aye.anchor.x = .5, this.aye.anchor.y = 1, this.aye.loop = !0, this.aye.hitArea = new PIXI.Rectangle(-43, -130, 86, 130), this.rootDisplayObject = this.aye, this.stage.addChild(this.rootDisplayObject), this.rootDisplayObject.interactive = !0, this.rootDisplayObject.buttonMode = !0, this.rootDisplayObject.click = this.rootDisplayObject.tap = function() {
                this.dispatcher.dispatch(codeplayground.events.SHOW_INFO), this.rootDisplayObject.mouseout = null
            }.bind(this), this.rootDisplayObject = this.aye, this.rootDisplayObject.interactive = !0, this.rootDisplayObject.mouseover = function() {
                this.dispatcher.dispatch(codeplayground.events.LOCK_VIEWPORT), this.rootDisplayObject.mouseout = function() {
                    this.dispatcher.dispatch(codeplayground.events.UNLOCK_VIEWPORT), this.rootDisplayObject.mouseout = null
                }.bind(this)
            }.bind(this), this.isReady = !0, this.updateView()
        }, AyeView.prototype.updateView = function(delta) {
            if (this.isReady && this.isPlaying) {
                if (!this.isAyeFolded) {
                    var newX = this.viewport.x + this.viewport.width - 50,
                        diff = newX - this.aye.x;
                    newX > this.aye.x ? (this.aye.loop = !0, this.aye.gotoAndPlay("run-right"), this.isAyeRunning = !0) : newX < this.aye.x ? (this.aye.loop = !0, this.aye.gotoAndPlay("run-left"), this.isAyeRunning = !0) : this.isAyeAnimating || (this.aye.gotoAndStop("idle"), this.isAyeRunning = !1), this.isAyeRunning ? this.cancelIdleAnimation() : this.initIdleAnimation(), 5 > diff ? this.aye.x = newX : this.aye.x += .1 * (newX - this.aye.x)
                }
                this.aye.position.y = this.worldBounds.height, this.aye.advanceTime(delta)
            }
        }, AyeView.prototype.initIdleAnimation = function() {
            this.isAyeRunning || this.isAyeFolded || this.idleTimeout || (this.idleTimeout = window.setTimeout(function() {
                this.isAyeAnimating = !0, this.aye.loop = !1, this.idleTimeout = null, this.aye.onComplete = function() {
                    this.isAyeAnimating = !1, this.aye.loop = !0, this.aye.onComplete = null, this.initIdleAnimation()
                }.bind(this), this.aye.gotoAndPlay("hop")
            }.bind(this), this.idleDelay))
        }, AyeView.prototype.cancelIdleAnimation = function() {
            this.idleTimeout && (window.clearTimeout(this.idleTimeout), this.idleTimeout = void 0)
        }, AyeView.prototype.fold = function() {
            this.isAyeFolded = !0, this.aye.loop = !1, this.aye.gotoAndPlay("fold")
        }, AyeView.prototype.unfold = function() {
            this.aye.loop = !1, this.aye.gotoAndPlay("unfold"), this.aye.onComplete = function() {
                this.aye.onComplete = null, this.isAyeFolded = !1
            }.bind(this)
        }, AyeView.prototype.focusView = function(event) {
            return event.params.view !== this.id ? (this.aye.isAyeFolded && this.aye.gotoAndPlay("idle"), this.aye.isAyeFolded = !1, void(this.isAyeAnimating = !1)) : (this.cancelIdleAnimation(), this.aye.isAyeFolded = !0, this.isAyeAnimating = !0, this.aye.gotoAndPlay("hop"), void this.dispatcher.dispatch(codeplayground.events.ELEMENT_FOCUSED, {
                description: "information button"
            }))
        }, AyeView.prototype.hitElement = function(event) {
            event.params.view === this.id && (this.dispatcher.dispatch(codeplayground.events.SHOW_INFO), document.getElementById("infoTab1").focus())
        }, codeplayground.AyeView = AyeView, soma.inherit(codeplayground.BasePlaythingView, codeplayground.AyeView.prototype)
    }(window.codeplayground = window.codeplayground || {})
}, function() {
    "use strict";
    codeplayground.BallsPlaythingView = codeplayground.BasePlaythingView.extend({
        K: 1,
        VELOCITY_X: 20,
        REBOUNCE_VELOCITY: 40,
        ROTATION_CONSTANT: .008,
        DRAG: .9,
        TYPES: ["base", "tennis", "basket", "soccer", "beach", "eight"],
        SOUNDS: [null, "tennis-ball-1", "basketball-1", "football-1", null, null],
        constructor: function(id, dispatcher) {
            codeplayground.BasePlaythingView.call(this, id, dispatcher), this.dispatcher = dispatcher, this.stage = null, this.container = null, this.balls = [], this.volume = .2
        },
        initView: function(stage, worldBounds) {
            this.proto.initView.call(this, stage, worldBounds), this.loadAssets("/images/sprites/balls.json"), this.loadSounds(this.SOUNDS.filter(Boolean))
        },
        onAssetsLoaded: function() {
            this.container = new PIXI.DisplayObjectContainer, Object.defineProperty(this.container, "tint", {
                set: this.setTint.bind(this)
            }), this.rootDisplayObject = this.container;
            var bounds = this.worldBounds;
            this.TYPES.forEach(function(type, i) {
                var ball = new PIXI.DisplayObjectContainer,
                    bShape = ball.bShape = PIXI.Sprite.fromFrame("ball." + type),
                    bShadow = ball.bShadow = PIXI.Sprite.fromFrame("ball." + type + ".shadow");
                ball.scale.x = ball.scale.y = .4, ball.addChild(bShape), ball.addChild(bShadow), bShape.anchor.x = .5, bShape.anchor.y = .5, bShape.y = -bShape.height / 2, bShadow.x = -bShape.width / 2, bShadow.y = -bShadow.height, ball.velocityX = -this.VELOCITY_X / 2 + Math.random() * this.VELOCITY_X, ball.velocityY = 0, ball.x = 5 * bounds.width / 7 + Math.random() * bounds.width * 2 / 7, ball.y = Math.random() * bounds.height, ball.elasticity = this.elasticity, ball.visible = i < this.numOfBalls, ball.click = ball.tap = this.notifySelected.bind(this), this.balls.push(ball), this.container.addChild(ball)
            }, this), this.stage.addChild(this.container), this.proto.onAssetsLoaded.call(this), this.isReady = !0, this.unlock(), this.initSelect(), this.updateView(), this.notifyReady()
        },
        onAllLoaded: function() {
            this.proto.onAllLoaded.call(this) && this.balls.forEach(function(ball, i) {
                var id = this.SOUNDS[i];
                id && (ball.sound = this.createSound(id), this.sound || (this.sound = ball.sound))
            }, this)
        },
        updateProperties: function(editable) {
            this.properties = editable, this.numOfBalls = this.properties.getByName("numOfBalls").value, this.gravity = this.properties.getByName("gravity").value, this.elasticity = this.properties.getByName("elasticity").value, this.container && this.balls.forEach(function(ball, i) {
                ball.elasticity = this.elasticity, ball.visible = i < this.numOfBalls
            }, this)
        },
        updateView: function() {
            if (this.isReady && this.isPlaying) {
                var bounds = this.worldBounds;
                this.balls.forEach(function(ball, i) {
                    if (!(i >= this.numOfBalls)) {
                        ball.velocityY += this.gravity * this.K, ball.y += ball.velocityY, ball.x += ball.velocityX * this.DRAG, ball.bShape.rotation += ball.velocityX * this.ROTATION_CONSTANT;
                        var halfW = ball.width / 2,
                            bounced = !1;
                        if ((ball.x < halfW || ball.x > bounds.width - halfW) && (ball.x = ball.x < halfW ? halfW : bounds.width - halfW, ball.velocityX = -ball.velocityX * ball.elasticity, bounced = !0), ball.y > bounds.height - 1 ? (ball.y = bounds.height, ball.velocityY = -ball.velocityY * ball.elasticity, Math.abs(ball.velocityY) < 1 ? (ball.velocityY = (.2 + .8 * Math.random()) * -this.REBOUNCE_VELOCITY * this.gravity, ball.velocityX = -this.VELOCITY_X / 2 + Math.random() * this.VELOCITY_X) : bounced = !0) : ball.y < 0 && ball.elasticity > 1 && (ball.elasticity = .95), ball.sound && bounced) {
                            var vp = this.viewport,
                                l = ball.x - halfW,
                                r = ball.x + halfW,
                                vpR = vp.x + vp.width,
                                onScreen = l >= vp.x && vpR >= l || r >= vp.x && vpR >= r;
                            onScreen && (this.updateVolume(ball.sound, 1), ball.sound.stop(), ball.sound.play())
                        }
                    }
                }, this)
            }
        },
        setTint: function(tint) {
            this.balls.forEach(function(ball) {
                ball.bShape.tint = tint
            })
        }
    })
}, function() {
    "use strict";
    codeplayground.BucketMonsterPlaythingView = codeplayground.BasePlaythingView.extend({
        SPEED_FACTOR: .1,
        MONSTER_OFFSET_Y: 500,
        BUCKET_OFFSET_X: 230,
        BUCKET_OFFSET_Y: -100,
        MASK_OFFSET: 500,
        NO_TINT: 16777215,
        MAX_TILT: 5,
        goingLeft: !0,
        cycle: 0,
        tick: 0,
        maskDelta: 0,
        originalColour: 7746100,
        oldColour: null,
        newColour: null,
        STATE_HOVER: "state_hover",
        STATE_END: "state_end",
        constructor: function(id, dispatcher) {
            window.codeplayground.BasePlaythingView.call(this, id, dispatcher), this.bucketmonster = null, this.oldColour = this.originalColour, this.maskDelta = -this.MASK_OFFSET, this.editableBucketTilt = this.MAX_TILT, this.volume = .6
        },
        initView: function(stage, worldBounds) {
            this.proto.initView.call(this, stage, worldBounds), this.loadAssets("/images/sprites/bucketmonster.json"), this.loadSounds(["monster-roar-6", "squelchy-splat-2"])
        },
        onAssetsLoaded: function() {
            var bucketmonster = this.bucketmonster = new PIXI.DisplayObjectContainer;
            Object.defineProperty(bucketmonster, "tint", {
                set: this.setTint.bind(this)
            }), this.rootDisplayObject = bucketmonster, this.stage.addChild(bucketmonster), bucketmonster.y = this.worldBounds.height - this.MONSTER_OFFSET_Y, bucketmonster.scale.x = bucketmonster.scale.y = .5, bucketmonster.x = this.getCenterOffsetX();
            for (var mod, texture, mainBody = this.mainBody = PIXI.Sprite.fromFrame("monster"), maskBody = this.maskBody = PIXI.Sprite.fromFrame("monster"), monsterFace = this.monsterFace = PIXI.Sprite.fromFrame("bucketmonster_face.png"), textures = [], i = 0; 22 > i; i++) mod = 10 > i ? "0" : "", texture = PIXI.Texture.fromFrame("bucket_animation_2" + (mod + i) + ".png"), textures.push(texture);
            var bucket = this.bucket = new PIXI.MovieClip(textures);
            for (bucketmonster.addChild(this.bucket), textures = [], i = 0; 23 > i; i++) mod = 10 > i ? "0" : "", texture = PIXI.Texture.fromFrame("paint" + (mod + i) + ".png"), textures.push(texture);
            var paint = this.paint = new PIXI.MovieClip(textures);
            bucketmonster.addChild(this.paint), [bucket, paint].forEach(function(mc) {
                mc.x = this.BUCKET_OFFSET_X, mc.y = this.BUCKET_OFFSET_Y, mc.animationSpeed = .2, mc.loop = !1
            }, this), bucketmonster.scale.x = bucketmonster.scale.y = .45, bucketmonster.x = .8 * this.worldBounds.width, this.state = this.STATE_HOVER, bucketmonster.addChild(mainBody), bucketmonster.addChild(maskBody), mainBody.tint = this.oldColour = this.originalColour, paint.tint = maskBody.tinit = this.tintColour, this.thing = new PIXI.Graphics, bucketmonster.addChild(this.thing), this.thing.position.x = 200, this.thing.position.y = 190, this.thing.lineStyle(0), this.maskBody.mask = this.thing, this.moveMask = !1, bucketmonster.addChild(monsterFace), monsterFace.x = 250, monsterFace.y = 320, this.isEnd = !1, this.notifyReady(), this.unlock(), this.initSelect(), this.drawMask(), this.updateView()
        },
        onSoundsLoaded: function() {
            this.proto.onSoundsLoaded.call(this), this.sound = this.createSound(this.tracks[0].id), this.soundPaint = this.createSound(this.tracks[1].id)
        },
        resizeView: function(worldBounds) {
            this.worldBounds = worldBounds, this.isReady && (this.bucketmonster.y = this.worldBounds.height - this.MONSTER_OFFSET_Y)
        },
        updateProperties: function(editable) {
            this.properties = editable;
            var updated = {
                    editableBucketTilt: Math.floor(this.properties.getByName("tilt").value / 10),
                    redColour: this.properties.getByName("red").value,
                    greenColour: this.properties.getByName("green").value,
                    blueColour: this.properties.getByName("blue").value
                },
                hasChanged = Object.keys(updated).reduce(function(init, key) {
                    return init || updated[key] !== this[key]
                }.bind(this), !1);
            hasChanged && (Object.keys(updated).forEach(function(key) {
                this[key] = updated[key]
            }, this), this.tintColour = this.rgbToHex(this.redColour, this.greenColour, this.blueColour), this.isReady && (this.paint.tint = this.maskBody.tint = this.tintColour, this.editableBucketTilt > this.MAX_TILT && (this.state = this.STATE_END)))
        },
        updateView: function() {
            this.isReady && this.isPlaying && (this.state === this.STATE_HOVER ? (this.loopBackMC(this.bucket, 0, this.editableBucketTilt, .2), this.paint.gotoAndStop(this.bucket.currentFrame)) : this.state !== this.STATE_END || this.isEnd || (this.isEnd = !0, setTimeout(function() {
                this.bucket.play(), this.paint.gotoAndPlay(this.bucket.currentFrame), this.moveMask = !0
            }.bind(this)), this.sound && (this.updateVolume(this.soundPaint), this.soundPaint.stop(), this.soundPaint.play(), setTimeout(function() {
                this.updateVolume(), this.sound.stop(), this.sound.play()
            }.bind(this), 300))), this.moveMask && (this.maskDelta += 4, this.tick += .2, this.drawMask(), this.maskDelta > this.MASK_OFFSET && (this.isEnd = !1, this.moveMask = !1, this.state = this.STATE_HOVER, this.resetColour())))
        },
        loopBackMC: function(mc, min, max, speed) {
            mc.direction = mc.direction || 1, mc.currentFrame += speed * mc.direction, mc.currentFrame >= max && (mc.direction = -1, mc.currentFrame = max), mc.currentFrame <= min && (mc.direction = !0, mc.currentFrame = min), mc.gotoAndStop(mc.currentFrame)
        },
        resetColour: function() {
            this.maskDelta = -this.MASK_OFFSET, this.drawMask(), this.mainBody.tint = this.oldColour = this.tintColour, this.editableBucketTilt = this.MAX_TILT
        },
        drawMask: function() {
            var sin = Math.sin(this.tick),
                cos = Math.cos(this.tick),
                a = -this.MASK_OFFSET,
                b = 20,
                c = 50,
                d = a / 3,
                e = -a + b;
            this.thing.clear(), this.thing.beginFill(0, .5), this.thing.moveTo(d + sin * b, a + cos * b), this.thing.lineTo(e + cos * b, a + sin * b), this.thing.lineTo(e + sin * b, this.maskDelta - a + cos * c), this.thing.lineTo(d + cos * b, this.maskDelta - a + sin * c), this.thing.lineTo(d + sin * b, d + cos * b), this.thing.endFill()
        },
        setTint: function(tint) {
            tint !== this.NO_TINT ? (this.mainBody.tint = tint, this.maskBody.tint = tint) : (this.mainBody.tint = this.oldColour, this.maskBody.tint = this.tintColour)
        },
        hold: function() {
            this.proto.hold.call(this), this.bucket.gotoAndStop(this.MAX_TILT), this.paint.gotoAndStop(this.MAX_TILT)
        },
        pcToHex: function(pc) {
            var hex = Math.round(pc / 100 * 255).toString(16);
            return 1 === hex.length ? "0" + hex : hex
        },
        rgbToHex: function(r, g, b) {
            return "0x" + this.pcToHex(r) + this.pcToHex(g) + this.pcToHex(b)
        }
    })
}, function() {
    "use strict";
    codeplayground.CatchyCrabPlaythingView = codeplayground.BasePlaythingView.extend({
        SPEED: 22,
        SECONDS_PER_FRUIT: 5,
        OFFSET_Y: 100,
        tick: 0,
        crab_bounds: 400,
        strawBerryFallSpeed: 6.5,
        catchArea: {
            width: 180,
            height: 1
        },
        fruitArea: {
            width: 70,
            height: 50
        },
        caughtFruit: !1,
        restartDelay: 3e3,
        canfall: !0,
        constructor: function(id, dispatcher) {
            window.codeplayground.BasePlaythingView.call(this, id, dispatcher), this.crab = null, this.volume = .3
        },
        initView: function(stage, worldBounds) {
            codeplayground.BasePlaythingView.prototype.initView.call(this, stage, worldBounds), this.loadAssets("/images/sprites/catchycrab.json"), this.loadSounds("crab-foley-1")
        },
        onOver: function() {
            //this.crab.tint = 16711680
        },
        onOut: function() {
            //this.crab.tint = 16777215
        },
        onAssetsLoaded: function() {
            var crabContainer = this.crabContainer = new PIXI.DisplayObjectContainer;
            this.stage.addChild(crabContainer), crabContainer.x = this.getCenterOffsetX();
            var sequences = {
                    walk: this.generateSequenceFromFrames(0, 1, "walk"),
                    "catch": this.generateSequenceFromFrames(1, 2, "catch")
                },
                crab = this.crab = new PIXI.AnimatedSprite(sequences, 3, "walk");
            this.crab.anchor.x = .5, this.crab.x = 200, this.crab.anchor.y = .9, this.crab.loop = !0, this.crab.gotoAndPlay("walk"), this.rootDisplayObject = this.crabContainer, crab.scale.x = crab.scale.y = .3, crabContainer.addChild(crab), this.crab.y = window.innerHeight - this.OFFSET_Y;
            var strawberry = this.strawberry = new PIXI.Sprite.fromFrame("strawberry.png");
            this.stage.addChild(strawberry), crabContainer.addChild(strawberry), strawberry.anchor.x = .5, strawberry.scale.x = strawberry.scale.y = .3, this.resetFruit(), strawberry.y = 0;
            var crabcatch = this.crabcatch = new PIXI.Graphics;
            crabContainer.addChild(crabcatch), crabcatch.beginFill("0xff0000", 0), crabcatch.moveTo(0, 0), crabcatch.lineTo(this.catchArea.width, 0), crabcatch.lineTo(this.catchArea.width, this.catchArea.height), crabcatch.lineTo(0, this.catchArea.height), crabcatch.lineTo(0, 0);
            var fruitcatch = this.fruitcatch = new PIXI.Graphics;
            crabContainer.addChild(fruitcatch), fruitcatch.beginFill("0xff6600", 0), fruitcatch.moveTo(0, 0), fruitcatch.lineTo(this.fruitArea.width, 0), fruitcatch.lineTo(this.fruitArea.width, this.fruitArea.height), fruitcatch.lineTo(0, this.fruitArea.height), fruitcatch.lineTo(0, 0), this.notifyReady(), this.unlock(), this.initSelect(), this.updateView()
        },
        onSoundsLoaded: function() {
            this.proto.onSoundsLoaded.call(this), this.sound = this.createSound(this.tracks[0].id)
        },
        updateProperties: function(editable) {
            this.properties = editable, this.SPEED = 50 * (this.properties.getByName("walkingspeed").value / 100)
        },
        updateView: function(delta) {
            if (this.isReady && this.isPlaying) {
                this.tick++;
                var crab = this.crab,
                    strawberry = this.strawberry;
                (crab.x <= -this.crab_bounds || crab.x >= this.crab_bounds) && (crab.scale.x *= -1), this.crab.advanceTime(delta), this.caughtFruit || (this.crabcatch.x = crab.x - this.crabcatch.width / 2, this.crabcatch.y = crab.y - 100, this.fruitcatch.x = strawberry.x - this.fruitArea.width / 2, this.fruitcatch.y = strawberry.y + 100, crab.x += crab.scale.x * this.SPEED, this.updateFruit())
            }
        },
        onHitFruit: function() {
            this.tick = 0, this.crab.gotoAndPlay("catch"), this.caughtFruit = !0, setTimeout(this.restart.bind(this), this.restartDelay), this.sound && (this.updateInView(), this.updateVolume(), this.sound.stop(), this.sound.play())
        },
        restart: function() {
            this.resetFruit(), this.crab.gotoAndPlay("walk"), this.caughtFruit = !1
        },
        updateFruit: function() {
            var t1 = this.crabcatch,
                t2 = this.fruitcatch,
                hit = this.hitTest(t1.position.x, t1.position.y, t1.width, t1.height, t2.position.x, t2.position.y, t2.width, t2.height);
            hit ? this.onHitFruit() : (this.canfall && (this.strawberry.y += this.strawBerryFallSpeed), this.tick % (60 * this.SECONDS_PER_FRUIT) === 0 && this.resetFruit())
        },
        resetFruit: function() {
            this.strawberry.y = 0 - (this.crabContainer.y + this.strawberry.height), this.canfall = !1, this.tick = 0, this.strawberry.visible = !1, setTimeout(function() {
                this.canfall = !0, this.strawberry.visible = !0
            }.bind(this), 2e3)
        },
        hitTest: function(x1, y1, w1, h1, x2, y2, w2, h2) {
            return x1 + w1 > x2 && x2 + w2 > x1 && y1 + h1 > y2 && y2 + h2 > y1 ? !0 : !1
        },
        generateSequenceFromFrames: function(start, end, pattern) {
            for (var sequence = [], frameNum = 0, frameName = null, i = start; end >= i; i++) frameNum = ("00" + (i + 1)).slice(-2), frameName = pattern + frameNum + ".png", sequence.push(PIXI.Texture.fromFrame(frameName));
            return sequence
        }
    })
}, function() {
    ! function(codeplayground) {
        "use strict";
        var ChickenPlaythingView = function(id, dispatcher) {
            codeplayground.BasePlaythingView.call(this, id, dispatcher), this.dispatcher = dispatcher, this.chicken = null, this.chickenSpeed = 1, this.chickenDirection = 1, this.chickenBounds = null, this.layTimeout = void 0, this.layDelay = 5e3, this.isLaying = !1, this.eggTypes = ["egg.png", "egg brown.png", "egg chocolate.png", "egg gold.png", "egg spotted.png"], this.eggs = [], this.eggScale = 1, this.layingTime = 2e3, this.maxEggs = codeplayground.DeviceModel().isAndroidBrowser() ? 5 : 30, this.volume = .6, this.viewObject = "chicken"
        };
        ChickenPlaythingView.prototype.initView = function(stage, worldBounds) {
            codeplayground.BasePlaythingView.prototype.initView.call(this, stage, worldBounds), this.loadAssets("/images/sprites/chicken.json"), this.loadSounds("chicken-clucking")
        }, ChickenPlaythingView.prototype.generateSequenceFromFrames = function(start, end, pattern) {
            for (var sequence = [], frameNum = 0, frameName = null, i = start; end >= i; i++) frameNum = ("00" + (i + 1)).slice(-2), frameName = pattern + frameNum + ".png", sequence.push(PIXI.Texture.fromFrame(frameName));
            return sequence
        }, ChickenPlaythingView.prototype.onAssetsLoaded = function() {
            this.container = new PIXI.DisplayObjectContainer, Object.defineProperty(this.container, "tint", {
                set: this.setTint.bind(this)
            }), this.rootDisplayObject = this.container, this.stage.addChild(this.container);
            var sequences = {
                walk: this.generateSequenceFromFrames(0, 1, "Chicken"),
                "lay-egg": this.generateSequenceFromFrames(2, 2, "Chicken")
            };
            this.chicken = new PIXI.AnimatedSprite(sequences, 12, "walk"), this.chicken.position.x = this.getCenterOffsetX(), this.chicken.position.y = window.innerHeight, this.chicken.anchor.x = .5, this.chicken.anchor.y = .9, this.chicken.scale.x *= -1, this.chicken.loop = !0, this.chicken.play(), this.container.addChild(this.chicken), this.unlock(), this.initSelect(), this.updateView(), this.notifyReady()
        }, ChickenPlaythingView.prototype.onSoundsLoaded = function() {
            this.proto.onSoundsLoaded.call(this), this.sound = this.createSound(this.tracks[0].id)
        }, ChickenPlaythingView.prototype.updateView = function(delta) {
            if (this.isReady && this.isPlaying) {
                this.chickenSpeed = this.properties.getByName("movementSpeed").value, this.isLaying || (this.isPlaying && (this.chicken.x += this.chickenSpeed * this.chickenDirection), this.chicken.y = this.chickenBounds.height, this.initLayEggAnimation()), this.chickenBounds.contains(this.chicken.x, this.chicken.y) || (this.chickenDirection *= -1, this.chicken.scale.x *= -1, this.chicken.x = Math.min(Math.max(this.chickenBounds.x + 1, this.chicken.x), this.chickenBounds.x + this.chickenBounds.width - 1));
                for (var i = 0; i < this.eggs.length; i++) {
                    var egg = this.eggs[i];
                    egg.y = this.worldBounds.height, 0 !== egg.swingTime && (egg.rotation = Math.sin(egg.swingTime) * (egg.swingTime / 30) * (Math.PI / 6), egg.swingTime -= .1, egg.swingTime < .1 && (egg.swingTime = 0))
                }
                this.updateInView(), this.updateVolume(), this.chicken.advanceTime(delta)
            }
        }, ChickenPlaythingView.prototype.initLayEggAnimation = function() {
            this.isLaying || this.layTimeout || (this.layTimeout = window.setTimeout(function() {
                this.isLaying = !0, this.layTimeout = null, this.chicken.loop = !1;
                var scale = this.properties.getByName("eggScale").value / 50;
                scale *= .9 + .2 * Math.random(), this.layEgg(scale)
            }.bind(this), 1e3 * this.properties.getByName("layingInterval").value))
        }, ChickenPlaythingView.prototype.cancelLayEggAnimation = function() {
            this.layTimeout && (window.clearTimeout(this.layTimeout), this.layTimeout = void 0, this.isLaying = !1, this.chicken.loop = !0, this.chicken.gotoAndPlay("walk"))
        }, ChickenPlaythingView.prototype.layEgg = function(eggScale) {
            var eggType = this.eggTypes[Math.floor(Math.random() * this.eggTypes.length)],
                egg = new PIXI.Sprite(PIXI.Texture.fromFrame(eggType));
            egg.anchor.x = .5, egg.anchor.y = 1, egg.x = this.chicken.x - 35 * this.chickenDirection, egg.y = this.worldBounds.height, egg.scale.x = egg.scale.y = .5 * eggScale, egg.visible = !1, egg.swingTime = 0, this.container.addChildAt(egg, this.container.getChildIndex(this.chicken)), this.eggs.push(egg), this.chicken.gotoAndPlay("lay-egg"), this.layTimeout = window.setTimeout(function(egg) {
                TweenMax.to(this.chicken, 1, {
                    y: this.worldBounds.height - egg.height
                }), TweenMax.to(this.chicken, .5, {
                    bezier: {
                        type: "soft",
                        values: [{
                            x: this.chicken.x + 2 * egg.height * this.chickenDirection,
                            y: this.chickenBounds.height - 2 * egg.height
                        }, {
                            x: this.chicken.x + 2 * egg.height * this.chickenDirection,
                            y: this.chickenBounds.height
                        }]
                    },
                    delay: 1.2,
                    onStart: function() {
                        egg.swingTime = 30, this.chicken.loop = !0, this.chicken.gotoAndPlay("walk"), this.soundsLoaded && (this.sound.stop(), this.sound.play())
                    }.bind(this),
                    onComplete: function() {
                        this.isLaying = !1, this.layTimeout = null, this.initLayEggAnimation()
                    }.bind(this)
                }), egg.visible = !0
            }.bind(this), eggScale * this.layingTime, egg), this.eggs.length > this.maxEggs && (egg = this.eggs.shift(), this.container.removeChild(egg))
        }, ChickenPlaythingView.prototype.resizeView = function(worldBounds) {
            codeplayground.BasePlaythingView.prototype.resizeView.call(this, worldBounds), this.chickenBounds = this.worldBounds
        }, ChickenPlaythingView.prototype.pause = function() {
            codeplayground.BasePlaythingView.prototype.pause.call(this), this.chicken.stop(), this.cancelLayEggAnimation()
        }, ChickenPlaythingView.prototype.resume = function() {
            codeplayground.BasePlaythingView.prototype.resume.call(this), this.chicken && (this.chicken.loop = !0, this.chicken.play())
        }, ChickenPlaythingView.prototype.hold = function() {
            codeplayground.BasePlaythingView.prototype.hold.call(this), this.isPlaying = !1, this.cancelLayEggAnimation()
        }, ChickenPlaythingView.prototype.release = function() {
            codeplayground.BasePlaythingView.prototype.release.call(this), this.isPlaying = !0
        }, ChickenPlaythingView.prototype.getWindowPostion = function() {
            var bounds = this.rootDisplayObject.getBounds();
            return bounds.x += bounds.width / 2, bounds.y += bounds.height / 2, bounds
        }, ChickenPlaythingView.prototype.setTint = function(tint) {
            this.chicken.tint = tint, this.eggs.forEach(function(egg) {
                egg.tint = tint
            })
        }, ChickenPlaythingView.prototype.reset = function() {
            this.eggs.forEach(function(egg) {
                this.container.removeChild(egg)
            }, this), this.eggs = []
        }, codeplayground.ChickenPlaythingView = ChickenPlaythingView, soma.inherit(codeplayground.BasePlaythingView, codeplayground.ChickenPlaythingView.prototype)
    }(window.codeplayground = window.codeplayground || {})
}, function() {
    ! function(codeplayground) {
        "use strict";
        var cp = codeplayground,
            SCALE = .8,
            MIN_Y = 18,
            MAX_Y = 22,
            BTN_X = 18,
            BTN_TOP = 46,
            BTN_SPACING = 34,
            CuboidControlsView = function(id, dispatcher, injector) {
                codeplayground.BasePlaythingView.call(this, id, dispatcher), this.dispatcher = dispatcher, this.injector = injector, this.body = null, this.propeller = null, this.btnPlayPause = null, this.btnMute = null, this.btnReset = null, this.btnTwitter = null, this.btnFacebook = null, this.direction = 1, this.focusedBtn = 0, this.btnTop = BTN_TOP, this.isPlaying = !0, dispatcher.addEventListener(codeplayground.events.PAUSE_ALL_PLAYTHING, function() {}.bind(this)), dispatcher.addEventListener(cp.events.VIEW_FOCUS, this.focusView.bind(this)), dispatcher.addEventListener(cp.events.ELEMENT_FOCUS, this.focusElement.bind(this)), dispatcher.addEventListener(cp.events.ELEMENT_HIT, this.hitElement.bind(this)), dispatcher.addEventListener(codeplayground.events.RESUME_ALL_PLAYTHING, function() {
                    this.btnPlayPause && this.btnPlayPause.setButtonState(codeplayground.PlayPauseButtonView.PLAY)
                }.bind(this))
            },
            proto = CuboidControlsView.prototype;
        proto.initView = function(stage, worldBounds) {
            codeplayground.BasePlaythingView.prototype.initView.call(this, stage, worldBounds);
            var assetsToLoader = ["/images/sprites/cuboid.json"],
                loader = new PIXI.AssetLoader(assetsToLoader);
            loader.onComplete = this.onAssetsLoaded.bind(this), loader.load()
        }, proto.onAssetsLoaded = function() {
            for (var propellerTextures = [], bodyTexture = null, texture = null, i = 0; 4 > i; i++) texture = PIXI.Texture.fromFrame("cuboid-ui-propeller-000" + (i + 1) + ".png"), propellerTextures.push(texture);
            bodyTexture = PIXI.Texture.fromFrame("cuboid-ui-base.png"), this.rootDisplayObject = new PIXI.DisplayObjectContainer, this.rootDisplayObject.scale.x = this.rootDisplayObject.scale.y = SCALE, this.rootDisplayObject.y = MIN_Y, this.stage.addChild(this.rootDisplayObject), this.propeller = new PIXI.MovieClip(propellerTextures), this.propeller.gotoAndPlay(1), this.propeller.animationSpeed = .5, this.rootDisplayObject.addChild(this.propeller), this.body = new PIXI.Sprite(bodyTexture), this.body.y = 12, this.rootDisplayObject.addChild(this.body), this.btnPlayPause = this.createButton({
                id: "PLAYPAUSE_BUTTON",
                view: codeplayground.PlayPauseButtonView,
                states: [{
                    id: codeplayground.PlayPauseButtonView.PLAY,
                    textures: ["button-0004.png", "button-0002.png"]
                }, {
                    id: codeplayground.PlayPauseButtonView.PAUSE,
                    textures: ["button-0010.png", "button-0007.png"]
                }]
            }), this.btnMute = this.createButton({
                id: "MUTE_BUTTON",
                view: codeplayground.MuteButtonView,
                states: [{
                    id: codeplayground.MuteButtonView.SOUND_ON,
                    textures: ["button-0009.png", "button-0006.png"]
                }, {
                    id: codeplayground.MuteButtonView.SOUND_OFF,
                    textures: ["button-0003.png", "button-0001.png"]
                }]
            }), this.btnReset = this.createButton({
                id: "RESET_BUTTON",
                text: ["reset"],
                states: [{
                    id: codeplayground.BaseButtonView.DEFAULT,
                    textures: ["button-0008.png", "button-0005.png"]
                }]
            }), this.btnFacebook = this.createButton({
                id: "FACEBOOK_BUTTON",
                text: ["facebook share"],
                states: [{
                    id: codeplayground.BaseButtonView.DEFAULT,
                    textures: ["button-0011.png", "button-0012.png"]
                }]
            }), this.btnTwitter = this.createButton({
                id: "TWITTER_BUTTON",
                text: ["twitter share"],
                states: [{
                    id: codeplayground.BaseButtonView.DEFAULT,
                    textures: ["button-0014.png", "button-0013.png"]
                }]
            }), this.buttons = [this.btnPlayPause, this.btnMute, this.btnReset, this.btnFacebook, this.btnTwitter], this.rootDisplayObject.interactive = !0, this.rootDisplayObject.mouseover = function() {
                this.dispatcher.dispatch(codeplayground.events.LOCK_VIEWPORT)
            }.bind(this), this.rootDisplayObject.mouseout = function() {
                this.dispatcher.dispatch(codeplayground.events.UNLOCK_VIEWPORT)
            }.bind(this), this.isReady = !0, this.updateView()
        }, proto.createButton = function(opts) {
            opts.view = opts.view || codeplayground.BaseButtonView;
            var btn = this.injector.createInstance(opts.view, codeplayground.BaseButtonView[opts.id]);
            return opts.text && (btn.TEXT = opts.text), btn.initView(this.rootDisplayObject), btn.rootDisplayObject.x = BTN_X, btn.rootDisplayObject.y = this.btnTop, this.btnTop += BTN_SPACING, opts.states.forEach(function(state) {
                btn.addButtonState(state.id, state.textures.map(PIXI.Texture.fromFrame))
            }), btn
        }, proto.updateView = function() {
            this.isReady && this.isPlaying && (this.rootDisplayObject.x = this.viewport.x + this.viewport.width - 100, this.rootDisplayObject.y += this.direction / 10, (this.rootDisplayObject.y > MAX_Y || this.rootDisplayObject.y < MIN_Y) && (this.direction *= -1))
        }, proto.focusView = function(event) {
            return event.params.view !== this.id ? this.unFocus() : void this.focus("Main controller. ")
        }, proto.focusElement = function(event) {
            event.params.view === this.id && (this.unFocus(), event.params.direction && (this.focusedBtn += event.params.direction, this.focusedBtn < 0 && (this.focusedBtn = this.buttons.length - 1), this.focusedBtn >= this.buttons.length && (this.focusedBtn = 0)), this.focus())
        }, proto.hitElement = function(event) {
            event.params.view === this.id && this.buttons[this.focusedBtn].onClick()
        }, proto.focus = function(message) {
            var button = this.buttons[this.focusedBtn];
            button.onMouseOver(), this.dispatcher.dispatch(cp.events.ELEMENT_FOCUSED, {
                description: (message || "") + button.getText() + " button"
            })
        }, proto.unFocus = function() {
            -1 !== this.focusedBtn && this.buttons[this.focusedBtn].onMouseOut()
        }, codeplayground.CuboidControlsView = CuboidControlsView, soma.inherit(codeplayground.BasePlaythingView, codeplayground.CuboidControlsView.prototype)
    }(window.codeplayground = window.codeplayground || {})
}, function() {
    "use strict";
    codeplayground.DanceDinoPlaythingView = codeplayground.BasePlaythingView.extend({
        PREFIX: "dance.dino.",
        MOVES: ["centre", "left", "right", "up", "down"],
        CHANGE_DELAY: 400,
        MOVE_MAP: {},
        TEXTURES: null,
        SPEED_K: 2,
        constructor: function(id, dispatcher) {
            codeplayground.BasePlaythingView.call(this, id, dispatcher), this.dino = null, this.move = 0, this.turntableData = null, this.delay = 400, this.musicIsStopped = !1, dispatcher.addEventListener(codeplayground.events.TURNTABLE_CHANGED, this.syncWithMusic.bind(this))
        },
        initView: function(stage, worldBounds) {
            codeplayground.BasePlaythingView.prototype.initView.call(this, stage, worldBounds);
            var loader = new PIXI.AssetLoader(["/images/sprites/dance-dino.json"]);
            loader.addEventListener("onComplete", this.onAssetsLoaded.bind(this)), loader.load()
        },
        onAssetsLoaded: function() {
            this.TEXTURES = this.MOVES.map(function(move, i) {
                return this.MOVE_MAP[move.slice(0, 1)] = i, PIXI.Texture.fromFrame(this.PREFIX + move + ".png")
            }, this);
            var dino = this.dino = new PIXI.Sprite(this.TEXTURES[this.move]);
            dino.anchor.x = .5, dino.anchor.y = 1, dino.x = this.getCenterOffsetX(), dino.y = this.BASE_Y = 2 * this.worldBounds.height / 3, this.rootDisplayObject = dino, this.stage.addChild(dino), this.unlock(), this.initSelect(), this.updateView(), this.notifyReady(), this.changeMode()
        },
        updateProperties: function(editable) {
            this.properties = editable, this.sequence = this.properties.getByName("sequence").value.split(""), this.isLinked = this.properties.getByName("linkWithTurntable").value, this.move = 0, this.isReady && this.changeMode()
        },
        changeMode: function() {
            if (this.changeAgain(), this.dino) {
                if (!this.isPlaying || this.isLinked && this.musicIsStopped) return void this.dino.setTexture(this.TEXTURES[0]);
                this.dino.setTexture(this.TEXTURES[this.MOVE_MAP[this.sequence[this.move]] || 0]), ++this.move >= this.sequence.length && (this.move = 0)
            }
        },
        changeAgain: function() {
            clearTimeout(this.timeoutI);
            var delay = this.isLinked ? this.delay : this.CHANGE_DELAY;
            this.timeoutI = setTimeout(this.changeMode.bind(this), delay)
        },
        syncWithMusic: function(event) {
            var adjustedPitch = .1 + .9 * Math.pow(event.params.pitch, 2);
            this.delay = this.CHANGE_DELAY / adjustedPitch, this.musicIsStopped = !event.params.playing, this.changeAgain()
        }
    })
}, function() {
    ! function(codeplayground) {
        "use strict";
        var EditorView = function(template, element, scope, dispatcher, i18n, breakpoint, deviceModel, analyticsModel, configModel) {
            this.template = template, this.element = element, this.dispatcher = dispatcher, this.scope = scope, this.i18n = i18n, this.breakpoint = breakpoint, this.deviceModel = deviceModel, this.analyticsModel = analyticsModel, this.configModel = configModel, this.slectedPlaything = null, this.editorClass = "", dispatcher.addEventListener(codeplayground.events.RENDER, function() {
                template.render()
            }), dispatcher.addEventListener(codeplayground.events.SHOW_EDITOR, function(event) {
               // this.selectedPlaything = event.params.plaything, this.updateView(this.selectedPlaything.editableProperties.properties), this.show(event.params.playthingPosition)
            }.bind(this)), dispatcher.addEventListener(codeplayground.events.HIDE_EDITOR, function(event) {
                this.updateView(null), this.hide(event)
            }.bind(this)), scope.input_onInput = function(event) {
                var input = event.target,
                    inputValue = input.value,
                    parsedValue = this.parseInput(inputValue, input.getAttribute("data-type"));
                input.value = parsedValue, this.updateProperties(), dispatcher.dispatch(codeplayground.events.PROPERTIES_CHANGED)
            }.bind(this), scope.runBtn_onClick = function() {
                this.updateProperties(), dispatcher.dispatch(codeplayground.events.PLAYTHING_UNSELECTED, {
                    playthingId: this.selectedPlaything.id
                }), this.analyticsModel.track(this.selectedPlaything.id, "Click", "Apply")
            }.bind(this), scope.resetBtn_onClick = function() {
                this.selectedPlaything.resetEditableProperties(), this.scope.editableProperties = null, this.template.render(), this.updateView(this.selectedPlaything.editableProperties.properties), this.analyticsModel.track(this.selectedPlaything.id, "Click", "Reset")
            }.bind(this), scope.closeBtn_onClick = function() {
                dispatcher.dispatch(codeplayground.events.PLAYTHING_UNSELECTED, {
                    playthingId: this.selectedPlaything.id,
                    clicked: !0
                }), this.analyticsModel.track(this.selectedPlaything.id, "Click", "Close")
            }.bind(this), this.initView()
        };
        EditorView.prototype.initView = function() {}, EditorView.prototype.updateView = function(editableProperties) {
            this.scope.playthingName = "// " + this.selectedPlaything.name, this.scope.functionName = this.i18n.translate("editor.label_function", {
                playthingName: this.selectedPlaything.name
            }), this.scope.isMobile = this.deviceModel.isMobile(), this.scope.editableProperties = editableProperties, editableProperties && this.deviceModel.isMobile() && editableProperties.forEach(function(property) {
                property.hide = property.mobileDisabled
            }), this.template.render()
        }, EditorView.prototype.parseInput = function(value, type) {
            switch (value = value.replace(new RegExp("(<(/?[^>]+)>)", "g"), ""), type.toLowerCase()) {
                case "number":
                    return value.replace(/[^\d.-]/g, "")
            }
            return value
        }, EditorView.prototype.updateProperties = function() {
            for (var properties = this.selectedPlaything.editableProperties.properties, totalProperties = properties.length, property = null, inputElement = null, inputValue = null, i = 0; totalProperties > i; i++) property = properties[i], inputElement = document.querySelector('input[data-property="' + property.name + '"]'), inputValue = inputElement.value, property.setValue(inputValue), inputValue && property.value !== inputValue;
            this.selectedPlaything.editableProperties.properties = properties, this.dispatcher.dispatch(codeplayground.events.UPDATE_PROPERTIES, {
                plaything: this.selectedPlaything
            })
        }, EditorView.prototype.show = function(position) {
            if (this.deviceModel.isMobile()) this.element.classList.remove("editor--hidden");
            else {
                for (var windowRect = new PIXI.Rectangle(0, 0, window.innerWidth, window.innerHeight), editorWidth = this.element.offsetWidth, editorHeight = this.element.offsetHeight, editorRect = null, editorRects = [new PIXI.Rectangle(position.x - editorWidth / 2, position.y - editorHeight, editorWidth, editorHeight), new PIXI.Rectangle(position.x - editorWidth / 2, position.y + position.height, editorWidth, editorHeight), new PIXI.Rectangle(position.x + position.width / 2, position.y + position.height / 2 - editorHeight / 2, editorWidth, editorHeight), new PIXI.Rectangle(position.x - editorWidth - position.width / 2, position.y + position.height / 2 - editorHeight / 2, editorWidth, editorHeight), new PIXI.Rectangle(position.x + position.width / 2, position.y - editorHeight, editorWidth, editorHeight), new PIXI.Rectangle(position.x + position.width / 2, position.y + position.height, editorWidth, editorHeight), new PIXI.Rectangle(position.x - editorWidth - position.width / 2, position.y + position.height, editorWidth, editorHeight), new PIXI.Rectangle(position.x - editorWidth - position.width / 2, position.y - editorHeight, editorWidth, editorHeight), new PIXI.Rectangle(window.innerWidth / 2 - editorWidth / 2, window.innerHeight / 2 - editorHeight / 2, editorWidth, editorHeight)], i = 0; i < editorRects.length; i++)
                    if (editorRect = editorRects[i], windowRect.containsRect(editorRect)) {
                        switch (i) {
                            case 0:
                                this.editorClass = "editor--top";
                                break;
                            case 1:
                                this.editorClass = "editor--bottom";
                                break;
                            case 2:
                                this.editorClass = "editor--right";
                                break;
                            case 3:
                                this.editorClass = "editor--left";
                                break;
                            case 4:
                                this.editorClass = "editor--top-right";
                                break;
                            case 5:
                                this.editorClass = "editor--bottom-right";
                                break;
                            case 6:
                                this.editorClass = "editor--bottom-left";
                                break;
                            case 7:
                                this.editorClass = "editor--top-left"
                        }
                        break
                    }
                editorRect && (this.element.vendorStyle("transform", "translate(" + editorRect.x + "px," + editorRect.y + "px)"), this.element.classList.remove("editor--hidden"), this.editorClass && this.element.classList.add(this.editorClass))
            }
            this.dispatcher.dispatch(codeplayground.events.LOCK_VIEWPORT)
        }, EditorView.prototype.hide = function(event) {
            this.element.classList.add("editor--hidden"), this.editorClass && this.element.classList.remove(this.editorClass), this.editorClass = "", this.dispatcher.dispatch(codeplayground.events.UNLOCK_VIEWPORT, {
                clicked: event.params && event.params.clicked
            })
        }, codeplayground.EditorView = EditorView
    }(window.codeplayground = window.codeplayground || {}, PIXI)
}, function() {
    "use strict";
    codeplayground.EyesPlaythingView = codeplayground.BasePlaythingView.extend({
        FOLLOW_FACTOR: .01,
        OFFSET_X: 180,
        OFFSET_Y: 40,
        TRAVEL: 30,
        constructor: function(id, dispatcher) {
            codeplayground.BasePlaythingView.call(this, id, dispatcher), this.stage = null, this.sprite = null, this.eyes = []
        },
        initView: function(stage, worldBounds) {
            codeplayground.BasePlaythingView.prototype.initView.call(this, stage, worldBounds);
            var loader = new PIXI.AssetLoader(["/images/sprites/eyes-base.png", "/images/sprites/eyes-pupil.png"]);
            loader.addEventListener("onComplete", this.onAssetsLoaded.bind(this)), loader.load()
        },
        resizeView: function(worldBounds) {
            this.worldBounds = worldBounds
        },
        onAssetsLoaded: function() {
            this.sprite = new PIXI.Sprite.fromImage("/images/sprites/eyes-base.png"), this.rootDisplayObject = this.sprite, this.sprite.anchor.x = this.sprite.anchor.y = .5, this.sprite.scale.x = this.sprite.scale.y = .5, this.eyes = [PIXI.Sprite.fromImage("/images/sprites/eyes-pupil.png"), PIXI.Sprite.fromImage("/images/sprites/eyes-pupil.png")], this.eyes.forEach(function(eye, i) {
                eye.x = eye.offset = i ? this.OFFSET_X : -this.OFFSET_X, eye.anchor.x = eye.anchor.y = .5, eye.tint = this.tint, eye.scale.x = eye.scale.y = this.scale, this.sprite.addChild(eye)
            }, this), this.targetX = this.sprite.x = this.getCenterOffsetX(), this.targetY = this.sprite.y = Math.random() * this.worldBounds.height, this.stage.addChild(this.sprite), this.unlock(), this.initSelect(), this.notifyReady(), this.updateView()
        },
        updateProperties: function(editable) {
            this.properties = editable, this.mode = this.properties.getByName("mode").value, this.scale = this.properties.getByName("scale").value / 100, this.tint = "0x" + utils.fn.hsvToHex(this.properties.getByName("tint").value), this.sprite && this.eyes.forEach(function(eye) {
                eye.tint = this.tint, eye.scale.x = eye.scale.y = this.scale
            }, this)
        },
        updateView: function() {
            if (this.isReady && this.isPlaying) {
                var sprite = this.sprite,
                    mPos = this.stage.stage.getMousePosition();
                1 === this.mode && -1e4 !== mPos.x ? (this.targetX = mPos.x - this.stage.x, this.targetY = mPos.y) : (this.targetX += -30 + 60 * Math.random(), this.targetY += -30 + 60 * Math.random(), this.targetX = Math.max(Math.min(this.targetX, this.worldBounds.width), 0), this.targetY = Math.max(Math.min(this.targetY, this.worldBounds.height), 0)), sprite.x += (this.targetX - sprite.x) * this.FOLLOW_FACTOR, sprite.y += (this.targetY - sprite.y) * this.FOLLOW_FACTOR;
                var spriteM = sprite.toLocal(mPos);
                this.eyes.forEach(function(eye) {
                    var mouse = {
                        x: spriteM.x - eye.offset,
                        y: spriteM.y - this.OFFSET_Y
                    }; - 1e4 === mPos.x && (mouse = {
                        x: 0,
                        y: 0
                    });
                    var angle = Math.atan2(mouse.y, mouse.x),
                        radius = this.TRAVEL;
                    Math.abs(mouse.x) < radius && Math.abs(mouse.y) < radius && (radius = Math.sqrt(Math.pow(mouse.x, 2), Math.pow(mouse.y, 2))), Math.abs(mouse.x) < radius && Math.abs(mouse.y) < radius && (radius = Math.min(Math.abs(mouse.x), Math.abs(mouse.y))), eye.x = eye.offset + Math.cos(angle) * radius, eye.y = this.OFFSET_Y + Math.sin(angle) * radius
                }, this)
            }
        }
    })
}, function() {
    "use strict";
    var CP = window.codeplayground;
    CP.FathersCTAPlaythingView = CP.BasePlaythingView.extend({
        type: "dad",
        MOVES: ["down", "vee", "right", "tee"],
        HEAD_MOVES: [{
            x: 0,
            y: 0,
            r: 0
        }, {
            x: 60,
            y: 12,
            r: -8
        }, {
            x: 27,
            y: 20,
            r: -2
        }, {
            x: -40,
            y: 13,
            r: 10
        }],
        LEG_PAD: 50,
        DELAY: 600,
        CARD_DELAY: 8e3,
        colours: {
            hair: 0,
            skin: 16631471,
            nose: 16687252,
            eyes: 7423300,
            bottom: 157589,
            top: 3250539,
            shoes: 0
        },
        constructor: function(id, dispatcher) {
            CP.BasePlaythingView.call(this, id, dispatcher), this.config = new CP.ConfigModel, this.container = null, this.scale = .25, this.cardIndex = 0, ["onRhythm", "openCard", "closeCard", "openFathersday"].forEach(function(method) {
                this[method] = this[method].bind(this)
            }, this)
        },
        initView: function() {
            CP.BasePlaythingView.prototype.initView.apply(this, arguments), this.loadAssets(["/fathersday/images/sprites/fathersday-cta.json", "/fathersday/images/sprites/dad.json"])
        },
        onAssetsLoaded: function() {
            this.container = new PIXI.DisplayObjectContainer, this.container.scale.x = this.container.scale.y = this.scale, this.rootDisplayObject = this.container, this.stage.addChild(this.container), this.cardContainer = new PIXI.DisplayObjectContainer, this.cards = this.createTextures(5, "fathersday-cta-{num}.png"), this.card = new PIXI.Sprite(this.cards[0]), this.container.addChild(this.cardContainer), this.cardContainer.addChild(this.card), this.cardContainer.scale.x = this.cardContainer.scale.y = 3, this.cardContainer.x = -330, this.cardContainer.y = -50, this.dad = new PIXI.DisplayObjectContainer, this.container.addChild(this.dad), this.shadow = PIXI.Sprite.fromFrame("dad-shadow.png"), this.dad.addChild(this.shadow), this.shoes = PIXI.Sprite.fromFrame("dad-shoes.png"), this.dad.addChild(this.shoes), this.legs = PIXI.Sprite.fromFrame("dad-legs.png"), this.dad.addChild(this.legs), this.pants = PIXI.Sprite.fromFrame("dad-pants.png"), this.dad.addChild(this.pants), this.legs.legMask = new PIXI.Graphics, this.legs.addChild(this.legs.legMask), this.legs.mask = this.legs.legMask, this.torsos = this.createTextures(4, "dad-torso-{num}.png"), this.torso = new PIXI.Sprite(this.torsos[0]), this.dad.addChild(this.torso), this.handPositions = this.createTextures(4, "dad-hands-{num}.png"), this.hands = new PIXI.Sprite(this.handPositions[0]), this.torso.addChild(this.hands), this.head = PIXI.Sprite.fromFrame("dad-head.png"), this.head.pivot.x = .5 * this.head.texture.crop.width, this.head.pivot.y = this.head.texture.crop.height, this.dad.addChild(this.head), this.face = PIXI.Sprite.fromFrame("dad-face.png"), this.head.addChild(this.face), this.nose = PIXI.Sprite.fromFrame("dad-nose.png"), this.head.addChild(this.nose), this.eyes = PIXI.Sprite.fromFrame("dad-eyes.png"), this.head.addChild(this.eyes), this.hair = new PIXI.Sprite.fromFrame("dad-hair-1.png"), this.head.addChild(this.hair), this.fullHeight = this.torso.texture.trim.height, [this.shadow, this.shoes, this.legs, this.pants, this.head, this.face, this.hair, this.eyes, this.nose].forEach(this.applyTextureTrim, this), [].concat(this.cards, this.torsos, this.handPositions).forEach(this.removeTrim), this.showTexture(this.torso, this.torsos[0]), this.showTexture(this.hands, this.handPositions[0]), this.positionFromTrim(this.card), this.legHeight = this.legs.height;
            var height = .3 * (this.legHeight - this.LEG_PAD),
                mask = this.legs.legMask;
            mask.beginFill(), mask.drawRect(0, 0, this.legs.width, this.LEG_PAD + height), mask.endFill(), this.legDiff = this.legHeight - this.LEG_PAD - height, this.shadow.y = this.shadow.origY - this.legDiff, this.shoes.y = this.shoes.origY - this.legDiff, this.unlock(), this.initSelect(), this.notifyReady(), this.updateSizeAndColour(), this.resizeView(), this.onRhythm(), this.openCard()
        },
        createTextures: function(num, name) {
            return Array.apply(0, new Array(num)).map(function(x, i) {
                return PIXI.Texture.fromFrame(name.replace("{num}", i + 1))
            }, this)
        },
        resizeView: function(worldBounds) {
            this.worldBounds = worldBounds || this.worldBounds, this.isReady && (this.container.x = this.getCenterOffsetX(), this.container.y = this.worldBounds.height / 2 - this.container.height / 2)
        },
        onRhythm: function() {
            var move = Math.floor(this.torsos.length * Math.random()),
                headPos = this.HEAD_MOVES[move];
            this.showTexture(this.torso, this.torsos[move]), this.showTexture(this.hands, this.handPositions[move]), this.head.x = this.head.origX + headPos.x + this.head.pivot.x, this.head.y = this.head.origY + headPos.y + this.head.pivot.y, this.head.rotation = headPos.r / 360 * 2 * Math.PI, this.torso.x += this.torso.pivot.x, setTimeout(this.onRhythm, this.DELAY)
        },
        updateSizeAndColour: function() {
            this.applyTint(this.colours.skin, this.head), this.applyTint(this.colours.skin, this.hands), this.applyTint(this.colours.hair, this.hair), this.applyTint(this.colours.nose, this.nose), this.applyTint(this.colours.eyes, this.eyes), this.applyTint(this.colours.bottom, this.legs), this.applyTint(this.colours.bottom, this.pants), this.applyTint(this.colours.shoes, this.shoes), this.applyTint(this.colours.top, this.torso)
        },
        showTexture: function(sprite, texture) {
            sprite && (sprite.visible = !!texture, texture && (sprite.setTexture(texture), this.positionFromTrim(sprite)))
        },
        applyTint: function(tint, sprite) {
            sprite && (sprite.tint = sprite.origTint = tint)
        },
        initSelect: function() {
            this.card.interactive = !0, this.card.mouseover = this.onOver.bind(this), this.card.mouseout = this.onOut.bind(this), this.container.click = this.openFathersday, this.container.tap = this.openFathersday
        },
        onOver: function() {
           // this.card.tint = 16711680, this.openCard()
        },
        onOut: function() {
            //this.card.tint = 16777215, this.closeCard()
        },
        openFathersday: function() {
            window.location = "/fathersday"
        },
        openCard: function() {
            return clearTimeout(this.cardTO), this.cardIndex++, this.cardIndex >= this.cards.length ? this.cardTO = setTimeout(this.closeCard, this.CARD_DELAY) : (this.showTexture(this.card, this.cards[this.cardIndex]), this.dad.visible = this.cardIndex === this.cards.length - 1, this.dad.x = 700, this.dad.y = -200, this.dad.rotation = 30 / 360 * 2 * Math.PI, this.container.addChild(this.cardContainer), void(this.cardTO = setTimeout(this.openCard, 100)))
        },
        closeCard: function() {
            clearTimeout(this.cardTO), this.cardIndex = 0, this.dad.visible = !0, this.dad.x = 0, this.dad.y = 0, this.dad.rotation = 0, this.showTexture(this.card, this.cards[this.cardIndex]), this.container.addChild(this.dad), this.cardTO = setTimeout(this.openCard, this.CARD_DELAY / 2)
        },
        applyTextureTrim: function(sprite) {
            sprite.texture && (sprite.texture.trim || sprite.texture.origTrim) && (this.positionFromTrim(sprite), sprite.origX = sprite.x, sprite.origY = sprite.y, this.removeTrim(sprite.texture), this.positionFromTrim(sprite))
        },
        positionFromTrim: function(sprite) {
            var trim = sprite.texture.trim || sprite.texture.origTrim;
            sprite.x = trim.x, sprite.y = trim.y, [this.cardContainer, this.dad].indexOf(sprite.parent) < 0 && (sprite.x -= sprite.parent.texture.origTrim.x, sprite.y -= sprite.parent.texture.origTrim.y)
        },
        removeTrim: function(texture) {
            texture.trim && (texture.frame.width = texture.crop.width, texture.frame.height = texture.crop.height, texture.origTrim = texture.trim, texture.trim = null)
        }
    })
}, function() {
    ! function(codeplayground) {
        "use strict";
        var PAD = 100,
            FishPlaythingView = function(id, dispatcher) {
                codeplayground.BasePlaythingView.call(this, id, dispatcher), this.dispatcher = dispatcher, this.fish = null, this.fishSpeed = 1, this.fishDirection = 1, this.fishBounds = null, this.impulse = 0
            };
        FishPlaythingView.prototype.initView = function(stage, worldBounds) {
            codeplayground.BasePlaythingView.prototype.initView.call(this, stage, worldBounds);
            var assetsToLoader = ["/images/sprites/fish.json", "/images/sprites/displacement-map-fish.jpg"],
                loader = new PIXI.AssetLoader(assetsToLoader);
            loader.addEventListener("onComplete", this.onAssetsLoaded.bind(this)), loader.load()
        }, FishPlaythingView.prototype.onAssetsLoaded = function() {
            for (var FishTextures = [], mod = "", i = 0; 50 > i; i++) {
                mod = 10 > i ? "0" : "";
                var texture = PIXI.Texture.fromFrame("fish0" + mod + i + ".png");
                FishTextures.push(texture)
            }
            this.fish = new PIXI.MovieClip(FishTextures), this.fish.updateTransform = codeplayground.pjsext.createUpdateTransform(this), this.fish.position.x = this.getCenterOffsetX(), this.fish.position.y = this.worldBounds.height / 3, this.fish.anchor.x = .5, this.fish.anchor.y = .5, this.fish.scale.x = this.fish.scale.y = 1, this.fish.gotoAndPlay(1), this.fish.stop(), this.fish.animationSpeed = 1, this.fish.origWidth = this.fish.width, this.stage.addChild(this.fish), this.mover();
            var displacementTexture = PIXI.Texture.fromImage("/images/sprites/displacement-map-fish.jpg");
            this.displacementShader = new PIXI.DisplacementFilter(displacementTexture), this.displacementShader.scale.x = 7, this.displacementShader.scale.y = 20, this.fish.filters = [this.displacementShader], this.rootDisplayObject = this.fish, this.pause(), this.isReady = !0, this.unlock(), this.initSelect(), this.updateView(), this.notifyReady()
        }, FishPlaythingView.prototype.updateView = function() {
            this.isReady && (this.animTarg = this.properties.getByName("frame").value - 1, this.fish.currentFrame !== this.animTarg && this.fish.gotoAndStop(this.fish.currentFrame < this.animTarg ? this.fish.currentFrame + 1 : this.fish.currentFrame - 1), this.isPlaying && (this.displacementShader.offset.y += 2, !isMoving && Math.random() > .99 && this.mover(), !this.inView && this.fish.filters ? this.fish.filters = null : this.inView && !this.fish.filters && (this.fish.filters = [this.displacementShader]), this.checkBounds()))
        }, FishPlaythingView.prototype.resizeView = function(worldBounds) {
            this.worldBounds = worldBounds, this.fishBounds = new PIXI.Rectangle(PAD, PAD, worldBounds.width - PAD, worldBounds.height - PAD), this.checkBounds()
        }, FishPlaythingView.prototype.mover = function() {
            isMoving = !0;
            var randDirection, power = 2 + 3 * Math.random();
            randDirection = this.fish.x < this.stage.width / 2 ? Math.random() > .9 ? -1 : 1 : Math.random() > .9 ? 1 : -1;
            var bounds = this.worldBounds,
                targx = this.fish.x + Math.max(200, 500 * Math.random()) * randDirection,
                targy = this.fish.y + 100 * Math.random() * (Math.random() > .5 ? 1 : -1);
            targx = Math.max(135, targx), targy = Math.min(this.worldBounds.height / 3, targy), PAD > targy && (targy = PAD), PAD > targx ? targx = PAD : targx > bounds.width - PAD && (targx = bounds.width - PAD), this.fish.x < targx ? (this.fishDirection = 1, this.fish.width = -this.fish.origWidth) : (this.fishDirection = -1, this.fish.width = this.fish.origWidth), this.newMovement(targx, targy, power)
        };
        var isMoving = !1;
        FishPlaythingView.prototype.newMovement = function(xpos, ypos, duration) {
            TweenLite.killTweensOf(this.fish), this.currentTween = TweenLite.to(this.fish, duration, {
                x: xpos,
                y: ypos,
                ease: Cubic.easeOut,
                onUpdateScope: this,
                onCompleteScope: this,
                onUpdate: function() {
                    Math.abs(xpos - this.fish.x) < 25 && (isMoving = !1, TweenLite.killTweensOf(this.fish), this.mover())
                }
            })
        }, FishPlaythingView.prototype.pause = FishPlaythingView.prototype.hold = function() {
            this.isPlaying = !1, this.currentTween && this.currentTween.pause()
        }, FishPlaythingView.prototype.resume = FishPlaythingView.prototype.release = function() {
            this.isPlaying = !0, this.currentTween && this.currentTween.resume()
        }, FishPlaythingView.prototype.checkBounds = function() {
            this.fishBounds && this.isReady && !this.fishBounds.contains(this.fish.x, this.fish.y) && (this.fish.x > this.fishBounds.width && (this.fish.x = this.fishBounds.width), this.fish.y > this.fishBounds.height && (this.fish.y = this.fishBounds.height))
        }, codeplayground.FishPlaythingView = FishPlaythingView, soma.inherit(codeplayground.BasePlaythingView, codeplayground.FishPlaythingView.prototype)
    }(window.codeplayground = window.codeplayground || {})
}, function() {
    "use strict";
    codeplayground.GiraffePlaythingView = codeplayground.BasePlaythingView.extend({
        ORIG_H: 740,
        BODY_H: 114,
        GROWTH: 10,
        SPEED_FACTOR: .25,
        BOUNCE: .9,
        HEAD_OFFSET_X: 0,
        HEAD_OFFSET_Y: 29,
        GIRAFFE_PIVOT_X: 146,
        FOOT_OFFSET_Y: 0,
        LEGS_OFFSET_X: [15, 35, 60, -20],
        LEGS_OFFSET_Y: -25,
        LEGS_PIVOT_Y: 100,
        FOOT_MIN: 5,
        NECK_PAD: 18,
        BOUNDS: {
            left: 2 / 7,
            right: 5 / 7
        },
        MAX_ANGLE: Math.PI / 12,
        constructor: function(id, dispatcher) {
            window.codeplayground.BasePlaythingView.call(this, id, dispatcher), this.giraffe = null, this.goingLeft = !0, this.neckLength = .1, this.neckHeight = 0, this.legHeight = .1, this.legLength = 0, this.cycle = 0
        },
        initView: function(stage, worldBounds) {
            codeplayground.BasePlaythingView.prototype.initView.call(this, stage, worldBounds), this.resizeView(worldBounds);
            var loader = new PIXI.AssetLoader(["/images/sprites/giraffe.json"]);
            loader.on("onComplete", this.onAssetsLoaded.bind(this)), loader.load()
        },
        onAssetsLoaded: function() {
            var giraffe = this.giraffe = new PIXI.DisplayObjectContainer;
            Object.defineProperty(this.giraffe, "tint", {
                set: this.setTint.bind(this)
            }), this.rootDisplayObject = giraffe, this.stage.addChild(giraffe);
            var body = this.body = PIXI.Sprite.fromFrame("giraffe body.png");
            giraffe.addChild(body), giraffe.x = this.getCenterOffsetX(), giraffe.y = this.bounds.height;
            var K = this.K = body.height / this.ORIG_H;
            this.BODY_HEIGHT = body.height, this.BODY_WIDTH = body.width, this.NECK_BASE = K * this.BODY_H, this.NECK_HEIGHT = this.BODY_HEIGHT - this.NECK_BASE - K * this.NECK_PAD, this.LEG_BASE = K * this.FOOT_MIN, giraffe.pivot.x = this.K * this.GIRAFFE_PIVOT_X, body.y = -this.BODY_HEIGHT;
            var neckMask = this.neckMask = new PIXI.Graphics;
            body.addChild(neckMask), body.mask = neckMask;
            var head = this.head = PIXI.Sprite.fromFrame("giraffe head.png");
            giraffe.addChild(head), head.x = K * this.HEAD_OFFSET_X, this.legs = Array.apply(0, new Array(4)).map(function(v, i) {
                var container = new PIXI.DisplayObjectContainer;
                giraffe.addChildAt(container, 0);
                var leg = container.leg = PIXI.Sprite.fromFrame("giraffe leg.png");
                container.addChild(leg), container.pivot.x = leg.width /* /2 */, container.pivot.y = container.pivot.y, container.y = K * this.LEGS_OFFSET_Y + container.pivot.y, container.x = K * this.LEGS_OFFSET_X[i] + container.pivot.x;
                var foot = container.foot = PIXI.Sprite.fromFrame("giraffe foot.png");
                container.addChild(foot);
                var mask = container.legMask = new PIXI.Graphics;
                return leg.addChild(mask), leg.mask = mask, this.LEG_WIDTH = leg.width, this.LEG_HEIGHT = leg.height + this.LEGS_OFFSET_Y - this.LEG_BASE, this.FOOT_HEIGHT = foot.height + K * this.FOOT_OFFSET_Y, container
            }, this), this.GIRAFFE_OFFSET_Y = -this.FOOT_HEIGHT - this.LEGS_OFFSET_Y, this.notifyReady(), this.unlock(), this.initSelect(), this.drawNeck(), this.adjustLegs()
        },
        updateProperties: function(editable) {
            this.properties = editable, this.targetNeck = this.properties.getByName("neckLength").value / 100, this.targetLeg = this.properties.getByName("legLength").value / 100, this.speed = this.properties.getByName("speed").value / 100, !this.isReady
        },
        updateView: function() {
            this.isReady && (this.isPlaying || this.isHolding) && (this.drawNeck(), this.adjustLegs(), this.isPlaying && (this.updateCycle(), this.rotateLegs(), this.move()))
        },
        resizeView: function(worldBounds) {
            this.worldBounds = worldBounds, this.bounds = worldBounds.clone(), this.bounds.x = worldBounds.width * this.BOUNDS.left, this.bounds.width = worldBounds.width * (this.BOUNDS.right - this.BOUNDS.left), this.isReady && (this.giraffe.y = this.bounds.height - this.legHeight + this.GIRAFFE_OFFSET_Y)
        },
        drawNeck: function() {
            var neckDelta = this.targetNeck - this.neckLength;
            if (neckDelta) {
                this.neckLength += neckDelta / this.GROWTH, Math.abs(neckDelta / this.GROWTH * this.NECK_HEIGHT) < .05 && (this.neckLength = this.targetNeck);
                var neckMask = this.neckMask;
                this.neckHeight = this.NECK_BASE + this.NECK_HEIGHT * this.neckLength, neckMask.clear(), neckMask.beginFill(), neckMask.drawRect(0, 0, this.BODY_WIDTH, this.neckHeight), neckMask.endFill(), neckMask.y = this.BODY_HEIGHT - this.neckHeight, this.head.y = this.K * this.HEAD_OFFSET_Y - this.neckHeight - this.head.height
            }
        },
        adjustLegs: function() {
            var legDelta = this.targetLeg - this.legLength;
            legDelta && (this.legLength += legDelta / this.GROWTH, Math.abs(legDelta / this.GROWTH * this.LEG_HEIGHT) < .05 && (this.legLength = this.targetLeg), this.legHeight = this.LEG_BASE + this.LEG_HEIGHT * this.legLength, this.legs.forEach(function(leg) {
                var mask = leg.legMask;
                mask.clear(), mask.beginFill(), mask.drawRect(0, 0, this.LEG_WIDTH, this.legHeight), mask.endFill(), leg.foot.y = this.legHeight + this.K * this.FOOT_OFFSET_Y
            }, this), this.giraffe.y = this.bounds.height - this.legHeight + this.GIRAFFE_OFFSET_Y)
        },
        updateCycle: function() {
            this.cycle += this.speed * this.SPEED_FACTOR, this.cycle > 2 * Math.PI && (this.cycle = this.cycle - 2 * Math.PI)
        },
        rotateLegs: function() {
            this.legs.forEach(function(leg, i) {
                var offset = i % 2 ? Math.PI : 0;
                leg.rotation = Math.sin(this.cycle + offset) * this.MAX_ANGLE
            }, this), this.giraffe.y += Math.sin(2 * this.cycle + Math.PI / 8) * this.BOUNCE * this.K * this.speed * 5
        },
        move: function() {
            var halfPI = Math.PI / 2,
                delta = Math.abs(Math.sin(this.cycle + halfPI)) * this.speed * this.legLength * 30,
                maxRight = this.bounds.x + this.bounds.width;
            this.giraffe.x += this.goingLeft ? -delta : delta, this.giraffe.x < this.bounds.x && (this.giraffe.x = this.bounds.x, this.flip()), this.giraffe.x > maxRight && (this.giraffe.x = maxRight, this.flip())
        },
        flip: function() {
            this.goingLeft = !this.goingLeft, this.giraffe.scale.x *= -1
        },
        setTint: function(tint) {
            this.body.tint = tint, this.head.tint = tint, this.legs.forEach(function(container) {
                container.leg.tint = tint, container.foot.tint = tint
            })
        }
    })
}, function() {
    ! function(codeplayground) {
        "use strict";
        var HandPlaythingView = function(id, dispatcher) {
            codeplayground.BasePlaythingView.call(this, id, dispatcher), this.dispatcher = dispatcher
        };
        HandPlaythingView.prototype.initView = function(stage, worldBounds) {
            this.proto.initView.call(this, stage, worldBounds), this.loadAssets("/images/sprites/hand.json"), this.loadSounds("tomato-squash-3")
        }, HandPlaythingView.prototype.onAssetsLoaded = function() {
            for (var HandTextures = [], mod = "", i = 0; 20 > i; i++) {
                mod = 10 > i ? "0" : "";
                var texture = PIXI.Texture.fromFrame("hand" + mod + i + ".png");
                HandTextures.push(texture)
            }
            this.Hand = new PIXI.MovieClip(HandTextures), this.Hand.updateTransform = codeplayground.pjsext.createUpdateTransform(this), this.Hand.x = this.getCenterOffsetX(), this.Hand.y = this.worldBounds.height / 2, this.Hand.anchor.x = .5, this.Hand.anchor.y = .5, this.Hand.scale.x = this.Hand.scale.y = 1, this.Hand.animationSpeed = .5, this.Hand.loop = !1, this.Hand.hitArea = new PIXI.Rectangle(-80, -115, 200, 225), this.stage.addChild(this.Hand), this.rootDisplayObject = this.Hand, this.isReady = !0, this.unlock(), this.initSelect(), this.updateView(), this.notifyReady(), this.Hand.play()
        }, HandPlaythingView.prototype.onSoundsLoaded = function() {
            this.proto.onSoundsLoaded.call(this), this.sound = this.createSound(this.tracks[0].id)
        };
        var speedmod, forward = !0,
            percentComplete = !0,
            pauseAnim = !1;
        HandPlaythingView.prototype.playRange = function(min, max) {
            if (!pauseAnim) {
                if (this.Hand.currentFrame > max && (forward = !1), percentComplete = (this.Hand.currentFrame - min) / (max - min), this.Hand.currentFrame >= 12 && max >= 12) return this.Hand.stop(), pauseAnim = !0, void this.playFinish();
                this.Hand.currentFrame <= min && (forward = !0), this.Hand.currentFrame >= max && (forward = !1), speedmod = percentComplete + .02, this.Hand.animationSpeed = forward ? speedmod : -speedmod
            }
        }, HandPlaythingView.prototype.playFinish = function() {
            var that = this,
                i = 0,
                myVar = setInterval(function() {
                    i++, that.Hand.gotoAndStop(i % 2 === 0 ? 10 : 11), i >= 30 && (clearInterval(myVar), that.Hand.animationSpeed = .5, that.Hand.onComplete = that.endGame(), that.Hand.gotoAndPlay(13))
                }, 50)
        }, HandPlaythingView.prototype.endGame = function() {
            this.sound && (this.updateInView(), this.updateVolume(), this.sound.stop(), this.sound.play()), TweenLite.to(this.Hand, 1, {
                alpha: 0,
                delay: 3
            }), TweenLite.delayedCall(4, function() {
                pauseAnim = !1, this.Hand.gotoAndPlay(1), TweenLite.to(this.Hand, 1, {
                    alpha: 1
                })
            }, null, this)
        }, HandPlaythingView.prototype.updateView = function() {
            this.isReady && this.isPlaying && (this.animTarg = Math.max(5, this.properties.getByName("frame").value / 100 * 13), 1 === this.animTarg && this.animTarg++, this.playRange(0, this.animTarg))
        }, HandPlaythingView.prototype.resizeView = function(worldBounds) {
            this.worldBounds = worldBounds, this.isReady && (this.Hand.y = worldBounds.height / 2, this.Hand.x > worldBounds.width && (this.Hand.x = worldBounds.width))
        }, codeplayground.HandPlaythingView = HandPlaythingView, soma.inherit(codeplayground.BasePlaythingView, codeplayground.HandPlaythingView.prototype)
    }(window.codeplayground = window.codeplayground || {})
}, function() {
    ! function(codeplayground) {
        "use strict";
        var SHOW_DELAY = 1e4,
            HandsView = function(id, dispatcher) {
                codeplayground.BasePlaythingView.call(this, id, dispatcher), this.dispatcher = dispatcher, this.leftHand = null, this.rightHand = null, this.handScale = .3, this.handMargin = 28, this.isAnimating = !1, dispatcher.addEventListener(codeplayground.events.INTRO_FINISHED, this.show.bind(this)), dispatcher.addEventListener(codeplayground.events.SCROLL, this.onScroll.bind(this))
            };
        HandsView.prototype.initView = function(stage, worldBounds) {
            codeplayground.BasePlaythingView.prototype.initView.call(this, stage, worldBounds), this.rootDisplayObject = new PIXI.DisplayObjectContainer, this.leftHand = new PIXI.Sprite(PIXI.Texture.fromImage("/images/sprites/pointing-hand.png")), this.leftHand.rotation = -Math.PI / 2, this.leftHand.scale.x = this.leftHand.scale.y = this.handScale, this.leftHand.x = this.viewport.x + this.handMargin, this.leftHand.y = this.viewport.height / 2, this.rightHand = new PIXI.Sprite(PIXI.Texture.fromImage("/images/sprites/pointing-hand.png")), this.rightHand.scale.x = -this.handScale, this.rightHand.scale.y = this.handScale, this.rightHand.rotation = Math.PI / 2, this.rightHand.x = this.viewport.x + this.viewport.width - this.handMargin, this.rightHand.y = this.viewport.height / 2, this.rootDisplayObject.addChild(this.leftHand), this.rootDisplayObject.addChild(this.rightHand), this.stage.addChild(this.rootDisplayObject), this.leftHand.visible = !1, this.rightHand.visible = !1, this.isReady = !0, this.updateView()
        }, HandsView.prototype.show = function() {
            if (!this.hasScrolled) {
                var onL = this.viewport.x + this.handMargin,
                    onR = this.viewport.x + this.viewport.width - this.handMargin,
                    offL = onL - 200,
                    offR = onR + 200,
                    moveL = onL - this.handMargin,
                    moveR = onR + this.handMargin;
                this.leftHand.x = offL, this.rightHand.x = offR, this.onAnimationStart(), TweenMax.to(this.leftHand, 1, {
                    x: onL,
                    ease: Quad.easeOut
                }), TweenMax.to(this.rightHand, 1, {
                    x: onR,
                    ease: Quad.easeOut
                }), TweenMax.to(this.leftHand, .5, {
                    delay: 1,
                    x: moveL,
                    yoyo: !0,
                    repeat: 3,
                    ease: Quad.easeInOut
                }), TweenMax.to(this.rightHand, .5, {
                    delay: 1,
                    x: moveR,
                    yoyo: !0,
                    repeat: 3,
                    ease: Quad.easeInOut
                }), TweenMax.to(this.leftHand, 1, {
                    delay: 3,
                    x: offL,
                    ease: Quad.easeIn
                }), TweenMax.to(this.rightHand, 1, {
                    delay: 3,
                    x: offR,
                    ease: Quad.easeIn,
                    onComplete: this.onAnimationEnd.bind(this)
                })
            }
        }, HandsView.prototype.resizeView = function() {
            this.isReady && (this.leftHand.y = this.viewport.height / 2, this.rightHand.y = this.viewport.height / 2)
        }, HandsView.prototype.onAnimationStart = function() {
            this.isAnimating = !0, this.leftHand.visible = !0, this.rightHand.visible = !0
        }, HandsView.prototype.onAnimationEnd = function() {
            this.hideHands(), this.showAgain()
        }, HandsView.prototype.hideHands = function() {
            this.isAnimating = !1, this.leftHand.visible = !1, this.rightHand.visible = !1, TweenMax.killTweensOf(this.leftHand), TweenMax.killTweensOf(this.rightHand)
        }, HandsView.prototype.showAgain = function() {
            clearTimeout(this.showTimeout), this.hasScrolled || (this.showTimeout = setTimeout(this.show.bind(this), SHOW_DELAY), this.hideHands())
        }, HandsView.prototype.onScroll = function() {
            this.hasScrolled = !0, this.hideHands()
        }, codeplayground.HandsView = HandsView, soma.inherit(codeplayground.BasePlaythingView, codeplayground.HandsView.prototype)
    }(window.codeplayground = window.codeplayground || {})
}, function() {
    "use strict";
    codeplayground.LogoPlaythingView = codeplayground.BasePlaythingView.extend({
        IMAGE_PATH: "/images/sprites/barclays-logo.png",
        SCALE: 1,
        direction: 1,
        size: 800,
        constructor: function(id, dispatcher) {
            window.codeplayground.BasePlaythingView.call(this, id, dispatcher), this.sprite = null
        },
        initView: function(stage, worldBounds) {
            codeplayground.BasePlaythingView.prototype.initView.call(this, stage, worldBounds);
            var loader = new PIXI.AssetLoader([this.IMAGE_PATH]);
            loader.on("onComplete", this.onAssetsLoaded.bind(this)), loader.load()
        },
        onAssetsLoaded: function() {
            var sprite = this.sprite = PIXI.Sprite.fromImage(this.IMAGE_PATH);
            sprite.scale.x = sprite.scale.y = this.SCALE, sprite.x = this.getCenterOffsetX(), sprite.y =0, this.stage.addChild(sprite), this.rootDisplayObject = this.sprite, this.filter = new PIXI.PixelateFilter, sprite.filters = [this.filter], this.unlock(), this.initSelect(), this.updateView(), this.notifyReady()
        },
updateProperties: function(editable) {
            this.properties = editable, this.maxPixelSize = this.properties.getByName("maxPixelSize").value, this.minPixelSize = Math.min(this.maxPixelSize, this.properties.getByName("minPixelSize").value), this.isReady && (this.rootDisplayObject.tint = 16777215, this.filter.size.x = this.filter.size.y = this.maxPixelSize)
        },
        updateView: function() {
            this.isReady && this.isPlaying && this.inView && (this.size += .25 * this.direction, this.size < this.minPixelSize ? (this.size = this.minPixelSize, this.direction = 1) : this.size > this.maxPixelSize && (this.size = this.maxPixelSize, this.direction = -1), this.filter.size.x = this.filter.size.y = this.size)
        }
    })
}, function() {
    ! function(codeplayground) {
        "use strict";
        var SCALE = .9,
            BTN_Y = 20,
            BTN_LEFT = 28,
            BTN_SPACING = 32,
            MobileCuboidControlsView = function(id, dispatcher, injector) {
                codeplayground.BasePlaythingView.call(this, id, dispatcher), this.dispatcher = dispatcher, this.injector = injector, this.body = null, this.btnPlayPause = null, this.btnMute = null, this.btnReset = null, this.btnTwitter = null, this.btnFacebook = null, this.btnLeft = BTN_LEFT, this.isPlaying = !0, dispatcher.addEventListener(codeplayground.events.INTRO_IN, function() {
                    this.rootDisplayObject && (this.rootDisplayObject.visible = !1)
                }.bind(this)), dispatcher.addEventListener(codeplayground.events.INTRO_FINISHED, function() {
                    this.rootDisplayObject && (this.rootDisplayObject.visible = !0)
                }.bind(this)), dispatcher.addEventListener(codeplayground.events.PAUSE_ALL_PLAYTHING, function() {}.bind(this)), dispatcher.addEventListener(codeplayground.events.RESUME_ALL_PLAYTHING, function() {
                    this.btnPlayPause && this.btnPlayPause.setButtonState(codeplayground.PlayPauseButtonView.PLAY)
                }.bind(this))
            };
        MobileCuboidControlsView.prototype.initView = function(stage, worldBounds) {
            codeplayground.BasePlaythingView.prototype.initView.call(this, stage, worldBounds);
            var assetsToLoader = ["/images/sprites/cuboid.json"],
                loader = new PIXI.AssetLoader(assetsToLoader);
            loader.onComplete = this.onAssetsLoaded.bind(this), loader.load()
        }, MobileCuboidControlsView.prototype.onAssetsLoaded = function() {
            var bodyTexture = PIXI.Texture.fromFrame("cuboid--mobile.png");
            this.rootDisplayObject = new PIXI.DisplayObjectContainer, this.rootDisplayObject.scale.x = this.rootDisplayObject.scale.y = SCALE, this.rootDisplayObject.visible = !1, this.stage.addChild(this.rootDisplayObject), this.body = new PIXI.Sprite(bodyTexture), this.body.scale.x = this.body.scale.y = .5, this.rootDisplayObject.addChild(this.body), this.btnPlayPause = this.createButton({
                id: "PLAYPAUSE_BUTTON",
                view: codeplayground.PlayPauseButtonView,
                states: [{
                    id: codeplayground.PlayPauseButtonView.PLAY,
                    textures: ["button-0004.png", "button-0002.png"]
                }, {
                    id: codeplayground.PlayPauseButtonView.PAUSE,
                    textures: ["button-0010.png", "button-0007.png"]
                }]
            }), this.btnMute = this.createButton({
                id: "MUTE_BUTTON",
                view: codeplayground.MuteButtonView,
                states: [{
                    id: codeplayground.MuteButtonView.SOUND_ON,
                    textures: ["button-0009.png", "button-0006.png"]
                }, {
                    id: codeplayground.MuteButtonView.SOUND_OFF,
                    textures: ["button-0003.png", "button-0001.png"]
                }]
            }), this.btnReset = this.createButton({
                id: "RESET_BUTTON",
                text: ["reset"],
                states: [{
                    id: codeplayground.BaseButtonView.DEFAULT,
                    textures: ["button-0008.png", "button-0005.png"]
                }]
            }), this.btnFacebook = this.createButton({
                id: "FACEBOOK_BUTTON",
                text: ["share"],
                rotate: !0,
                states: [{
                    id: codeplayground.BaseButtonView.DEFAULT,
                    textures: ["button-0011.png", "button-0012.png"]
                }]
            }), this.btnTwitter = this.createButton({
                id: "TWITTER_BUTTON",
                text: ["share"],
                rotate: !0,
                states: [{
                    id: codeplayground.BaseButtonView.DEFAULT,
                    textures: ["button-0014.png", "button-0013.png"]
                }]
            }), this.isReady = !0, this.updateView()
        }, MobileCuboidControlsView.prototype.createButton = function(opts) {
            opts.view = opts.view || codeplayground.BaseButtonView;
            var btn = this.injector.createInstance(opts.view, codeplayground.BaseButtonView[opts.id]);
            opts.text && (btn.TEXT = opts.text), btn.initView(this.rootDisplayObject), opts.states.forEach(function(state) {
                btn.addButtonState(state.id, state.textures.map(PIXI.Texture.fromFrame))
            });
            var root = btn.rootDisplayObject;
            return root.pivot.x = root.width / 2, root.pivot.y = root.height / 2, root.x = this.btnLeft, root.y = BTN_Y, this.btnLeft += BTN_SPACING, opts.rotate ? root.rotation = -.2 : root.scale.y = -1, btn
        }, MobileCuboidControlsView.prototype.updateView = function() {
            this.isReady && this.isPlaying && (this.rootDisplayObject.x = this.viewport.x + this.viewport.width / 2 - 85, this.rootDisplayObject.y = 0)
        }, codeplayground.MobileCuboidControlsView = MobileCuboidControlsView, soma.inherit(codeplayground.BasePlaythingView, codeplayground.MobileCuboidControlsView.prototype)
    }(window.codeplayground = window.codeplayground || {})
}, function() {
    ! function(codeplayground) {
        "use strict";
        var MonsterFacePlaythingView = function(id, dispatcher) {
            codeplayground.BasePlaythingView.call(this, id, dispatcher), this.dispatcher = dispatcher, this.MonsterFace = null, this.MonsterFaceSpeed = 1, this.MonsterFaceDirection = 1, this.MonsterFaceBounds = null, this.weirdness = .5, this.scaleMod = .7, this.numberOfTicks = 0, this.bounds = 100, this.SPEED = .5
        };
        MonsterFacePlaythingView.prototype.initView = function(stage, worldBounds) {
            codeplayground.BasePlaythingView.prototype.initView.call(this, stage, worldBounds);
            var loader = new PIXI.AssetLoader(["/images/sprites/yellow-monster.json", "/images/sprites/displacement-map.jpg"]);
            loader.addEventListener("onComplete", this.onAssetsLoaded.bind(this)), loader.load()
        }, MonsterFacePlaythingView.prototype.onAssetsLoaded = function() {
            this.container = this.rootDisplayObject = new PIXI.DisplayObjectContainer, Object.defineProperty(this.container, "tint", {
                set: this.setTint.bind(this)
            });
            var centreX = this.getCenterOffsetX();
            this.container.x = centreX, this.bounds_min = centreX - this.bounds, this.bounds_max = centreX + this.bounds, this.container.y = 50, this.stage.addChild(this.rootDisplayObject), this.sprite = PIXI.Sprite.fromFrame("yellow-monster-head.png"), this.sprite.scale.x = this.sprite.scale.y = this.scaleMod, this.sprite.anchor.x = .5, this.container.addChild(this.sprite), this.eyes = ["left", "right"].map(function(x, i) {
          var eye = PIXI.Sprite.fromFrame("yellow-monster-eye.png");
                return eye.direction = x, eye.anchor.x = eye.anchor.y = .5, eye.scale.x = eye.scale.y = this.scaleMod, eye.x = -50 + 140 * i, eye.y = 140, this.container.addChild(eye), eye
            }, this), this.updateEyes();
            var textures = Array.apply(0, new Array(5)).map(function(v, i) {
                return PIXI.Texture.fromFrame("yellow-monster-smile-" + (i + 1) + ".png")
            });
            this.mouth = new PIXI.MovieClip(textures), this.mouth.anchor.x = this.mouth.anchor.y = .5, this.mouth.x = 0, this.mouth.y = 360, this.mouth.gotoAndStop(this.mouthFrame), this.sprite.addChild(this.mouth);    
	var displacementTexture = PIXI.Texture.fromImage("/images/sprites/displacement-map.jpg");
            this.displacementShader = new PIXI.DisplacementFilter(displacementTexture), this.displacementShader.scale.x = .7, this.sprite.filters = [this.displacementShader], this.isReady = !0, this.unlock(), this.initSelect(), this.updateView(), this.notifyReady()
        }, MonsterFacePlaythingView.prototype.updateView = function() {
            this.isReady && this.isPlaying && (this.displacementShader.offset.x += this.weirdness, this.displacementShader.offset.y += this.weirdness, this.container.x += this.container.scale.x * this.SPEED, this.container.x <= this.bounds_min ? this.container.scale.x = 1 : this.container.x >= this.bounds_max && (this.container.scale.x = -1), this.updateInView(), !this.inView && this.sprite.filters ? this.sprite.filters = null : this.inView && !this.sprite.filters && (this.sprite.filters = [this.displacementShader]))
        }, MonsterFacePlaythingView.prototype.updateProperties = function(editable) {
            this.properties = editable, this.weirdness = this.properties.getByName("wibblyness").value, this.mouthFrame = this.properties.getByName("mouth").value, this.leftEye = this.properties.getByName("leftEye").value / 100, this.rightEye = this.properties.getByName("rightEye").value / 100, this.isReady && (this.updateView(), this.mouth.gotoAndStop(this.mouthFrame), this.updateEyes())
        }, MonsterFacePlaythingView.prototype.updateEyes = function() {
            TweenMax.to(this.eyes[0].scale, 1, {
                x: this.leftEye,
                y: this.leftEye,
                ease: Elastic.easeOut
            }), TweenMax.to(this.eyes[1].scale, 1, {
                x: this.rightEye,
                y: this.rightEye,
                ease: Elastic.easeOut
            })
        }, MonsterFacePlaythingView.prototype.resizeView = function(worldBounds) {
            this.MonsterFaceBounds = worldBounds
        }, MonsterFacePlaythingView.prototype.setTint = function(tint) {
            this.sprite.tint = tint
        }, codeplayground.MonsterFacePlaythingView = MonsterFacePlaythingView, soma.inherit(codeplayground.BasePlaythingView, codeplayground.MonsterFacePlaythingView.prototype)
    }(window.codeplayground = window.codeplayground || {})
}, function() {
    ! function(codeplayground) {
        "use strict";
        var MuteButtonView = function(id, dispatcher) {
            codeplayground.BaseButtonView.call(this, id, dispatcher), this.TEXT = ["mute", "unmute"]
        };
        MuteButtonView.SOUND_ON = "codeplayground.MuteButtonView.soundOn", MuteButtonView.SOUND_OFF = "codeplayground.MuteButtonView.soundOff", codeplayground.MuteButtonView = MuteButtonView, soma.inherit(codeplayground.BaseButtonView, codeplayground.MuteButtonView.prototype)
    }(window.codeplayground = window.codeplayground || {})
}, function() {
    "use strict";
    codeplayground.PencilManPlaythingView = codeplayground.BasePlaythingView.extend({
        K: .005,
        LINE_MAX: 450,
        DRAW_FRAMES: 6,
        FADE_WIDTH: 150,
        constructor: function(id, dispatcher) {
            codeplayground.BasePlaythingView.call(this, id, dispatcher), this.stage = null, this.sprite = null, this.points = [], this.headPoints = [], this.frameNum = 0, this.volume = .3
        },
        initView: function(stage, worldBounds) {
            codeplayground.BasePlaythingView.prototype.initView.call(this, stage, worldBounds), this.loadAssets("/images/sprites/pencil.json"), this.loadSounds("pencil-slow-drawing")
        },
        onAssetsLoaded: function() {
            this.container = new PIXI.DisplayObjectContainer, Object.defineProperty(this.container, "tint", {
                set: this.setTint.bind(this)
            }), this.rootDisplayObject = this.container, this.sprite = PIXI.Sprite.fromFrame("base"), this.container.addChild(this.sprite), this.tintLayer = PIXI.Sprite.fromFrame("tint"), this.sprite.addChild(this.tintLayer), this.tintLayer.tint = this.tint || 279620;
            var bounds = this.worldBounds;
            this.direction = 360 * Math.random(), this.sprite.x = this.getCenterOffsetX(), this.sprite.y = this.sprite.height + Math.random() * (bounds.height - this.sprite.height), this.sprite.anchor.x = 26 / 47, this.sprite.anchor.y = 273 / 276, this.sprite.scale.x = this.sprite.scale.y = .5 + .5 * Math.random(), this.tintLayer.x = -this.tintLayer.width * this.sprite.anchor.x, this.tintLayer.y = -this.tintLayer.height * this.sprite.anchor.y, this.head = new PIXI.Graphics, this.tail = new PIXI.Graphics, this.stage.addChild(this.container), this.isReady = !0, this.unlock(), this.initSelect(), this.updateView(), this.notifyReady()
        },
        onSoundsLoaded: function() {
            this.proto.onSoundsLoaded.call(this), this.sound = this.createSound(this.tracks[0].id), this.playSound(), this.sound.on("complete", this.playSound.bind(this))
        },
        playSound: function() {
            this.updateInView(), this.updateVolume(), this.sound.play()
        },
        updateProperties: function(editable) {
            this.properties = editable, this.curve = this.properties.getByName("curve").value * this.K, this.speed = this.properties.getByName("animationSpeed").value, this.tint = this.rgbToHex(this.properties.getByName("red").value, this.properties.getByName("green").value, this.properties.getByName("blue").value), this.isReady && (this.tintLayer.tint = this.tint)
        },
        updateView: function() {
            if (this.isReady && this.isPlaying) {
                this.direction += this.curve / Math.PI / 2;
                var deltaX = Math.cos(this.direction),
                    deltaY = Math.sin(this.direction),
                    hit = !1,
                    bounds = this.worldBounds;
                (this.sprite.x < 0 || this.sprite.x > bounds.width) && (hit = !0, this.sprite.x = this.sprite.x < 0 ? 0 : bounds.width, deltaX = -deltaX, this.direction = Math.atan2(deltaY, deltaX)*Math.random()), (this.sprite.y < 0 || this.sprite.y > bounds.height) && (hit = !0, this.sprite.y = this.sprite.y < 0 ? 0 : bounds.height, deltaY = -deltaY, this.direction = Math.atan2(deltaY, deltaX)), hit && this.points.push(this.sprite.x, this.sprite.y), this.sprite.x += deltaX * this.speed, this.sprite.y += deltaY * this.speed, (hit || this.frameNum % this.DRAW_FRAMES === 0) && (this.points.push(this.sprite.x, this.sprite.y), this.points = this.points.slice(2 * -this.LINE_MAX), this.tail.clear(), this.tail.lineStyle(20, this.tint), this.tail.moveTo.apply(this.tail, this.points.slice(0, 2)), this.tail.graphicsData[0].shape.points = this.points.slice(2), this.stage.addChildAt(this.tail, 0)), this.headPoints = this.headPoints.slice(2 * -this.DRAW_FRAMES), this.headPoints.push(this.sprite.x, this.sprite.y), this.head.clear(), this.head.lineStyle(20, this.tint), this.head.moveTo.apply(this.head, this.headPoints.slice(0, 2)), this.head.graphicsData[0].shape.points = this.headPoints.slice(2), this.stage.addChildAt(this.head, 0), this.updateInView(), this.updateVolume(), this.frameNum++
            }
        },
        updateInView: function() {
            if (this.sprite) {
                var vp = this.viewport,
                    pos = this.sprite.x,
                    vpR = vp.x + vp.width;
                if (this.inView = pos >= vp.x && vpR >= pos, this.sound) {
                    var FADE_WIDTH = this.FADE_WIDTH,
                        leftFade = pos < vp.x ? (FADE_WIDTH + pos - vp.x) / FADE_WIDTH : 0,
                        rightFade = pos > vpR ? (FADE_WIDTH + vpR - pos) / FADE_WIDTH : 0;
                    this.fadeVolume = +this.inView || Math.max(0, leftFade, rightFade)
                }
            }
        },
        setTint: function(tint) {
            this.tintLayer.tint = tint, 16777215 === tint && (this.tintLayer.tint = this.tint)
        },
        pause: function() {
            this.proto.pause.call(this), this.sound && this.sound.pause()
        },
        hold: function() {
            this.proto.hold.call(this), this.sound && this.sound.pause()
        },
        resume: function() {
            this.proto.resume.call(this), this.sound && this.isPlaying && this.sound.play()
        },
        release: function() {
            this.proto.release.call(this), this.sound && this.isPlaying && this.sound.play()
        },
        pcToHex: function(pc) {
            var hex = Math.round(pc / 100 * 255).toString(16);
            return 1 === hex.length ? "0" + hex : hex
        },
        rgbToHex: function(r, g, b) {
            return "0x" + this.pcToHex(r) + this.pcToHex(g) + this.pcToHex(b)
        },
        reset: function() {
            this.headPoints = [], this.points = []
        }
    })
}, function() {
    ! function(codeplayground) {
        "use strict";
        var instanceCount = 0,
            PlaneView = function(id, dispatcher, i18n, analyticsModel) {
                codeplayground.BasePlaythingView.call(this, id, dispatcher), this.instanceID = instanceCount++, this.dispatcher = dispatcher, this.i18n = i18n, this.analyticsModel = analyticsModel, this.plane = null, this.planeBanner = null, this.planeBody = null, this.planeSpeed = 3, this.planeDirection = -1, this.planeBounds = null, this.planeAngle = 0, this.startX = 0, this.startY = 0, this.dispatcher.addEventListener(codeplayground.events.RESUME_ALL_PLAYTHING, this.resume.bind(this)), this.dispatcher.addEventListener(codeplayground.events.PAUSE_ALL_PLAYTHING, this.pause.bind(this))
            };
        PlaneView.prototype.initView = function(stage, worldBounds) {
            codeplayground.BasePlaythingView.prototype.initView.call(this, stage, worldBounds);
            var assetsToLoader = ["/images/sprites/plane.json"],
                loader = new PIXI.AssetLoader(assetsToLoader);
            loader.onComplete = this.onAssetsLoaded.bind(this), loader.load()
        }, PlaneView.prototype.onAssetsLoaded = function() {
            this.plane = new PIXI.DisplayObjectContainer, Object.defineProperty(this.plane, "tint", {
                set: this.setTint.bind(this)
            }), this.plane.position.x = this.startX, this.plane.position.y = this.startY;
            var alt = this.instanceID ? "-alt" : "";
            this.planeBanner = new PIXI.Sprite(PIXI.Texture.fromFrame("plane-banner" + alt + ".png")), this.planeBanner.anchor.x = .5, this.planeBanner.x = 382, this.planeBanner.y = -6, this.plane.addChild(this.planeBanner), this.planeBody = new PIXI.Sprite(PIXI.Texture.fromFrame("plane-body.png")), this.plane.addChild(this.planeBody), this.stage.addChildAt(this.plane, 0), this.rootDisplayObject = this.plane;
            var displacementTexture = PIXI.Texture.fromImage("/images/sprites/displacement-map-fish.jpg");
            this.displacementShader = new PIXI.DisplacementFilter(displacementTexture), this.displacementShader.scale.x = 1, this.displacementShader.scale.y = 10, this.planeBanner.filters = [this.displacementShader], this.rootDisplayObject.interactive = !0, this.rootDisplayObject.buttonMode = !0, Modernizr.touch ? this.rootDisplayObject.tap = function() {
                this.dispatcher.dispatch(codeplayground.events.SHOW_INFO, {
                    sectionId: 2
                }), this.analyticsModel.track("PlaneView", "Click", "Book_session")
            }.bind(this) : (this.rootDisplayObject.mouseover = function() {
                this.onOver()
            }.bind(this), this.rootDisplayObject.mouseout = function() {
                this.onOut()
            }.bind(this), this.rootDisplayObject.click = function() {
                this.dispatcher.dispatch(codeplayground.events.SHOW_INFO, {
                    sectionId: 1
                }), this.analyticsModel.track("PlaneView", "Click", "Book_session")
            }.bind(this)), this.isReady = !0, this.updateView()
        }, PlaneView.prototype.initPosition = function(x, y) {
            this.startX = x, this.startY = y
        }, PlaneView.prototype.updateView = function() {
            if (this.isReady && this.isPlaying) {
                this.planeAngle += .01;
                var plane = this.plane,
                    dir = this.planeDirection;
                this.isPlaying && (plane.x += this.planeSpeed * this.planeDirection, plane.y = this.startY + 50 * Math.sin(this.planeAngle)), -1 === dir && plane.x + plane.width < this.viewport.x ? (this.planeDirection = 1, plane.scale.x = -1, this.planeBanner.scale.x = -1) : 1 === dir && plane.x + plane.width > this.viewport.x + this.viewport.width && (this.planeDirection = -1, plane.scale.x = 1, this.planeBanner.scale.x = 1)
            }
        }, PlaneView.prototype.setTint = function(tint) {
            this.planeBody.tint = tint
        }, codeplayground.PlaneView = PlaneView, soma.inherit(codeplayground.BasePlaythingView, codeplayground.PlaneView.prototype)
    }(window.codeplayground = window.codeplayground || {})
}, function() {
    ! function(codeplayground) {
        "use strict";
        var PlayPauseButtonView = function(id, dispatcher) {
            codeplayground.BaseButtonView.call(this, id, dispatcher), this.TEXT = ["pause", "play"]
        };
        PlayPauseButtonView.PLAY = "codeplayground.PlayPauseButtonView.play", PlayPauseButtonView.PAUSE = "codeplayground.PlayPauseButtonView.pause", codeplayground.PlayPauseButtonView = PlayPauseButtonView, soma.inherit(codeplayground.BaseButtonView, codeplayground.PlayPauseButtonView.prototype)
    }(window.codeplayground = window.codeplayground || {})
}, function() {
    "use strict";
    codeplayground.RainbowPlaythingView = codeplayground.BasePlaythingView.extend({
        SPEED: .02,
        FADE_SPEEED: .002,
        THICKNESS: 70,
        RAINBOW_STEP: .05,
        ROTATION_INIT: -Math.PI,
        BOUNDS_L: 3 / 7,
        COLOURS: [16711680, 16757824, 16711424, 6878283, 5983220, 11553780],
	constructor: function(id, dispatcher) {
            codeplayground.BasePlaythingView.call(this, id, dispatcher), this.dispatcher = dispatcher, this.stage = null, this.sprite = null, this.rainbows = [], this.rotation = -Math.PI, this.radius = 100, this.thickness = this.THICKNESS / this.COLOURS.length, this.direction = 1, this.offestY = 0
        },
        initView: function(stage, worldBounds) {
            this.proto.initView.call(this, stage, worldBounds), this.loadAssets("/images/sprites/boot.png")
        },
        onAssetsLoaded: function() {
            this.container = this.rootDisplayObject = new PIXI.DisplayObjectContainer, Object.defineProperty(this.container, "tint", {
                set: this.setTint.bind(this)
            }), this.stage.addChild(this.container), this.sprite = PIXI.Sprite.fromImage("/images/sprites/boot.png"), this.container.addChild(this.sprite), this.sprite.anchor.x = .3, this.sprite.anchor.y = .5, this.sprite.scale.x = this.sprite.scale.y = .5, this.offestY = this.sprite.width / 2, this.x = this.getCenterOffsetX(), this.y = this.worldBounds.height + this.offestY, this.unlock(), this.initSelect(), this.notifyReady(), this.resizeView(this.worldBounds)
        },
         updateProperties: function(editable) {
            this.properties = editable;
            var oldRadius = this.radius;
            if (this.radius = this.properties.getByName("radius").value, this.speed = this.SPEED * this.properties.getByName("speed").value / 10, this.isReady) {
                this.radius !== oldRadius && (this.x += (this.radius - oldRadius) * this.direction);
                var oldRainbow = this.rainbow;
                this.container.removeChild(oldRainbow), this.makeRainbow(), this.updateBurgerPos(), oldRainbow && (this.rainbow.rotation = oldRainbow.rotation)
            }
        },
	resizeView: function(bounds) {
            this.worldBounds = bounds, this.isReady && (this.y = bounds.height + this.offestY, this.rainbows.forEach(function(rainbow) {
                rainbow.y = this.y
            }, this), this.rainbow && (this.rainbow.y = this.y))
        },
        updateView: function() {
            this.isReady && this.isPlaying && (this.rainbow || this.makeRainbow(), (this.rotation > 0 || this.rotation < -2 * Math.PI) && this.finishRainbow(), this.rotation += this.direction * this.speed, this.rainbow.rotation = this.rotation + (this.direction < 0 ? Math.PI : 0), this.updateBurgerPos(), this.rainbows.forEach(this.fadeRainbow, this))
        },
        updateBurgerPos: function() {
            var point = this.pointFromRadius(this.currentRadius);
            this.sprite.x = this.x + point.x, this.sprite.y = this.y + point.y, this.sprite.rotation = this.rotation + Math.PI / 2 * this.direction
        },
        pointFromRadius: function(radius, rot) {
            var rotation = void 0 !== rot ? rot : this.rotation;
            return rotation += this.direction < 0 ? Math.PI : 0, {
                x: radius * Math.cos(rotation),
                y: radius * Math.sin(rotation)
            }
        },
        makeRainbow: function() {
            var rainbow = this.rainbow = new PIXI.DisplayObjectContainer;
            rainbow.x = this.x, rainbow.y = this.y, rainbow.arcs = [], rainbow.rotation = this.ROTATION_INIT, this.container.addChildAt(rainbow, 0), this.currentRadius = this.radius * (.95 + Math.random() * -.1), this.COLOURS.forEach(function(colour, i) {
                var arc = new PIXI.Graphics,
                    radius = this.currentRadius + .5 * this.thickness - this.thickness * i,
                    point = this.pointFromRadius(radius, this.ROTATION_INIT);
                arc.lineStyle(this.thickness, colour, 1), arc.moveTo(-radius * this.direction, 0), rainbow.arcs.push(arc);
                for (var r = rainbow.rotation; 0 >= r; r += this.RAINBOW_STEP) point = this.pointFromRadius(radius, r), arc.lineTo(point.x, point.y);
                rainbow.addChild(arc)
            }, this), rainbow.hitArea = new PIXI.Circle(0, 0, this.currentRadius + .5 * this.thickness)
        },
        finishRainbow: function() {
            this.rotation = this.ROTATION_INIT;
            var radius = this.currentRadius,
                delta = 2 * radius - this.THICKNESS / 2;
            this.x += this.direction * delta;
            var boundsR = this.worldBounds.width,
                boundsL = this.BOUNDS_L * boundsR;
            (this.x + radius > boundsR + radius || this.x - radius < boundsL) && (this.direction *= -1, this.sprite.scale.x *= -1, this.x += 2 * radius * Math.random() * this.direction), this.rainbows.push(this.rainbow), this.makeRainbow()
        },
        fadeRainbow: function(rainbow, i, rainbows) {
            rainbow.alpha -= this.FADE_SPEEED * this.speed / this.SPEED, rainbow.alpha < .01 && (this.container.removeChild(rainbow), this.removeFromArray(rainbow, rainbows))
        },
        setTint: function(tint) {
            this.rainbows.concat(this.rainbow || []).forEach(function(rainbow) {
                rainbow.arcs.forEach(function(arc) {
                    arc.tint = tint
                })
            }), this.sprite.tint = tint
        },
        reset: function() {
            this.rainbows.forEach(function(rainbow) {
                this.container.removeChild(rainbow)
            }, this), this.rainbows = []
        }
    })
}, function() {
    "use strict";
    codeplayground.RocketmanPlaythingView = codeplayground.BasePlaythingView.extend({
        FRAMES: [
            ["stop", 2],
            ["walk", 4],
            ["jump", 2],
            ["turn", 2]
        ],
        S_MAP: {
            s: "stop",
            w: "walk",
            j: "jump",
            t: "turn"
        },
        SPEED: 3,
        PIVOT_X: 100,
        CHANGE_DELAY: 2e3,
        TURN_TIME: 200,
        BASE_Y: null,
        JUMP_OFFSET: -80,
        sPointer: 0,
        constructor: function(id, dispatcher) {
            codeplayground.BasePlaythingView.call(this, id, dispatcher), this.rocketman = null, this.volume = .3
        },
        initView: function(stage, worldBounds) {
            codeplayground.BasePlaythingView.prototype.initView.call(this, stage, worldBounds), this.loadSounds("rocket-launch-5"), this.loadAssets("/images/sprites/rocketman.json")
        },
        onAssetsLoaded: function() {
            var sequences = this.sequencesFromFrames(this.FRAMES),
                rocketman = this.rocketman = new PIXI.AnimatedSprite(sequences, 7, "stop");
            rocketman.anchor.x = this.PIVOT_X / rocketman.width, rocketman.anchor.y = 1, rocketman.x = this.getCenterOffsetX(), rocketman.y = this.BASE_Y = 2 * this.worldBounds.height / 3, rocketman.loop = !0, this.rootDisplayObject = rocketman, this.stage.addChild(rocketman), this.changeMode(), this.unlock(), this.initSelect(), this.updateView(), this.notifyReady()
        },
        onSoundsLoaded: function() {
            this.proto.onSoundsLoaded.call(this), this.sound = this.createSound(this.tracks[0].id)
        },
        updateProperties: function(editable) {
            this.properties = editable, this.sequence = this.properties.getByName("sequence").value.split(""), this.sPointer = 0
        },
        updateView: function(delta) {
            if (this.isReady && this.isPlaying) {
                var rocket = this.rocketman;
                (rocket.x <= 0 || rocket.x >= this.worldBounds.width) && (rocket.scale.x *= -1), "s" !== this.mode && (rocket.x += rocket.scale.x * this.SPEED), "j" === this.mode && this.updateInView(), this.rocketman.advanceTime(delta)
            }
        },
        changeMode: function() {
            if (clearTimeout(this.timeoutI), !this.isPlaying) return void(this.timeoutI = setTimeout(this.changeMode.bind(this), this.CHANGE_DELAY));
            var rocket = this.rocketman,
                delay = this.CHANGE_DELAY,
                oldMode = this.mode;
            this.mode = this.sanitise(this.sequence[this.sPointer]), rocket.gotoAndPlay(this.S_MAP[this.mode]), rocket.y = this.BASE_Y + ("j" === this.mode ? this.JUMP_OFFSET : 0), "t" === this.mode && (delay = this.TURN_TIME), "t" === oldMode && (rocket.scale.x *= -1), "j" === this.mode && this.sound && (this.updateVolume(), this.sound.stop(), this.sound.play()), ++this.sPointer >= this.sequence.length && (this.sPointer = 0), this.timeoutI = setTimeout(this.changeMode.bind(this), delay)
        },
        pause: function() {
            codeplayground.BasePlaythingView.prototype.pause.call(this), this.rocketman.playing = this.isPlaying = !1
        },
        resume: function() {
            codeplayground.BasePlaythingView.prototype.resume.call(this), this.isPlaying = !0, this.rocketman && (this.rocketman.playing = !0)
        },
        sequencesFromFrames: function(data) {
            var sequences = {};
            return data.forEach(function(data) {
                var name = data[0],
                    length = data[1],
                    sequence = Array.apply(0, new Array(length)).map(function(v, i) {
                        return PIXI.Texture.fromFrame("rocketman." + name + "." + (i + 1) + ".png")
                    });
                sequences[name] = sequence
            }), sequences
        },
        sanitise: function(mode) {
            return mode = mode.toLowerCase(), this.S_MAP[mode] && mode || "s"
        }
    })
}, function() {
    "use strict";
    codeplayground.SheepPlaythingView = codeplayground.BasePlaythingView.extend({
        BROADCAST_SKIP: 5,
        EAT_CYCLES: 300,
        PIVOT_X: 100,
        OFFSET_Y: 120,
        BOUNDS_R: 3 / 7,
        BLADE_HEIGHT: 150,
        BLADE_SPACING: 12,
        GROWTH_CONSTANT: 1e4,
        MAX_TUFTS: codeplayground.DeviceModel().isAndroidBrowser() ? 10 : 100,
        BLADE_ADJ: [{
            off: .7,
            rot: .5,
            seq: 0
        }, {
            off: .3,
            rot: .2,
            seq: 2
        }, {
            off: .1,
            rot: .2,
            seq: 4
        }, {
            off: .2,
            rot: -.2,
            seq: 6
        }, {
            off: 0,
            rot: -.2,
            seq: 7
        }, {
            off: .4,
            rot: -.2,
            seq: 5
        }, {
            off: .6,
            rot: -.5,
            seq: 3
        }, {
            off: .8,
            rot: -.8,
            seq: 1
        }],
        EAT_ORDER: [0, 7, 1, 6, 2, 5, 3, 4],
        constructor: function(id, dispatcher) {
            codeplayground.BasePlaythingView.call(this, id, dispatcher), this.sheep = null, this.sheepSpeed = 1, this.sheepDirection = 1, this.sheepBounds = null, this.cycle = 0, this.volume = 1.3, this.grass = null, this.tufts = [], this.growing = [], this.eating = []
        },
        initView: function(stage, worldBounds) {
            codeplayground.BasePlaythingView.prototype.initView.call(this, stage, worldBounds), this.resizeView(worldBounds), this.loadSounds("sheep-eating"), this.loadAssets(["/images/sprites/sheep.json", "/images/sprites/grass.json"])
        },
        generateSequenceFromFrames: function(start, end) {
            return Array.apply(0, new Array(end - start + 1)).map(function(v, i) {
                var frame = start + 1 + i;
                return PIXI.Texture.fromFrame("sheep " + frame + ".png")
            })
        },
        onAssetsLoaded: function() {
            var grass = this.grass = new PIXI.DisplayObjectContainer;
            Object.defineProperty(this.grass, "tint", {
                set: this.setTint.bind(this)
            }), this.rootDisplayObject = grass, this.stage.addChild(grass);
            var bounds = this.grassBounds;
            grass.x = 0, grass.y = bounds.height, this.createTuft();
            var sequences = {
                idle: this.generateSequenceFromFrames(0, 0, "sheep "),
                walk: this.generateSequenceFromFrames(1, 4, "sheep "),
                eat: this.generateSequenceFromFrames(5, 9, "sheep ")
            };
            this.sheep = new PIXI.AnimatedSprite(sequences, 12, "idle"), this.sheep.anchor.x = this.PIVOT_X / this.sheep.width, this.sheep.anchor.y = 1, this.sheep.x = this.getCenterOffsetX(), this.sheep.loop = !0, this.sheep.gotoAndPlay("walk"), this.grass.addChild(this.sheep), this.unlock(), this.initSelect(), this.updateView(), this.notifyReady()
        },
        onSoundsLoaded: function() {
            this.proto.onSoundsLoaded.call(this), this.sound = this.createSound(this.tracks[0].id)
        },
        updateProperties: function(editable) {
            this.properties = editable, this.sheepSpeed = this.properties.getByName("eatingSpeed").value, this.bladeCount = this.properties.getByName("blades").value, this.growthRate = this.properties.getByName("growthRate").value / this.GROWTH_CONSTANT, this.size = this.properties.getByName("thickness").value / this.BLADE_HEIGHT
        },
        updateView: function(delta) {
            if (this.isReady && (this.adjustExisting(), this.isPlaying)) {
                if (this.grow(), this.eat(), this.cycle++, "walk" === this.sheep.currentSequence) {
                    this.sheep.x -= this.sheepSpeed * this.sheepDirection, this.cycle % this.BROADCAST_SKIP === 0 && this.checkSheepPos();
                    var bounds = this.sheepBounds;
                    (this.sheep.x < bounds.x || this.sheep.x > bounds.x + bounds.width) && (this.sheep.x = this.sheep.x < bounds.x ? 0 : bounds.x + bounds.width, this.sheepDirection *= -1, this.sheep.scale.x *= -1)
                }
                "eat" === this.sheep.currentSequence && this.cycle >= this.EAT_CYCLES && (this.cycle = 0, this.sheep.gotoAndPlay("walk")), this.sheep.advanceTime(delta)
            }
        },
        eatGrass: function() {
            this.cycle = 0, this.sheep.gotoAndPlay("eat"), this.sound && (this.updateInView(), this.updateVolume(), this.sound.stop(), this.sound.play())
        },
        resizeView: function(worldBounds) {
            this.grassBounds = worldBounds, this.sheepBounds = this.worldBounds = worldBounds.clone(), this.sheepBounds.width *= this.BOUNDS_R, this.isReady && (this.grass.y = worldBounds.height)
        },
        adjustExisting: function() {
            var bladesDelta = this.prevBlades - this.blades,
                sizeDelta = this.prevSize - this.size;
            (bladesDelta || !sizeDelta) && this.tufts.forEach(function(tuft) {
                tuft.blades.forEach(this.growBlade, this)
            }, this)
        },
        grow: function() {
            this.growing.slice().forEach(function(tuft) {
                tuft.growth += this.growthRate, tuft.growth > 1 && (tuft.growth = 1, this.removeFromArray(tuft, this.growing), this.tufts.push(tuft), this.createTuft()), tuft.blades.forEach(this.growBlade, this)
            }, this), this.tufts.length > this.MAX_TUFTS && this.grass.removeChild(this.tufts.shift())
        },
        eat: function() {
            this.eating.slice().forEach(function(tuft) {
                if (tuft.eatCycles = tuft.eatCycles || this.EAT_CYCLES, !--tuft.eatCycles) return this.grass.removeChild(tuft), void this.removeFromArray(tuft, this.eating);
                var hideIndex = Math.floor(tuft.eatCycles / this.EAT_CYCLES * tuft.blades.length);
                tuft.blades[this.EAT_ORDER[hideIndex]].visible = !1
            }, this)
        },
        createTuft: function() {
            var tuft = new PIXI.DisplayObjectContainer;
            tuft.growth = 0, tuft.x = Math.random() * this.grassBounds.width * this.BOUNDS_R, tuft.scaleK = .5 * Math.random() + .5, this.grass.addChildAt(tuft, 0), tuft.blades = Array.apply(0, new Array(8)).map(function(v, i) {
                var blade = PIXI.Sprite.fromFrame("grass-blade-x.png".replace("x", i + 1));
                return blade.tuft = tuft, tuft.addChild(blade), blade.x = i * this.BLADE_SPACING, blade.y = 0, blade.pivot.y = blade.height - 5, this.BLADE_ADJ[i].rot > 0 ? blade.pivot.x = blade.width : blade.x -= this.BLADE_SPACING, blade.scale.y = 0, blade
            }, this), this.growing.push(tuft)
        },
        growBlade: function(blade, i) {
            var adj = this.BLADE_ADJ[i],
                tuft = blade.tuft;
            if (!(tuft.growth < adj.off)) {
                var growth = 1 - 1 / (1 - adj.off) + tuft.growth / (1 - adj.off);
                blade.scale.y = this.size * growth * tuft.scaleK, blade.scale.x = .5 + .5 * growth, blade.rotation = adj.rot * (1 - growth), blade.visible = tuft.blades.length - this.bladeCount <= adj.seq
            }
        },
        checkSheepPos: function() {
            var pos = this.sheep.x,
                found = !1;
            this.tufts.concat(this.growing).forEach(function(tuft) {
                pos < tuft.x || pos > tuft.x + tuft.width || (this.removeFromArray(tuft, this.growing) && this.createTuft(), this.removeFromArray(tuft, this.tufts), this.eating.push(tuft), found = !0)
            }, this), found && this.eatGrass()
        },
        setTint: function(tint) {
            this.sheep.tint = tint, this.tufts.concat(this.growing, this.eating).forEach(function(tuft) {
                tuft.blades.forEach(function(blade) {
                    blade.tint = tint
                })
            })
        },
        reset: function() {
            this.tufts.concat(this.growing).concat(this.eating).forEach(function(tuft) {
                this.grass.removeChild(tuft)
            }, this), this.tufts = [], this.growing = [], this.eating = []
        },
        pause: function() {
            codeplayground.BasePlaythingView.prototype.pause.call(this), this.sheep.stop()
        },
        resume: function() {
            codeplayground.BasePlaythingView.prototype.resume.call(this), this.sheep && (this.sheep.loop = !0, this.sheep.play())
        },
        hold: function() {
            codeplayground.BasePlaythingView.prototype.hold.call(this), this.isPlaying = !1
        },
        release: function() {
            codeplayground.BasePlaythingView.prototype.release.call(this), this.isPlaying = !0
        }
    })
}, function() {
    "use strict";
    codeplayground.SplatsPlaythingView = codeplayground.BasePlaythingView.extend({
        COLOURS: ["mint", "pink", "yellow", "aqua", "orange"],
        COLOUR_MAP: null,
        FREQUENCY_K: 1e3,
        MAX_SPLATS: 10,
        SCALE_INC: .1,
        FADE_INC: .1,
        constructor: function(id, dispatcher) {
            codeplayground.BasePlaythingView.call(this, id, dispatcher), this.container = null, this.splats = [], this.splatting = [], this.disappearing = [], this.volume = .3;
            var colourMap = this.COLOUR_MAP = {};
            this.COLOURS.forEach(function(colour, i) {
                colourMap[colour] = i + 1
            })
        },
        initView: function(stage, worldBounds) {
            codeplayground.BasePlaythingView.prototype.initView.call(this, stage, worldBounds), this.viewObject = "currentSplat", this.loadAssets("/images/sprites/splats.json"), this.loadSounds("boing-4")
        },
        onAssetsLoaded: function() {
            this.container = this.rootDisplayObject = new PIXI.DisplayObjectContainer, Object.defineProperty(this.container, "tint", {
                set: this.setTint.bind(this)
            }), this.stage.addChild(this.container), this.notifyReady(), this.unlock(), this.initSelect(), this.updateView(), this.resetCycle()
        },
        onSoundsLoaded: function() {
            this.proto.onSoundsLoaded.call(this), this.sound = this.createSound(this.tracks[0].id)
        },
        updateProperties: function(editable) {
            this.properties = editable, this.minSize = this.properties.getByName("minSize").value / 100, this.maxSize = Math.max(this.minSize, this.properties.getByName("maxSize").value / 100), this.frequency = this.properties.getByName("frequency").value, this.colour = this.properties.getByName("colour").value
        },
        updateView: function() {
            this.isReady && this.isPlaying && (this.fireSplat(), this.splatSplats(), this.disappearSplats())
        },
        fireSplat: function() {
            if (this.cycle++, !(this.cycle < this.nextSplat)) {
                var length = this.COLOURS.length,
                    colourOffset = this.COLOUR_MAP[this.colour] || 1,
                    index = Math.floor(Math.random()) * length + colourOffset;
                "random" === this.colour && (index = Math.ceil(Math.random() * length * 2));
                var splat = new PIXI.Sprite.fromFrame("splats " + index + ".png");
                splat.x = Math.random() * this.worldBounds.width, splat.y = Math.random() * this.worldBounds.height, splat.pivot.x = splat.width / 2, splat.pivot.y = splat.height / 2, splat.rotation = Math.random() * Math.PI * 2;
                var range = this.maxSize - this.minSize;
                splat.targetScale = this.minSize + Math.random() * range, splat.scale.x = splat.scale.y = 0, this.splats.push(splat), this.splatting.push(splat), this.container.addChildAt(splat, 0), this.currentSplat = splat, this.splats.length > this.MAX_SPLATS && this.disappearing.push(this.splats.shift());
                var vp = this.viewport,
                    l = splat.x - splat.width / 2,
                    r = splat.x + splat.width / 2,
                    inView = l >= vp.x && l <= vp.x + vp.width || r >= vp.x && r <= vp.x + vp.width;
                inView && this.soundsLoaded && (this.updateVolume(this.sound, 1), this.sound.stop(), this.sound.play()), this.resetCycle()
            }
        },
        splatSplats: function() {
            this.splatting.slice().forEach(function(splat) {
                splat.scale.x = splat.scale.y += this.SCALE_INC, splat.scale.x < splat.targetScale || (splat.scale.x = splat.scale.y = splat.targetScale, this.removeFromArray(splat, this.splatting))
            }, this)
        },
        disappearSplats: function() {
            this.disappearing.slice().forEach(function(splat) {
                splat.y += 5, splat.alpha -= this.FADE_INC, splat.alpha <= 0 && (this.container.removeChild(splat), this.removeFromArray(splat, this.disappearing))
            }, this)
        },
        resetCycle: function() {
            this.cycle = 0, this.nextSplat = Math.floor(this.FREQUENCY_K / this.frequency)
        },
        setTint: function(tint) {
            this.splats.concat(this.splatting, this.disappearing).forEach(function(splat) {
                splat.tint = tint
            })
        },
        reset: function() {
            this.splats.concat(this.splatting).concat(this.disappearing).forEach(function(splat) {
                this.container.removeChild(splat)
            }, this), this.splats = [], this.splatting = [], this.disappearing = []
        }
    })
}, function() {
    "use strict";
    codeplayground.ToasterPlaythingView = codeplayground.BasePlaythingView.extend({
        SPEED_FACTOR: .1,
        arr_toast: [],
        tick: 0,
        arr_toasters: [],
        toaster_xpos: 66,
        toaster_ypos: 56,
        toasterAltitude: 160,
        constructor: function(id, dispatcher) {
            window.codeplayground.BasePlaythingView.call(this, id, dispatcher), this.toasterContainer = null
        },
        initView: function(stage, worldBounds) {
            codeplayground.BasePlaythingView.prototype.initView.call(this, stage, worldBounds), this.loadAssets("/images/sprites/toaster.json"), this.loadSounds("toaster-2")
        },
        onAssetsLoaded: function() {
            var toasterContainer = this.toasterContainer = new PIXI.DisplayObjectContainer;
            Object.defineProperty(toasterContainer, "tint", {
                set: this.setTint.bind(this)
            }), this.rootDisplayObject = toasterContainer, this.stage.addChild(toasterContainer), toasterContainer.x = this.getCenterOffsetX(), toasterContainer.y = this.worldBounds.height - this.toasterAltitude, this.checkNumToasters(), this.notifyReady(), this.unlock(), this.initSelect(), this.updateView()
        },
        onSoundsLoaded: function() {
            this.proto.onSoundsLoaded.call(this), this.sound = this.createSound(this.tracks[0].id)
        },
        createToaster: function() {
            var toasterObj = {},
                toaster = new PIXI.DisplayObjectContainer;
            toaster.main_body = PIXI.Sprite.fromFrame("toaster.png"), toaster.addChild(toaster.main_body);
            var handle1 = PIXI.Sprite.fromFrame("handle.png");
            toaster.addChild(handle1), handle1.x = 114, handle1.y = 200;
            var handle2 = PIXI.Sprite.fromFrame("handle.png");
            toaster.addChild(handle2), handle2.x = 179, handle2.y = 164, toasterObj.handle1 = handle1, toasterObj.handle2 = handle2, toaster.alpha = 0, this.toasterContainer.addChildAt(toaster, 0), TweenMax.to(toaster, .5, {
                alpha: 1
            }), toasterObj.mc = toaster, toasterObj.arr_toast = [], toasterObj.tick = 1, toasterObj.canPop = !0, this.createToast(toasterObj, 1), this.createToast(toasterObj, 1), this.createToast(toasterObj, 1), this.createToast(toasterObj, 1), toasterObj.toaster = toaster, this.arr_toasters.push(toasterObj), toaster.x = -this.toaster_xpos + this.toaster_xpos * this.arr_toasters.length, toaster.y = -this.toaster_ypos - this.toaster_ypos * this.arr_toasters.length
        },
        createToast: function(toaster, offset) {
            var targ = toaster.mc,
                toast = PIXI.Sprite.fromFrame("toast.png"),
                toast_dark = PIXI.Sprite.fromFrame("toast.png");
            targ.addChild(toast), toast.addChild(toast_dark), toast_dark.tint = 0, toast_dark.alpha = 0;
            var offsetX = 40 * offset-100,
                offsetY = 20 * offset-260;
            toast.x = 40 + offsetX, toast.y = 54 - offsetY;
	    var masker = new PIXI.Graphics;
	    targ.addChild(masker), masker.beginFill("0x" + Math.random().toString(16).substr(-6), 1), masker.moveTo(40 + offsetX, -1e3 - offsetY-50), masker.lineTo(240 + offsetX, -1e3 - offsetY-50), masker.lineTo(240 + offsetX, 54 - offsetY), masker.lineTo(40 + offsetX, 54 - offsetY), masker.lineTo(40 + offsetX, -1e3 - offsetY), toast.mask = masker, toaster.arr_toast.push({
                toast: toast,
                shad: toast_dark
            })
        },
        updateProperties: function(editable) {
            this.properties = editable, this.toasttime = 2e3 + 50 * this.properties.getByName("toastTime").value, this.toasterpower = this.properties.getByName("toasterPower").value / 50, this.numToasters = this.properties.getByName("numToasters").value, this.isReady && this.checkNumToasters()
        },
        updateView: function() {
            this.isReady && this.isPlaying && (this.tick++, this.updateToasters())
        },
        checkNumToasters: function() {
            var i;
            if (this.numToasters > this.arr_toasters.length) {
                var totalNew = this.numToasters - this.arr_toasters.length;
                for (i = 0; totalNew > i; i++) this.createToaster()
            }
            for (i = 0; i < this.arr_toasters.length; i++) this.arr_toasters[i].mc.visible = i < this.numToasters
        },
        resetToast: function(t) {
            t.alpha = 0
        },
        updateToasters: function() {
            this.arr_toasters.forEach(function(targ) {
                targ.mc.visible && (targ.tick++, targ.arr_toast.forEach(function(toast) {
                    toast.shad.alpha += .0000
                }), targ.tick % (60 * this.toasttime / 1e3) === 0 && (targ.tick = 0, targ.jumptime = Math.max(.8, this.toasterpower / 2), targ.arr_toast.forEach(function(toast) {
                    TweenMax.to(toast.toast, targ.jumptime, {
                        y: -(400 * this.toasterpower) + 30 * Math.random(),
                        delay: .1 + Math.random() / 4,
                        repeat: 1,
                        ease: Cubic.easeOut,
                        yoyo: !0,
                        onComplete: this.resetToast,
                        onCompleteParams: [toast.shad]
                    })
                }, this), TweenMax.to(targ.handle1, .05, {
                    delay: .4,
                    y: 110
                }), TweenMax.to(targ.handle1, 1, {
                    delay: .7,
                    y: 200,
                    ease: Quad.easeInOut
                }), TweenMax.to(targ.handle2, .05, {
                    delay: .1,
                    y: 74 
                }), TweenMax.to(targ.handle2, 1, {
                    delay: .7,
                    y: 164,
                    ease: Quad.easeInOut
                }), this.updateInView(), this.sound && (this.updateVolume(), this.sound.stop(), this.sound.play())))
            }, this)
        },
        resizeView: function(bounds) {
            this.worldBounds = bounds, this.isReady && (this.toasterContainer.y = this.worldBounds.height - this.toasterAltitude)
        },
        setTint: function(tint) {
            this.arr_toasters.forEach(function(toaster) {
               // toaster.mc.main_body.tint = tint, toaster.handle1.tint = tint, toaster.handle2.tint = tint
            })
        },
        updateInView: function() {
            if (this.isReady && this.viewport) {
                var vp = this.viewport,
                    toaster = this.toasterContainer,
                    l = toaster.x,
                    r = toaster.x + toaster.width,
                    vpL = vp.x,
                    vpR = vp.x + vp.width;
                if (this.inView = l >= vpL && vpR >= l || r >= vpL && vpR >= r, this.sound) {
                    var FADE_WIDTH = this.FADE_WIDTH,
                        leftFade = vpL > r ? (FADE_WIDTH + r - vpL) / FADE_WIDTH : 0,
                        rightFade = l > vpR ? (FADE_WIDTH + vpR - l) / FADE_WIDTH : 0;
                    this.fadeVolume = +this.inView || Math.max(0, leftFade, rightFade)
                }
            }
        }
    })
}, function() {
    "use strict";
    codeplayground.TurntablePlaythingView = codeplayground.BasePlaythingView.extend({
        SLIDE_INCREMENT: .02,
        RANGE_X: 28,
        RANGE_Y: 17.5,
        constructor: function(id, dispatcher) {
            codeplayground.BasePlaythingView.call(this, id, dispatcher), this.sprite = null, this.volume = .3
        },
        initView: function(stage, worldBounds) {
            codeplayground.BasePlaythingView.prototype.initView.call(this, stage, worldBounds), this.loadAssets("/images/sprites/turntable.json")
        },
        initSounds: function() {
            this.loadSounds(["turntable-1", "turntable-2"])
        },
        onAssetsLoaded: function() {
            for (var frames = [], i = 1; 4 >= i; i++) frames[i - 1] = "turntable.base." + i + ".png";
            var sprite = this.sprite = PIXI.MovieClip.fromFrames(frames);
            for (sprite.animationSpeed = .2, this.rootDisplayObject = sprite, sprite.x = this.getCenterOffsetX(), sprite.y = this.BASE_Y = 2 * this.worldBounds.height / 3 - this.sprite.height, frames = [], i = 1; 2 >= i; i++) frames[i - 1] = "turntable.button." + i + ".png";
            var button = this.button = PIXI.MovieClip.fromFrames(frames);
            sprite.addChild(this.button), this.slider = PIXI.Sprite.fromFrame("turntable.slider.png"), sprite.addChild(this.slider), this.pitch = 0, sprite.interactive = !0, sprite.click = sprite.touch = this.notifySelected.bind(this), button.click = button.touch = this.notifySelected.bind(this), this.stage.addChild(sprite), this.unlock(), this.initSelect(), this.updateView(), this.updateChildren(), this.notifyReady(), this.initSounds()
        },
        updateProperties: function(editable) {
            this.properties = editable, this.targetPitch = 1.01 + this.properties.getByName("pitch").value / 100, this.playing = this.properties.getByName("playing").value, this.track = this.properties.getByName("track").value, this.notifyChange(), this.isReady && this.updateChildren()
        },
        updateView: function() {
            if (this.isReady && this.isPlaying && this.targetPitch !== this.pitch) {
                var slideIncrement = this.SLIDE_INCREMENT;
                this.pitch += this.targetPitch > this.pitch ? slideIncrement : -slideIncrement, Math.abs(this.targetPitch - this.pitch) < slideIncrement && (this.pitch = this.targetPitch), this.updatePitch(), this.slider.x = this.RANGE_X * (this.pitch - 1), this.slider.y = -this.RANGE_Y * (this.pitch - 1)
            }
        },
        pause: function() {
            codeplayground.BasePlaythingView.prototype.pause.call(this), this.sprite.stop(), this.sound && this.sound.pause()
        },
        resume: function() {
            codeplayground.BasePlaythingView.prototype.resume.call(this), this.playing && (this.sound && this.sound.play(), this.sprite.loop = !0, this.sprite.play())
        },
        updateChildren: function() {
            if (this.isReady) {
                if (this.currentTrack !== this.track) {
                    this.sound && this.sound.stop();
                    var info = this.tracks[this.track];
                    this.sound = this.createSound(info.id, this.playing), this.updateVolume(), this.updatePitch(), this.sound.addEventListener("complete", function() {
                        this.sound.play(), this.updatePitch()
                    }.bind(this)), this.currentTrack = this.track
                }
                this.lastPlaying !== this.playing && (this.playing ? (this.sprite.play(), this.sound && this.sound.play()) : (this.sprite.stop(), this.sound && this.sound.pause()), this.button.gotoAndStop(+this.playing), this.lastPlaying = this.playing)
            }
        },
        updatePitch: function() {
            var playbackRate = this.access("sound.sourceNode.playbackRate", this);
            playbackRate && (playbackRate.value = this.pitch), this.notifyChange()
        },
        notifyChange: function() {
            this.dispatcher.dispatch(codeplayground.events.TURNTABLE_CHANGED, {
                playing: this.playing,
                pitch: this.pitch - .01
            })
        },
        access: function(string, context) {
            return string.split(".").reduce(function(context, param) {
                return context && context[param]
            }, context)
        }
    })
}, function() {
    "use strict";
    codeplayground.WindowPlaythingView = codeplayground.BasePlaythingView.extend({
        CURTAIN_EASE: .1,
        EYE_STATES: ["middle", "closed", "left", "right"],
        STATE_MAP: null,
        CURTAIN_OFFSET_X: -5,
        CURTAIN_OFFSET_Y: -5,
        BLINK_FREQ: 300,
        BLINK_FRAMES: 2,
        SOUND_MIN: 1e3,
        SOUND_MAX: 8e3,
        constructor: function(id, dispatcher) {
            codeplayground.BasePlaythingView.call(this, id, dispatcher), this.container = null, this.curtainOpeness = 0, this.updateBlink(), this.volume = .4;
            var stateMap = this.STATE_MAP = {};
            this.EYE_STATES.forEach(function(state, i) {
                stateMap[state] = i
            })
        },
        initView: function(stage, worldBounds) {
            this.proto.initView.call(this, stage, worldBounds), this.loadAssets(["/images/sprites/curtain.json", "/images/sprites/cat.json"]), this.loadSounds("cat-meow-4-high")
        },
        onAssetsLoaded: function() {
            var frames, i, container = this.container = new PIXI.DisplayObjectContainer;
            Object.defineProperty(container, "tint", {
                set: this.setTint.bind(this)
            }), this.rootDisplayObject = container, this.stage.addChild(container), container.addChild(new PIXI.Sprite.fromFrame("picture.png"));
            var eyeFrames = function(direction) {
                return function(state) {
                    return direction + " eye " + state + ".png"
                }
            };
            for (this.eyes = ["left", "right"].map(function(direction) {
                    frames = this.EYE_STATES.map(eyeFrames(direction));
                    var eye = new PIXI.MovieClip.fromFrames(frames);
                    return eye.direction = direction, container.addChild(eye), eye
                }, this), frames = [], i = 0; 60 > i; i++) frames[i] = "curtain " + i + ".png";
            var curtains = this.curtains = new PIXI.MovieClip.fromFrames(frames);
            curtains.x = this.CURTAIN_OFFSET_X, curtains.y = this.CURTAIN_OFFSET_Y, container.addChild(curtains);
            var bounds = this.worldBounds;
            this.container.x = this.getCenterOffsetX(), this.container.y = .3 * (bounds.height - container.height), this.notifyReady(), this.unlock(), this.initSelect(), this.updateView(), this.moveEyes()
        },
        onSoundsLoaded: function() {
            this.proto.onSoundsLoaded.call(this), this.sound = this.createSound(this.tracks[0].id), this.sound.on("complete", this.playAgain.bind(this)), this.playAgain()
        },
        playAgain: function() {
            var delay = this.SOUND_MIN + Math.random() * (this.SOUND_MAX - this.SOUND_MIN);
            setTimeout(this.playSound.bind(this), delay)
        },
        playSound: function() {
            this.updateInView(), this.updateVolume(), this.sound.play()
        },
        updateProperties: function(editable) {
            this.properties = editable, this.leftEye = this.properties.getByName("leftEye").value, this.rightEye = this.properties.getByName("rightEye").value, this.targetOpeness = this.properties.getByName("curtainOpeness").value / 100, this.isReady && this.moveEyes()
        },
        updateView: function() {
            this.isReady && (this.openCurtain(), this.isPlaying && this.blinkEyes())
        },
        resizeView: function(worldBounds) {
            this.worldBounds = worldBounds, !this.isReady
        },
        openCurtain: function() {
            var delta = this.targetOpeness - this.curtainOpeness;
            if (delta) {
                var lastFrame = this.curtains.totalFrames - 1;
                this.curtainOpeness += delta * this.CURTAIN_EASE, Math.abs(delta * lastFrame) < .5 && (this.curtainOpeness = this.targetOpeness), this.curtains.gotoAndStop(Math.round(this.curtainOpeness * lastFrame))
            }
        },
        moveEyes: function() {
            this.eyes.forEach(function(eye) {
                var eyeState = this[eye.direction + "Eye"];
                eye.gotoAndStop("undefined" == typeof eyeState || "random" === eyeState ? Math.floor(Math.random() * this.EYE_STATES.length) : this.STATE_MAP[eyeState])
            }, this)
        },
        blinkEyes: function() {
            "closed" !== this.leftEye && "closed" !== this.rightEye && (this.blinkFrame++, this.blinkFrame < this.nextBlink || (this.eyes.forEach(function(eye) {
                eye.gotoAndStop(this.STATE_MAP.closed)
            }, this), this.updateBlink()))
        },
        updateBlink: function() {
            this.blinkFrame < this.nextOpen || (this.blinkFrame = 0, this.nextBlink = 1 + Math.floor(this.BLINK_FREQ * Math.random()), this.nextOpen = this.nextBlink + this.BLINK_FRAMES, this.isReady && this.moveEyes())
        },
        setTint: function(tint) {
            this.curtains.tint = tint
        }
    })
}, , , , function(module) {
    module.exports = {
        playthings: [{
            id: "Splats",
            name: "Splats",
            viewClass: "SplatsPlaythingView",
            enabled: !0,
            mobileEnabled: !0,
            zIndex: "10",
            editable: [{
                name: "maxSize",
                type: "Integer",
                min: 0,
                max: 100,
                size: 3,
                value: 100,
                description: "Choose the biggest size splat with a number from 1 to 100."
            }, {
                name: "minSize",
                type: "Integer",
                min: 0,
                max: 100,
                size: 3,
                value: 10,
                description: "Choose the smallest size splat with a number from 1 to 100."
            }, {
                name: "frequency",
                type: "Number",
                min: 1,
                max: 200,
                size: 3,
                value: 60,
                description: "Change how often the splats are fired: choose from 0 to 200."
            }, {
                name: "colour",
                type: "String",
                size: 6,
                value: "random",
                description: "Change the splat colour: type 'random', 'mint', 'pink', 'aqua' or 'orange'."
            }]
        }, {
            id: "GrassAndSheep",
            name: "GrassAndSheep",
            viewClass: "SheepPlaythingView",
            enabled: !0,
            mobileEnabled: !0,
            androidMobile: !0,
            zIndex: "40",
            centerOffsetX: "-20%",
            editable: [{
                name: "eatingSpeed",
                type: "Number",
                size: 3,
                value: 10,
                min: 1,
                max: 100,
                description: "Make the sheep eat the grass faster: enter a number from 1 to 100."
            }, {
                name: "blades",
                type: "Integer",
                min: 1,
                max: 8,
                size: 2,
                value: 8,
                description: "Choose how much grass: enter a number from 1 to 8."
            }, {
                name: "growthRate",
                type: "Number",
                min: 0,
                max: 100,
                size: 3,
                value: 60,
                description: "Speed up the growth: enter a number from 0 to 100."
            }, {
                name: "thickness",
                type: "Number",
                min: 0,
                max: 200,
                size: 3,
                value: 200,
                description: "Make the grass grow taller: enter a number from 0 to 200."
            }]
        }, {
            id: "Window",
            name: "WindowCat",
            viewClass: "WindowPlaythingView",
            enabled: !0,
            mobileEnabled: !0,
            zIndex: "20",
            centerOffsetX: "38%",
            editable: [{
                name: "curtainOpeness",
                type: "Number",
                min: 0,
                max: 100,
                size: 3,
                value: 100,
                description: "Open or close the curtains: type a number from 0 to 100"
            }, {
                name: "leftEye",
                type: "String",
                size: 6,
                value: "random",
                description: "Change which way the catâ€™s left eye looks: type 'left', 'right', 'middle' or 'random'."
            }, {
                name: "rightEye",
                type: "String",
                size: 6,
                value: "random",
                description: "Change which way the catâ€™s right eye looks: type 'left', 'right', 'middle' or 'random'."
            }]
        }, {
            id: "Logo",
            name: "Cotuit, Massachusetts",
            viewClass: "LogoPlaythingView",
            enabled: !0,
            mobileEnabled: !0,
            zIndex: "12",
            centerOffsetX: "-11%",
            needsWebGL: !0,
            editable: [{
                name: "minPixelSize",
                type: "Integer",
                min: 1,
                max: 100,
                size: 3,
                value: 1,
                description: "Change the quality of the logo with a minimum pixel size from 1 to 100. (The smaller the better!)"
            }, {
                name: "maxPixelSize",
                type: "Integer",
                min: 1,
                max: 3,
                size: 3,
                value: 1,
                description: "Change the pixelation of the logo with a maximum size from 1 to 100. (Bigger pixels mean lower quality!)"
            }]
        }, {
            id: "DanceDino",
            name: "DanceDino",
            viewClass: "DanceDinoPlaythingView",
            enabled: !0,
            mobileEnabled: !0,
            zIndex: "100",
            centerOffsetX: "12%",
            editable: [{
                name: "sequence",
                type: "String",
                size: 15,
                value: "ucdcucdclcrclcrc",
                description: "Program how Dino dances. Type a sequence using â€˜câ€™ (centre), â€˜uâ€™ (up), â€˜dâ€™ (down), â€˜râ€™ (right) and â€˜lâ€™ (left)"
            }, {
                name: "linkWithTurntable",
                type: "Boolean",
                size: 5,
                value: !1,
                description: "Link to the turntable music. 'true' or 'false'",
                mobileDisabled: !0
            }]
        }, {
            id: "Rocketman",
            name: "Rocketman",
            viewClass: "RocketmanPlaythingView",
            enabled: !0,
            mobileEnabled: !0,
            zIndex: "30",
            centerOffsetX: "-15%",
            editable: [{
                name: "sequence",
                type: "String",
                size: 10,
                value: "wwjts",
                description: "Program what the Rocketman does. Type a sequence using â€˜wâ€™ (walk), â€˜sâ€™ (stop), â€˜tâ€™ (turn) and â€˜jâ€™ (jump)"
            }]
        }, {
            id: "CatchyCrab",
            name: "CatchyCrab",
            viewClass: "CatchyCrabPlaythingView",
            enabled: !0,
            mobileEnabled: !0,
            zIndex: "30",
            centerOffsetX: "5%",
            editable: [{
                name: "walkingspeed",
                type: "Number",
                min: 0,
                max: 100,
                size: 3,
                value: 10,
                description: "How fast should the crab walk? Try a number from 0 to 100."
            }]
        }, {
            id: "BucketMonster",
            name: "BucketMonster",
            viewClass: "BucketMonsterPlaythingView",
            enabled: !1,
            mobileEnabled: !1,
            zIndex: "10",
            centerOffsetX: "32%",
            editable: [{
                name: "tilt",
                type: "Number",
                size: 3,
                min: 0,
                max: 100,
                value: 50,
                description: "Control how much the bucket tips over with a number from 1 to 100. Careful - it could spill!"
            }, {
                name: "red",
                type: "Number",
                size: 3,
                min: 0,
                max: 100,
                value: 0,
                description: "Give the monster a colour. Add more red with a number between 0 and 100."
            }, {
                name: "green",
                type: "Number",
                size: 3,
                min: 0,
                max: 100,
                value: 50,
                description: "Add more green with a number between 0 and 100."
            }, {
                name: "blue",
                type: "Number",
                size: 3,
                min: 0,
                max: 100,
                value: 90,
                description: "Add more blue with a number from 0 to 100."
            }]
        }, {
            id: "Chicken",
            name: "Chicken",
            viewClass: "ChickenPlaythingView",
            enabled: !0,
            mobileEnabled: !0,
            androidMobile: !0,
            zIndex: "80",
            centerOffsetX: "-13%",
            editable: [{
                name: "movementSpeed",
                type: "Number",
                size: 3,
                value: 10,
                min: 1,
                max: 100,
                description: "Make her walk faster: enter a number from 1 to 100."
            }, {
                name: "eggScale",
                type: "Number",
                size: 3,
                value: 80,
                min: 1,
                max: 100,
                description: "Change the size of her eggs: enter a number from 1 to 100."
            }, {
                name: "layingInterval",
                type: "Number",
                size: 3,
                value: 10,
                min: 1,
                max: 100,
                description: "Change how often she lays an egg: enter a number from 1 to 100."
            }]
        }, {
            id: "Toaster",
            name: "Toaster",
            viewClass: "ToasterPlaythingView",
            enabled: !0,
            mobileEnabled: !0,
            zIndex: "10",
            centerOffsetX: "-28%",
            editable: [{
                name: "toastTime",
                type: "Number",
                size: 3,
                value: 0,
                min: 0,
                max: 100,
                description: "how brown do you want your toast? Enter a number from 1 to 100."
            }, {
                name: "numToasters",
                type: "Number",
                size: 3,
                value: 1,
                min: 1,
                max: 5,
                description: "Set the number of toasters from 1 to 5."
            }, {
                name: "toasterPower",
                type: "Number",
                size: 3,
                value: 50,
                min: 0,
                max: 100,
                description: "Make the toast jump high: enter a height from 1 to 100."
            }]
        }, {
            id: "Fish",
            name: "Fish",
            viewClass: "FishPlaythingView",
            enabled: !0,
            mobileEnabled: !0,
            androidMobile: !0,
            needsWebGL: !0,
            zIndex: "120",
            centerOffsetX: "-25%",
            editable: [{
                name: "frame",
                type: "Integer",
                size: 3,
                value: 35,
                min: 1,
                max: 50,
                description: "Choose how many scales the fish has: type a number from 1 to 50."
            }]
        }, {
            id: "Hand",
            name: "Hand",
            viewClass: "HandPlaythingView",
            enabled: !0,
            mobileEnabled: !0,
            androidMobile: !0,
            zIndex: "10",
            centerOffsetX: "-36%",
            editable: [{
                name: "frame",
                type: "Number",
                size: 3,
                value: 40,
                min: 0,
                max: 100,
                description: "Squeeze the tomato less or more: choose a number from 1 - 100."
            }]
        }, {
            id: "FlyingMan",
            name: "FlyingMan",
            viewClass: "FlyingmanPlaythingView",
            enabled: !0,
            mobileEnabled: !0,
            androidMobile: !0,
            zIndex: "130",
            centerOffsetX: "-25%",
            editable: [{
                name: "flapSpeed",
                type: "Number",
                size: 3,
                value: 50,
                min: 1,
                max: 100,
                description: "Change how much he flaps his wings: choose a number from 1 to 100."
            }]
        }, {
            id: "MonsterFace",
            name: "MonsterFace",
            viewClass: "MonsterFacePlaythingView",
            enabled: !0,
            mobileEnabled: !0,
            androidMobile: !0,
            needsWebGL: !0,
            zIndex: "20",
            centerOffsetX: "-41%",
            editable: [{
                name: "wibblyness",
                type: "Number",
                size: 3,
                value: .5,
                min: 0,
                max: 5,
                description: "Change the wibblyness of the MonsterFace: Pick a number from 0 to 5."
            }, {
                name: "mouth",
                type: "Integer",
                size: 3,
                value: 0,
                min: 0,
                max: 3,
                description: "Choose a mouth by entering a number from 0 to 3."
            }, {
                name: "leftEye",
                type: "Number",
                size: 3,
                value: 20,
                min: 1,
                max: 100,
                description: "How big should his left eye be? Enter a number from 1 to 100"
            }, {
                name: "rightEye",
                type: "Number",
                size: 3,
                value: 80,
                min: 1,
                max: 100,
                description: "How big should his right eye be? Enter a number from 1 to 100"
            }]
        }, {
            id: "Balls",
            name: "BouncingBalls",
            viewClass: "BallsPlaythingView",
            enabled: !0,
            mobileEnabled: !0,
            androidMobile: !0,
            zIndex: "50",
            editable: [{
                name: "numOfBalls",
                type: "Int",
                size: 1,
                min: 0,
                max: 6,
                value: 4,
                description: "Add or take away balls: choose a number from 0 to 6."
            }, {
                name: "gravity",
                type: "Number",
                min: 0,
                max: 10,
                value: .9,
                size: 4,
                description: "Choose how far they bounce: from 0 to 10 metres"
            }, {
                name: "elasticity",
                type: "Number",
                min: 0,
                max: 2,
                value: .95,
                size: 4,
                description: "Change the bounciness of the balls: choose from 0 to 2"
            }]
        }, {
            id: "Eyes",
            name: "Eyes",
            viewClass: "EyesPlaythingView",
            enabled: !0,
            mobileEnabled: !0,
            androidMobile: !0,
            zIndex: "90",
            centerOffsetX: "50%",
            editable: [{
                name: "mode",
                type: "Integer",
                size: 1,
                min: 1,
                max: 2,
                value: 2,
                description: "Move the eyes: type â€˜1â€™ to follow the mouse, â€˜2â€™ to travel independently.",
                mobileDisabled: !0
            }, {
                name: "tint",
                type: "Integer",
                size: 3,
                min: 0,
                max: 360,
                value: 70,
                description: "Change the colour of the eyes: pick a number from 0 to 360."
            }, {
                name: "scale",
                type: "Number",
                min: 1,
                max: 200,
                value: 100,
                size: 3,
                description: "Change the size of the iris: type a number from 1 to 200."
            }]
        }, {
            id: "Rainbow",
            name: "RainbowBoot",
            viewClass: "RainbowPlaythingView",
            enabled: !0,
            mobileEnabled: !0,
            zIndex: "0",
            centerOffsetX: "8%",
            editable: [{
                name: "radius",
                type: "Integer",
                size: 3,
                min: 100,
                max: 1e3,
                value: 350,
                description: "Change the size of the rainbow: choose from 100 to 1000."
            }, {
                name: "speed",
                type: "Integer",
                size: 3,
                min: 1,
                max: 100,
                value: 10,
                description: "Change the speed of the boot: choose from 1 to 100."
            }]
        }, {
            id: "Turntable",
            name: "Turntable",
            viewClass: "TurntablePlaythingView",
            enabled: !0,
            mobileEnabled: !0,
            requiresSound: !0,
            zIndex: "20",
            centerOffsetX: "14%",
            editable: [{
                name: "track",
                type: "Integer",
                size: 1,
                min: 0,
                max: 1,
                value: 0,
                description: "Play a tune: type either â€˜0â€™ or â€˜1â€™."
            }, {
                name: "pitch",
                type: "Integer",
                size: 4,
                min: -100,
                max: 100,
                value: 0,
                description: "Change the speed with a number from -100 to 100."
            }, {
                name: "playing",
                type: "Boolean",
                size: 5,
                value: !1,
                description: "Type 'true' to play, or 'false' to stop the record."
            }]
        }, {
            id: "Giraffe",
            name: "Giraffe",
            viewClass: "GiraffePlaythingView",
            enabled: !0,
       // <!-- 4th Screen --><img aria-hidden=true class=img-tag src="http://ads.admarvel.com/fam/conversions.php?partner_id=3939de5680fdd652&site_id=37449&tracking_id=1188367" height=1 width=1>       
            mobileEnabled: !0,
            zIndex: "70",
            centerOffsetX: "-13%",
            editable: [{
                name: "neckLength",
                type: "Integer",
                min: 0,
                max: 100,
                value: 50,
                size: 3,
                description: "Make the giraffeâ€™s neck long or short: type from 1 to 100"
            }, {
                name: "legLength",
                type: "Integer",
                min: 0,
                max: 100,
                value: 100,
                size: 3,
                description: "Change the length of the giraffe's legs: type any number from 0 to 100."
            }, {
                name: "speed",
                type: "Integer",
                min: 1,
                max: 100,
                value: 100,
                size: 3,
                description: "Speed up or slow down the giraffe: choose from 1 to 100."
            }]
        }, {
            id: "PencilMan",
            name: "LittlePencil",
            viewClass: "PencilManPlaythingView",
            enabled: !1,
            mobileEnabled: !1,
            androidMobile: !1,
            zIndex: "20",
            centerOffsetX: "-3%",
            editable: [{
                name: "animationSpeed",
                type: "Number",
                size: 3,
                min: .1,
                max: 100,
                value: 5,
                description: "Change how fast the pencil moves: add a number from 0.1 to 100."
            }, {
                name: "curve",
                type: "Integer",
                size: 3,
                min: -50,
                max: 50,
                value: 13,
                description: "Change the curve of the drawing: enter a number from -50 to 50."
            }, {
                name: "red",
                type: "Number",
                size: 3,
                min: 0,
                max: 100,
                value: 0,
                description: "Change the pencilâ€™s colour. Add more red with a number between 0 and 100."
            }, {
                name: "green",
                type: "Number",
                size: 3,
                min: 0,
                max: 100,
                value: 50,
                description: "Add more green with a number between 0 and 100."
            }, {
                name: "blue",
                type: "Number",
                size: 3,
                min: 0,
                max: 100,
                value: 90,
                description: "Add more blue with a number from 0 to 100."
            }]
        }, {
            id: "FathersCTA",
            name: "FathersDay",
            viewClass: "FathersCTAPlaythingView",
            enabled: !1,
            mobileEnabled: !1,
            androidMobile: !1,
            zIndex: "150",
            centerOffsetX: "-1%",
            editable: []
        }]
    }
}]);
